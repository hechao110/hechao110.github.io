<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>kudu | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="KuDu一概述背景介绍在KUDU之前，大数据主要以两种方式存储； （1）静态数据： 以 HDFS 引擎作为存储引擎，适用于高吞吐量的离线大数据分析场景。 这类存储的局限性是数据无法进行随机的读写。 （2）动态数据： 以 HBase、Cassandra 作为存储引擎，适用于大数据随机读写场景。 局限性是批量读取吞吐量远不如 HDFS，不适用于批量数据分析的场景。 从上面分析可知，这两种数据在存储方式">
<meta property="og:type" content="article">
<meta property="og:title" content="kudu">
<meta property="og:url" content="http://yoursite.com/2019/08/08/kudu/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="KuDu一概述背景介绍在KUDU之前，大数据主要以两种方式存储； （1）静态数据： 以 HDFS 引擎作为存储引擎，适用于高吞吐量的离线大数据分析场景。 这类存储的局限性是数据无法进行随机的读写。 （2）动态数据： 以 HBase、Cassandra 作为存储引擎，适用于大数据随机读写场景。 局限性是批量读取吞吐量远不如 HDFS，不适用于批量数据分析的场景。 从上面分析可知，这两种数据在存储方式">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/t.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/t2.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/dcs.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/dcs2.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/dcs3.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/f.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/w.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/r.png">
<meta property="og:image" content="https://manzhong.github.io/images/kudu/updata.png">
<meta property="og:updated_time" content="2019-08-08T03:44:36.855Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kudu">
<meta name="twitter:description" content="KuDu一概述背景介绍在KUDU之前，大数据主要以两种方式存储； （1）静态数据： 以 HDFS 引擎作为存储引擎，适用于高吞吐量的离线大数据分析场景。 这类存储的局限性是数据无法进行随机的读写。 （2）动态数据： 以 HBase、Cassandra 作为存储引擎，适用于大数据随机读写场景。 局限性是批量读取吞吐量远不如 HDFS，不适用于批量数据分析的场景。 从上面分析可知，这两种数据在存储方式">
<meta name="twitter:image" content="https://manzhong.github.io/images/kudu/t.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-kudu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/kudu/" class="article-date">
  <time datetime="2019-08-08T03:40:26.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      kudu
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KuDu"><a href="#KuDu" class="headerlink" title="KuDu"></a>KuDu</h1><h2 id="一概述"><a href="#一概述" class="headerlink" title="一概述"></a>一概述</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在KUDU之前，大数据主要以两种方式存储；</p>
<p>（1）静态数据：</p>
<p>以 HDFS 引擎作为存储引擎，适用于高吞吐量的离线大数据分析场景。</p>
<p>这类存储的局限性是数据无法进行随机的读写。</p>
<p>（2）动态数据：</p>
<p>以 HBase、Cassandra 作为存储引擎，适用于大数据随机读写场景。</p>
<p>局限性是批量读取吞吐量远不如 HDFS，不适用于批量数据分析的场景。</p>
<p>从上面分析可知，这两种数据在存储方式上完全不同，进而导致使用场景完全不同，但在真实的场景中，边界可能没有那么清晰，面对既需要随机读写，又需要批量分析的大数据场景，该如何选择呢？</p>
<p>这个场景中，单种存储引擎无法满足业务需求，我们需要通过多种大数据工具组合来满足这一需求</p>
<p><a href="https://manzhong.github.io/images/kudu/t.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/t.png" alt="img"></a></p>
<p>如上图所示，数据实时写入 HBase，实时的数据更新也在 HBase 完成，为了应对 OLAP 需求，我们定时将 HBase 数据写成静态的文件（如：Parquet）导入到 OLAP 引擎（如：Impala、hive）。这一架构能满足既需要随机读写，又可以支持 OLAP 分析的场景，但他有如下缺点：</p>
<p>(1)<strong>架构复杂</strong>。从架构上看，数据在HBase、消息队列、HDFS 间流转，涉及环节太多，运维成本很高。并且每个环节需要保证高可用，都需要维护多个副本，存储空间也有一定的浪费。最后数据在多个系统上，对数据安全策略、监控等都提出了挑战。</p>
<p>(2)<strong>时效性低</strong>。数据从HBase导出成静态文件是周期性的，一般这个周期是一天（或一小时），在时效性上不是很高。</p>
<p>(3)<strong>难以应对后续的更新</strong>。真实场景中，总会有数据是延迟到达的。如果这些数据之前已经从HBase导出到HDFS，新到的变更数据就难以处理了，一个方案是把原有数据应用上新的变更后重写一遍，但这代价又很高。</p>
<p>为了解决上述架构的这些问题，KUDU应运而生。<strong>KUDU</strong>的定位是Fast Analytics on Fast Data，<strong>是一个既支持随机读写、又支持 OLAP 分析的大数据存储引擎</strong>。</p>
<p>KUDU 是一个折中的产品，在 HDFS 和 HBase 这两个偏科生中平衡了随机读写和批量分析的性能。从 KUDU 的诞生可以说明一个观点：底层的技术发展很多时候都是上层的业务推动的，脱离业务的技术很可能是空中楼阁。</p>
<p>kudu是什么</p>
<ul>
<li>是一个大数据存储引擎 用于大数据的存储，结合其他软件开展数据分析。</li>
<li>汲取了hdfs中高吞吐数据的能力和hbase中高随机读写数据的能力</li>
<li>既满足有传统OLAP分析 又满足于随机读写访问数据</li>
<li>kudu来自于cloudera 后来贡献给了apache</li>
</ul>
<p>kudu应用场景</p>
<p>适用于那些既有随机访问，也有批量数据扫描的复合场景</p>
<p>高计算量的场景</p>
<p>使用了高性能的存储设备，包括使用更多的内存</p>
<p>支持数据更新，避免数据反复迁移</p>
<p>支持跨地域的实时数据备份和查询</p>
<h2 id="二架构"><a href="#二架构" class="headerlink" title="二架构"></a>二架构</h2><ul>
<li>kudu集群是主从架构<ul>
<li>主角色 master ：管理集群 管理元数据</li>
<li>从角色 tablet server：负责最终数据的存储 对外提供数据读写能力 里面存储的都是一个个tablet</li>
</ul>
</li>
<li>kudu tablet<ul>
<li>是kudu表中的数据水平分区 一个表可以划分成为多个tablet(类似于hbase region)</li>
<li>tablet中主键是不重复连续的 所有tablet加起来就是一个table的所有数据</li>
<li>tablet在存储的时候 会进行冗余存放 设置多个副本</li>
<li>在一个tablet所有冗余中 任意时刻 一个是leader 其他的冗余都是follower</li>
</ul>
</li>
</ul>
<p>与HDFS和HBase相似，Kudu使用单个的Master节点，用来管理集群的元数据，并且使用任意数量的Tablet Server（类似HBase中的RegionServer角色）节点用来存储实际数据。可以部署多个Master节点来提高容错性。</p>
<p><a href="https://manzhong.github.io/images/kudu/t2.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/t2.png" alt="img"></a></p>
<h2 id="1．-Table"><a href="#1．-Table" class="headerlink" title="1． Table"></a>1． Table</h2><p>表（Table）是数据库中用来存储数据的对象，是有结构的数据集合。kudu中的表具有schema（纲要）和全局有序的primary key（主键）。kudu中一个table会被水平分成多个被称之为tablet的片段。</p>
<h2 id="2．-Tablet"><a href="#2．-Tablet" class="headerlink" title="2． Tablet"></a>2． Tablet</h2><p>一个 tablet 是一张 table连续的片段，tablet是kudu表的水平分区，类似于HBase的region。每个tablet存储着一定连续range的数据（key），且tablet两两间的range不会重叠。一张表的所有tablet包含了这张表的所有key空间。</p>
<p>tablet 会冗余存储。放置到多个 tablet server上，并且在任何给定的时间点，其中一个副本被认为是leader tablet,其余的被认之为follower tablet。每个tablet都可以进行数据的读请求，但只有Leader tablet负责写数据请求。</p>
<h2 id="3．-Tablet-Server"><a href="#3．-Tablet-Server" class="headerlink" title="3． Tablet Server"></a>3． Tablet Server</h2><p>tablet server集群中的小弟，负责数据存储，并提供数据读写服务</p>
<p>一个 tablet server 存储了table表的tablet，向kudu client 提供读取数据服务。对于给定的 tablet，一个tablet server 充当 leader，其他 tablet server 充当该 tablet 的 follower 副本。</p>
<p>只有 leader服务写请求，然而 leader 或 followers 为每个服务提供读请求 。一个 tablet server 可以服务多个 tablets ，并且一个 tablet 可以被多个 tablet servers 服务着。</p>
<h2 id="4．-Master-Server"><a href="#4．-Master-Server" class="headerlink" title="4． Master Server"></a>4． Master Server</h2><p>集群中的老大，负责集群管理、元数据管理等功能。</p>
<h2 id="三-kudu安装"><a href="#三-kudu安装" class="headerlink" title="三 kudu安装"></a>三 kudu安装</h2><p>1节点规划</p>
<table>
<thead>
<tr>
<th align="left"><strong>节点</strong></th>
<th align="left"><strong>kudu-master</strong></th>
<th align="left"><strong>kudu-tserver</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">node01</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">node02</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">node03</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>本次配置node01 和node02 不配置 kudu-master</p>
<p>2本地yum源配置</p>
<p>配过了在 node03上</p>
<p>3 安装KUDU</p>
<table>
<thead>
<tr>
<th align="left"><strong>服务器</strong></th>
<th align="left"><strong>安装命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">node01</td>
<td align="left">yum install -y kudu kudu-tserver kudu-client0 kudu-client-devel</td>
</tr>
<tr>
<td align="left">node02</td>
<td align="left">yum install -y kudu kudu-tserver kudu-client0 kudu-client-devel</td>
</tr>
<tr>
<td align="left">node03</td>
<td align="left">yum install -y kudu kudu-master kudu-tserver kudu-client0 kudu-client-devel</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install kudu # Kudu的基本包</span><br><span class="line">yum install kudu-master # KuduMaster </span><br><span class="line">yum install kudu-tserver # KuduTserver </span><br><span class="line">yum install kudu-client0 #Kudu C ++客户端共享库</span><br><span class="line">yum install kudu-client-devel # Kudu C ++客户端共享库 SDK</span><br></pre></td></tr></table></figure>

<p>4 kudu节点配置</p>
<p>安装完成之后。 需要在所有节点的/etc/kudu/conf目录下有两个文件：master.gflagfile和tserver.gflagfile。</p>
<h3 id="1-1．-修改master-gflagfile"><a href="#1-1．-修改master-gflagfile" class="headerlink" title="1.1． 修改master.gflagfile"></a>1.1． 修改master.gflagfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/kudu/conf/master.gflagfile</span><br><span class="line"># Do not modify these two lines. If you wish to change these variables,</span><br><span class="line"># modify them in /etc/default/kudu-master.</span><br><span class="line">--fromenv=rpc_bind_addresses</span><br><span class="line">--fromenv=log_dir</span><br><span class="line">--fs_wal_dir=/export/servers/kudu/master</span><br><span class="line">--fs_data_dirs=/export/servers/kudu/master</span><br><span class="line">--master_addresses=node03:7051     若为集node01:7051,node02:7051,node03:7051 若为单节点 则这句注释掉</span><br><span class="line">若为单节点 且没注释掉 则启动报错</span><br></pre></td></tr></table></figure>

<h3 id="1-2-修改tserver-gflagfile"><a href="#1-2-修改tserver-gflagfile" class="headerlink" title="1.2 修改tserver.gflagfile"></a>1.2 修改tserver.gflagfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Do not modify these two lines. If you wish to change these variables,</span><br><span class="line"># modify them in /etc/default/kudu-tserver.</span><br><span class="line">--fromenv=rpc_bind_addresses</span><br><span class="line">--fromenv=log_dir</span><br><span class="line">--fs_wal_dir=/export/servers/kudu/tserver</span><br><span class="line">--fs_data_dirs=/export/servers/kudu/tserver</span><br><span class="line">--tserver_master_addrs=node03:7051  若为集node01:7051,node02:7051,node03:7051</span><br></pre></td></tr></table></figure>

<h3 id="1-3修改-etc-default-kudu-master"><a href="#1-3修改-etc-default-kudu-master" class="headerlink" title="1.3修改 /etc/default/kudu-master"></a>1.3修改 /etc/default/kudu-master</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FLAGS_log_dir=/var/log/kudu</span><br><span class="line">#每台机器的master地址要与主机名一致,这里是在node03上</span><br><span class="line">export FLAGS_rpc_bind_addresses=node03:7051</span><br></pre></td></tr></table></figure>

<h3 id="1-4修改-etc-default-kudu-tserver"><a href="#1-4修改-etc-default-kudu-tserver" class="headerlink" title="1.4修改 /etc/default/kudu-tserver"></a>1.4修改 /etc/default/kudu-tserver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FLAGS_log_dir=/var/log/kudu</span><br><span class="line">#每台机器的tserver地址要与主机名一致，这里是在node03上</span><br><span class="line">export FLAGS_rpc_bind_addresses=node03:7050</span><br></pre></td></tr></table></figure>

<p>kudu默认用户就是KUDU，所以需要将/export/servers/kudu权限修改成kudu：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /export/servers/kudu</span><br><span class="line">chown -R kudu:kudu /export/servers/kudu</span><br></pre></td></tr></table></figure>

<p>(如果使用的是普通的用户，那么最好配置sudo权限)/etc/sudoers文件中添加：</p>
<p><strong>kudu集群的启动与关闭</strong></p>
<p>1 ntp服务的安装</p>
<p>启动的时候要注意时间同步</p>
<p>安装ntp服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service ntpd start </span><br><span class="line">chkconfig ntpd on</span><br></pre></td></tr></table></figure>

<p>可以在每台服务器执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ntpd restart</span><br><span class="line">启动</span><br><span class="line">service kudu-master start</span><br><span class="line">service kudu-tserver start</span><br><span class="line">关闭</span><br><span class="line">service kudu-master stop</span><br><span class="line">service kudu-tserver stop</span><br><span class="line">kudu的web管理界面。http://master主机名:8051</span><br><span class="line"></span><br><span class="line">可以查看每个机器上master相关信息。http://node03:8051/masters    一定为8051 不为7051</span><br><span class="line"></span><br><span class="line">tserver 的web地址  http://node03:8051/tablet-servers</span><br></pre></td></tr></table></figure>

<p>安装属于事项</p>
<h3 id="1-1给普通用户授予sudo出错"><a href="#1-1给普通用户授予sudo出错" class="headerlink" title="1.1给普通用户授予sudo出错"></a>1.1给普通用户授予sudo出错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo: /etc/sudoers is world writable</span><br><span class="line">解决方式：``pkexec chmod 555 /etc/sudoers</span><br></pre></td></tr></table></figure>

<h3 id="1-2-启动kudu的时候报错"><a href="#1-2-启动kudu的时候报错" class="headerlink" title="1.2 启动kudu的时候报错"></a>1.2 启动kudu的时候报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Failed to start Kudu Master Server. Return value: 1 [FAILED]</span><br><span class="line">去日志文件中查看：</span><br><span class="line">Service unavailable: Cannot initialize clock: Errorreading clock. Clock considered</span><br><span class="line">unsynchronized</span><br><span class="line">解决：</span><br><span class="line">第一步：首先检查是否有安装ntp：如果没有安装则使用以下命令安装：</span><br><span class="line">yum -y install ntp</span><br><span class="line">第二步：设置随机启动：</span><br><span class="line">service ntpd start</span><br><span class="line">chkconfig ntpd on</span><br></pre></td></tr></table></figure>

<h3 id="1-3-启动过程中报错"><a href="#1-3-启动过程中报错" class="headerlink" title="1.3 启动过程中报错"></a>1.3 启动过程中报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Invalid argument: Unable to initialize catalog manager: Failed to initialize sys</span><br><span class="line">tables</span><br><span class="line">async: on-disk master list</span><br><span class="line">解决：</span><br><span class="line">（1）：停掉master和tserver</span><br><span class="line">（2）：删除掉之前所有的/export/servers/kudu/master/*和/export/servers/kudu/tserver/*</span><br></pre></td></tr></table></figure>

<h3 id="1-4-启动过程中报错"><a href="#1-4-启动过程中报错" class="headerlink" title="1.4 启动过程中报错"></a>1.4 启动过程中报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: Could not create new FS layout: unable to create file system roots: unable to</span><br><span class="line">write instance metadata: Call to mkstemp() failed on name template</span><br><span class="line">/export/servers/kudu/master/instance.kudutmp.XXXXXX: Permission denied (error 13)</span><br><span class="line">这是因为kudu默认使用kudu权限进行执行，可能遇到文件夹的权限不一致情况，更改文件夹权限即可</span><br></pre></td></tr></table></figure>

<h2 id="四-Java操作kudu"><a href="#四-Java操作kudu" class="headerlink" title="四 Java操作kudu"></a>四 Java操作kudu</h2><p>###1 创建maven工程 导入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;  </span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.kudu&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;kudu-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2 初始化方法"></a>2 初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestKudu &#123;</span><br><span class="line"></span><br><span class="line">    //声明全局变量 KuduClient后期通过它来操作kudu表</span><br><span class="line">    private KuduClient kuduClient;</span><br><span class="line">    //指定kuduMaster地址</span><br><span class="line">    private String kuduMaster;</span><br><span class="line">    //指定表名</span><br><span class="line">    private String tableName;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        //初始化操作</span><br><span class="line">        kuduMaster=&quot;node03:7051&quot;;</span><br><span class="line">        //指定表名</span><br><span class="line">        tableName=&quot;student&quot;;</span><br><span class="line">        KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMaster);</span><br><span class="line">		//设置客户端与kudu集群socket超时时间</span><br><span class="line">        kuduClientBuilder.defaultSocketReadTimeoutMs(10000);</span><br><span class="line">        kuduClient=kuduClientBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3 创建表"></a>3 创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建表</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void createTable() throws KuduException &#123;</span><br><span class="line">    //判断表是否存在，不存在就构建</span><br><span class="line">    if(!kuduClient.tableExists(tableName))&#123;</span><br><span class="line"></span><br><span class="line">        //构建创建表的schema信息-----就是表的字段和类型</span><br><span class="line">        ArrayList&lt;ColumnSchema&gt; columnSchemas = new ArrayList&lt;ColumnSchema&gt;();</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;id&quot;, Type.INT32).key(true).build());</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;name&quot;, Type.STRING).build());</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;age&quot;, Type.INT32).build());</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;sex&quot;, Type.INT32).build());</span><br><span class="line">        Schema schema = new Schema(columnSchemas);</span><br><span class="line"></span><br><span class="line">        //指定创建表的相关属性</span><br><span class="line">        CreateTableOptions options = new CreateTableOptions();</span><br><span class="line">        ArrayList&lt;String&gt; partitionList = new ArrayList&lt;String&gt;();</span><br><span class="line">        //指定kudu表的分区字段是什么</span><br><span class="line">        partitionList.add(&quot;id&quot;);    //  按照 id.hashcode % 分区数 = 分区号</span><br><span class="line">        options.addHashPartitions(partitionList,6);</span><br><span class="line"></span><br><span class="line">        kuduClient.createTable(tableName,schema,options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-插入数据"><a href="#4-插入数据" class="headerlink" title="4 插入数据"></a>4 插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 向表加载数据</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void insertTable() throws KuduException &#123;</span><br><span class="line">      //向表加载数据需要一个kuduSession对象</span><br><span class="line">      KuduSession kuduSession = kuduClient.newSession();</span><br><span class="line">      //设置提交数据为自动flush</span><br><span class="line">      kuduSession.setFlushMode(SessionConfiguration.FlushMode.AUTO_FLUSH_SYNC);</span><br><span class="line"></span><br><span class="line">      //需要使用kuduTable来构建Operation的子类实例对象  就是打开本次操作的表名</span><br><span class="line">      KuduTable kuduTable = kuduClient.openTable(tableName);</span><br><span class="line">//此处需要kudutable 来构建operation的子类实例对象  此处 为insert</span><br><span class="line">      for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">          Insert insert = kuduTable.newInsert();</span><br><span class="line">          PartialRow row = insert.getRow();</span><br><span class="line">          row.addInt(&quot;id&quot;,i);</span><br><span class="line">          row.addString(&quot;name&quot;,&quot;zhangsan-&quot;+i);</span><br><span class="line">          row.addInt(&quot;age&quot;,20+i);</span><br><span class="line">          row.addInt(&quot;sex&quot;,i%2);</span><br><span class="line"></span><br><span class="line">          kuduSession.apply(insert);//最后实现执行数据的加载操作</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-查询数据"><a href="#5-查询数据" class="headerlink" title="5 查询数据"></a>5 查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 查询表的数据结果</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void queryData() throws KuduException &#123;</span><br><span class="line"></span><br><span class="line">        //构建一个查询的扫描器 在扫描器中指定 表名</span><br><span class="line">        KuduScanner.KuduScannerBuilder kuduScannerBuilder = kuduClient.newScannerBuilder(kuduClient.openTable(tableName));</span><br><span class="line">        //创建集合 用于存储扫描的字段信息</span><br><span class="line">        ArrayList&lt;String&gt; columnsList = new ArrayList&lt;String&gt;();</span><br><span class="line">        columnsList.add(&quot;id&quot;);</span><br><span class="line">        columnsList.add(&quot;name&quot;);</span><br><span class="line">        columnsList.add(&quot;age&quot;);</span><br><span class="line">        columnsList.add(&quot;sex&quot;);</span><br><span class="line">        kuduScannerBuilder.setProjectedColumnNames(columnsList);</span><br><span class="line">        // 调用build方法执行扫描,返回结果集</span><br><span class="line">        KuduScanner kuduScanner = kuduScannerBuilder.build();</span><br><span class="line">        //遍历</span><br><span class="line">        while (kuduScanner.hasMoreRows())&#123;</span><br><span class="line">            RowResultIterator rowResults = kuduScanner.nextRows();</span><br><span class="line"></span><br><span class="line">             while (rowResults.hasNext())&#123;</span><br><span class="line">                 RowResult row = rowResults.next(); //拿到的是一行数据</span><br><span class="line">                 int id = row.getInt(&quot;id&quot;);</span><br><span class="line">                 String name = row.getString(&quot;name&quot;);</span><br><span class="line">                 int age = row.getInt(&quot;age&quot;);</span><br><span class="line">                 int sex = row.getInt(&quot;sex&quot;);</span><br><span class="line"></span><br><span class="line">                 System.out.println(&quot;id=&quot;+id+&quot;  name=&quot;+name+&quot;  age=&quot;+age+&quot;  sex=&quot;+sex);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-修改数据"><a href="#6-修改数据" class="headerlink" title="6 修改数据"></a>6 修改数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 修改表的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void updateData() throws KuduException &#123;</span><br><span class="line">        //修改表的数据需要一个kuduSession对象</span><br><span class="line">        KuduSession kuduSession = kuduClient.newSession();</span><br><span class="line">        //设置提交数据为自动flush</span><br><span class="line">        kuduSession.setFlushMode(SessionConfiguration.FlushMode.AUTO_FLUSH_SYNC);</span><br><span class="line"></span><br><span class="line">        //需要使用kuduTable来构建Operation的子类实例对象</span><br><span class="line">        KuduTable kuduTable = kuduClient.openTable(tableName);</span><br><span class="line"></span><br><span class="line">        //Update update = kuduTable.newUpdate(); //如果id不存在 ,就什么也不操作</span><br><span class="line">        Upsert upsert = kuduTable.newUpsert(); //如果id存在就表示修改，不存在就新增</span><br><span class="line">        PartialRow row = upsert.getRow();</span><br><span class="line">        row.addInt(&quot;id&quot;,100);</span><br><span class="line">        row.addString(&quot;name&quot;,&quot;zhangsan-100&quot;);</span><br><span class="line">        row.addInt(&quot;age&quot;,100);</span><br><span class="line">        row.addInt(&quot;sex&quot;,0);</span><br><span class="line"></span><br><span class="line">        kuduSession.apply(upsert);//最后实现执行数据的修改操作</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7删除数据"><a href="#7删除数据" class="headerlink" title="7删除数据"></a>7删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 删除数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void deleteData() throws KuduException &#123;</span><br><span class="line">        //删除表的数据需要一个kuduSession对象</span><br><span class="line">        KuduSession kuduSession = kuduClient.newSession();</span><br><span class="line">        kuduSession.setFlushMode(SessionConfiguration.FlushMode.AUTO_FLUSH_SYNC);</span><br><span class="line"></span><br><span class="line">        //需要使用kuduTable来构建Operation的子类实例对象</span><br><span class="line">        KuduTable kuduTable = kuduClient.openTable(tableName);</span><br><span class="line"></span><br><span class="line">        Delete delete = kuduTable.newDelete();</span><br><span class="line">        PartialRow row = delete.getRow();</span><br><span class="line">        row.addInt(&quot;id&quot;,100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        kuduSession.apply(delete);//最后实现执行数据的删除操作</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-删除表"><a href="#8-删除表" class="headerlink" title="8 删除表"></a>8 删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void dropTable() throws KuduException &#123;</span><br><span class="line"></span><br><span class="line">    if(kuduClient.tableExists(tableName))&#123;</span><br><span class="line">        kuduClient.deleteTable(tableName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-kudu的分区方式"><a href="#9-kudu的分区方式" class="headerlink" title="9 kudu的分区方式"></a>9 kudu的分区方式</h3><p>为了提供可扩展性，Kudu 表被划分为称为 tablet 的单元，并分布在许多 tablet servers 上。行总是属于单个tablet 。将行分配给 tablet 的方法由在表创建期间设置的表的分区决定。 kudu提供了3种分区方式。</p>
<h4 id="1-范围分区Range-Partitioning"><a href="#1-范围分区Range-Partitioning" class="headerlink" title="1 范围分区Range Partitioning"></a>1 范围分区Range Partitioning</h4><p>范围分区可以根据存入数据的数据量，均衡的存储到各个机器上，防止机器出现负载不均衡现象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 测试分区：</span><br><span class="line">  * RangePartition</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void testRangePartition() throws KuduException &#123;</span><br><span class="line">     //设置表的schema</span><br><span class="line">     LinkedList&lt;ColumnSchema&gt; columnSchemas = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">     columnSchemas.add(new Column(&quot;id&quot;, Type.INT32,true));</span><br><span class="line">     columnSchemas.add(new Column(&quot;WorkId&quot;, Type.INT32,false));</span><br><span class="line">     columnSchemas.add(new Column(&quot;Name&quot;, Type.STRING,false));</span><br><span class="line">     columnSchemas.add(new Column(&quot;Gender&quot;, Type.STRING,false));</span><br><span class="line">     columnSchemas.add(new Column(&quot;Photo&quot;, Type.STRING,false));</span><br><span class="line"></span><br><span class="line">     //创建schema</span><br><span class="line">     Schema schema = new Schema(columnSchemas);</span><br><span class="line"></span><br><span class="line">     //创建表时提供的所有选项</span><br><span class="line">     CreateTableOptions tableOptions = new CreateTableOptions();</span><br><span class="line">     //设置副本数</span><br><span class="line">     //tableOptions.setNumReplicas(1);</span><br><span class="line">     //设置范围分区的规则</span><br><span class="line">     LinkedList&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">     parcols.add(&quot;id&quot;);</span><br><span class="line">     //设置按照那个字段进行range分区</span><br><span class="line">     tableOptions.setRangePartitionColumns(parcols);</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      * range</span><br><span class="line">      *  0 &lt; value &lt; 10</span><br><span class="line">      * 10 &lt;= value &lt; 20</span><br><span class="line">      * 20 &lt;= value &lt; 30</span><br><span class="line">      * ........</span><br><span class="line">      * 80 &lt;= value &lt; 90</span><br><span class="line">      * */</span><br><span class="line">     int count=0;</span><br><span class="line">     for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">         //范围开始</span><br><span class="line">         PartialRow lower = schema.newPartialRow();</span><br><span class="line">         lower.addInt(&quot;id&quot;,count);</span><br><span class="line"></span><br><span class="line">         //范围结束</span><br><span class="line">         PartialRow upper = schema.newPartialRow();</span><br><span class="line">         count +=10;</span><br><span class="line">         upper.addInt(&quot;id&quot;,count);</span><br><span class="line"></span><br><span class="line">         //设置每一个分区的范围</span><br><span class="line">         tableOptions.addRangePartition(lower,upper);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         kuduClient.createTable(&quot;t-range-partition&quot;,schema,tableOptions);</span><br><span class="line">     &#125; catch (KuduException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">      kuduClient.close();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-哈希分区Hash-Partitioning-为kudu的默认分区"><a href="#2-哈希分区Hash-Partitioning-为kudu的默认分区" class="headerlink" title="2 哈希分区Hash Partitioning 为kudu的默认分区"></a>2 哈希分区Hash Partitioning 为kudu的默认分区</h4><p>哈希分区通过哈希值将行分配到许多 buckets (存储桶 )之一； 哈希分区是一种有效的策略，当不需要对表进行有序访问时。哈希分区对于在 tablet 之间随机散布这些功能是有效的，这有助于减轻热点和 tablet 大小不均匀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 测试分区：</span><br><span class="line">     * hash分区</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testHashPartition() throws KuduException &#123;</span><br><span class="line">        //设置表的schema</span><br><span class="line">        LinkedList&lt;ColumnSchema&gt; columnSchemas = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">        columnSchemas.add(new Column(&quot;id&quot;, Type.INT32,true));</span><br><span class="line">        columnSchemas.add(new Column(&quot;WorkId&quot;, Type.INT32,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Name&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Gender&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Photo&quot;, Type.STRING,false));</span><br><span class="line"></span><br><span class="line">        //创建schema</span><br><span class="line">        Schema schema = new Schema(columnSchemas);</span><br><span class="line"></span><br><span class="line">        //创建表时提供的所有选项</span><br><span class="line">        CreateTableOptions tableOptions = new CreateTableOptions();</span><br><span class="line">        //设置副本数</span><br><span class="line">        tableOptions.setNumReplicas(1);</span><br><span class="line">        //设置范围分区的规则</span><br><span class="line">        LinkedList&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">        parcols.add(&quot;id&quot;);</span><br><span class="line">        //设置按照那个字段进行range分区</span><br><span class="line">        tableOptions.addHashPartitions(parcols,6);</span><br><span class="line">        try &#123;</span><br><span class="line">            kuduClient.createTable(&quot;t-hash-partition&quot;,schema,tableOptions);</span><br><span class="line">        &#125; catch (KuduException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kuduClient.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-多级分区Multilevel-Partitioning"><a href="#3-多级分区Multilevel-Partitioning" class="headerlink" title="3 多级分区Multilevel Partitioning"></a>3 多级分区Multilevel Partitioning</h4><p>Kudu 允许一个表在单个表上组合多级分区。 当正确使用时，多级分区可以保留各个分区类型的优点，同时减少每个分区的缺点</p>
<p>如 范围分区 为5个 hash分区为3个 则多级分区为15个 (即在范围分区里面有进行了hash分区)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 测试分区：</span><br><span class="line">     * 多级分区</span><br><span class="line">     * Multilevel Partition</span><br><span class="line">     * 混合使用hash分区和range分区</span><br><span class="line">     *</span><br><span class="line">     * 哈希分区有利于提高写入数据的吞吐量，而范围分区可以避免tablet无限增长问题，</span><br><span class="line">     * hash分区和range分区结合，可以极大的提升kudu的性能</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMultilevelPartition() throws KuduException &#123;</span><br><span class="line">        //设置表的schema</span><br><span class="line">        LinkedList&lt;ColumnSchema&gt; columnSchemas = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">        columnSchemas.add(new Column(&quot;id&quot;, Type.INT32,true));</span><br><span class="line">        columnSchemas.add(new Column(&quot;WorkId&quot;, Type.INT32,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Name&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Gender&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Photo&quot;, Type.STRING,false));</span><br><span class="line"></span><br><span class="line">        //创建schema</span><br><span class="line">        Schema schema = new Schema(columnSchemas);</span><br><span class="line">        </span><br><span class="line">        //创建表时提供的所有选项</span><br><span class="line">        CreateTableOptions tableOptions = new CreateTableOptions();</span><br><span class="line">        //设置副本数</span><br><span class="line">        //tableOptions.setNumReplicas(1);</span><br><span class="line">        //设置范围分区的规则</span><br><span class="line">        LinkedList&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">        parcols.add(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        //hash分区</span><br><span class="line">        tableOptions.addHashPartitions(parcols,5);</span><br><span class="line"></span><br><span class="line">        //range分区</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        //指定上界</span><br><span class="line">            PartialRow lower = schema.newPartialRow();</span><br><span class="line">            lower.addInt(&quot;id&quot;,count);</span><br><span class="line">            count+=10;</span><br><span class="line">			//指定下界</span><br><span class="line">            PartialRow upper = schema.newPartialRow();</span><br><span class="line">            upper.addInt(&quot;id&quot;,count);</span><br><span class="line">            tableOptions.addRangePartition(lower,upper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            kuduClient.createTable(&quot;t-multilevel-partition&quot;,schema,tableOptions);</span><br><span class="line">        &#125; catch (KuduException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        kuduClient.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-kudu集成impala"><a href="#五-kudu集成impala" class="headerlink" title="五 kudu集成impala"></a>五 kudu集成impala</h2><h3 id="1-impala的配置修改"><a href="#1-impala的配置修改" class="headerlink" title="1 impala的配置修改"></a>1 impala的配置修改</h3><p>可选项 若配置以后写的时候指定 master地址即可</p>
<p>在每一个服务器的impala的配置文件中添加如下配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/impala</span><br></pre></td></tr></table></figure>

<p><code>在</code>IMPALA_SERVER_ARGS`下添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-kudu_master_hosts=node-1:7051,node-2:7051,node-3:7051</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">### 2 创建kudu表</span><br><span class="line"></span><br><span class="line">需要先启动hdfs、hive、kudu、impala。使用impala的shell控制台。</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">impala-shell</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">内部表:impala中删除,kudu里也会删除  </span><br><span class="line"></span><br><span class="line">外部表: impala中删除,kudu中不会删除.</span><br><span class="line"></span><br><span class="line">2.1 内部表</span><br><span class="line"></span><br><span class="line">内部表由Impala管理，当您从Impala中删除时，数据和表确实被删除。当您使用Impala创建新表时，它通常是内部表。</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line">CREATE TABLE my_first_table</span><br><span class="line">(</span><br><span class="line">id BIGINT,</span><br><span class="line">name STRING,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH PARTITIONS 16 </span><br><span class="line">STORED AS KUDU</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">&apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;,  //这种就是没有配置以上的 指定地址</span><br><span class="line">&apos;kudu.table_name&apos; = &apos;my_first_table&apos;</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">在 CREATE TABLE 语句中，必须首先列出构成主键的列。</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">2.2 外部表</span><br><span class="line"></span><br><span class="line">外部表（创建者CREATE EXTERNAL TABLE）不受Impala管理，并且删除此表不会将表从其源位置（此处为Kudu）丢弃。相反，它只会去除Impala和Kudu之间的映射。这是Kudu提供的用于将现有表映射到Impala的语法。</span><br><span class="line"></span><br><span class="line">首先使用java创建kudu表：</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">public class CreateTable &#123;</span><br><span class="line">        private static ColumnSchema newColumn(String name, Type type, boolean iskey) &#123;</span><br><span class="line">                ColumnSchema.ColumnSchemaBuilder column = new</span><br><span class="line">                    ColumnSchema.ColumnSchemaBuilder(name, type);</span><br><span class="line">                column.key(iskey);</span><br><span class="line">                return column.build();</span><br><span class="line">        &#125;</span><br><span class="line">    public static void main(String[] args) throws KuduException &#123;</span><br><span class="line">        // master地址</span><br><span class="line">        final String masteraddr = &quot;node1,node2,node3&quot;;</span><br><span class="line">        // 创建kudu的数据库链接</span><br><span class="line">        KuduClient client = new</span><br><span class="line">     KuduClient.KuduClientBuilder(masteraddr).defaultSocketReadTimeoutMs(6000).build();</span><br><span class="line">        </span><br><span class="line">        // 设置表的schema</span><br><span class="line">        List&lt;ColumnSchema&gt; columns = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">        columns.add(newColumn(&quot;CompanyId&quot;, Type.INT32, true));</span><br><span class="line">        columns.add(newColumn(&quot;WorkId&quot;, Type.INT32, false));</span><br><span class="line">        columns.add(newColumn(&quot;Name&quot;, Type.STRING, false));</span><br><span class="line">        columns.add(newColumn(&quot;Gender&quot;, Type.STRING, false));</span><br><span class="line">        columns.add(newColumn(&quot;Photo&quot;, Type.STRING, false));</span><br><span class="line">        Schema schema = new Schema(columns);</span><br><span class="line">    //创建表时提供的所有选项</span><br><span class="line">    CreateTableOptions options = new CreateTableOptions();</span><br><span class="line">        </span><br><span class="line">    // 设置表的replica备份和分区规则</span><br><span class="line">    List&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">    parcols.add(&quot;CompanyId&quot;);</span><br><span class="line">    //设置表的备份数</span><br><span class="line">        options.setNumReplicas(1);</span><br><span class="line">    //设置range分区</span><br><span class="line">    options.setRangePartitionColumns(parcols);</span><br><span class="line">        </span><br><span class="line">    //设置hash分区和数量</span><br><span class="line">    options.addHashPartitions(parcols, 3);</span><br><span class="line">    try &#123;</span><br><span class="line">    client.createTable(&quot;person&quot;, schema, options);</span><br><span class="line">    &#125; catch (KuduException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">使用impala创建外部表 ， 将kudu的表映射到impala上。</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">在impala-shell中执行</span><br><span class="line"></span><br><span class="line">CREATE EXTERNAL TABLE `person` STORED AS KUDU</span><br><span class="line">TBLPROPERTIES(</span><br><span class="line">    &apos;kudu.table_name&apos; = &apos;person&apos;,</span><br><span class="line">    &apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;)</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### 3 使用impala对kudu进行DML</span><br><span class="line"></span><br><span class="line">1 插入数据</span><br><span class="line"></span><br><span class="line">impala 允许使用标准 SQL 语句将数据插入 Kudu 。</span><br><span class="line"></span><br><span class="line">首先建表：</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line">在impala-shell中</span><br><span class="line">CREATE TABLE my_first_table1</span><br><span class="line">(</span><br><span class="line">id BIGINT,</span><br><span class="line">name STRING,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH PARTITIONS 16</span><br><span class="line">STORED AS KUDU </span><br><span class="line">TBLPROPERTIES(</span><br><span class="line">    &apos;kudu.table_name&apos; = &apos;person1&apos;,</span><br><span class="line">    &apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;);</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">此示例插入单个行：</span><br></pre></td></tr></table></figure>

<p>INSERT INTO my_first_table VALUES (50, “zhangsan”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此示例插入3行：</span><br></pre></td></tr></table></figure>

<p>INSERT INTO my_first_table VALUES (1, “john”), (2, “jane”), (3, “jim”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">批量导入数据：</span><br><span class="line"></span><br><span class="line">从 Impala 和 Kudu 的角度来看，通常表现最好的方法通常是使用 Impala 中的 SELECT FROM 语句导入数据。</span><br></pre></td></tr></table></figure>

<p>INSERT INTO my_first_table SELECT * FROM temp1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 更新数据</span><br></pre></td></tr></table></figure>

<p>UPDATE my_first_table SET name=”xiaowang” where id =1 ;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 删除数据</span><br></pre></td></tr></table></figure>

<p>delete from my_first_table where id =2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 更改表属性</span><br><span class="line"></span><br><span class="line">4.1重命名impala表</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE PERSON RENAME TO person_temp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 4.2重新命名内部表的基础kudu表</span><br><span class="line"></span><br><span class="line">  				4.1.1创建内部表</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">CREATE TABLE kudu_student</span><br><span class="line">(</span><br><span class="line">CompanyId INT,</span><br><span class="line">WorkId INT,</span><br><span class="line">Name STRING,</span><br><span class="line">Gender STRING,</span><br><span class="line">Photo STRING,</span><br><span class="line">PRIMARY KEY(CompanyId)</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH PARTITIONS 16</span><br><span class="line">STORED AS KUDU</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">&apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;,</span><br><span class="line">&apos;kudu.table_name&apos; = &apos;student&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">				4.1.2如果表是内部表，则可以通过更改 kudu.table_name 属性重命名底层的 Kudu 表。</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE kudu_student SET TBLPROPERTIES(‘kudu.table_name’ = ‘new_student’);<br>&lt;!–￼33–&gt;</p>
<p>CREATE EXTERNAL TABLE external_table<br>    STORED AS KUDU<br>    TBLPROPERTIES (<br>    ‘kudu.master_addresses’ = ‘node1:7051,node2:7051,node3:7051’,<br>    ‘kudu.table_name’ = ‘person’<br>);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重新映射外部表，指向不同的kudu表：</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE external_table<br>SET TBLPROPERTIES(‘kudu.table_name’ = ‘hashTable’)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的操作是：将external_table映射的PERSON表重新指向hashTable表。</span><br><span class="line"></span><br><span class="line">4.4 更改kudu master地址</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE my_table<br>SET TBLPROPERTIES(‘kudu.master_addresses’ = ‘kudu-new-master.example.com:7051’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.5 将内部表改为外部表</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE my_table SET TBLPROPERTIES(‘EXTERNAL’ = ‘TRUE’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\##4 impala使用Java操作kudu</span><br><span class="line"></span><br><span class="line">对于impala而言，开发人员是可以通过JDBC连接impala的，有了JDBC，开发人员可以通过impala来间接操作 kudu。</span><br><span class="line"></span><br><span class="line">### 1 引入依赖</span><br></pre></td></tr></table></figure>

   <!--impala的jdbc操作--> 
<dependency>
        <groupid>com.cloudera</groupid>
        <artifactid>ImpalaJDBC41</artifactid>
        <version>2.5.42</version>
    </dependency>

<pre><code>&lt;!--Caused by : ClassNotFound : thrift.protocol.TPro--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;
    &lt;artifactId&gt;libfb303&lt;/artifactId&gt;
    &lt;version&gt;0.9.3&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;

&lt;!--Caused by : ClassNotFound : thrift.protocol.TPro--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;
    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;
    &lt;version&gt;0.9.3&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
    &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
            &lt;artifactId&gt;hive-service-rpc&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
            &lt;artifactId&gt;hive-service&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--导入hive--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
    &lt;artifactId&gt;hive-service&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2 jdbc连接impala操作kudu</span><br><span class="line"></span><br><span class="line">使用JDBC连接impala操作kudu，与JDBC连接mysql做更重增删改查基本一样。</span><br><span class="line"></span><br><span class="line">创建实体类</span><br></pre></td></tr></table></figure>

<p>package cn.itcast.impala.impala;</p>
<p>public class Person {<br>    private int companyId;<br>    private int workId;<br>    private  String name;<br>    private  String gender;<br>    private  String photo;</p>
<pre><code>public Person(int companyId, int workId, String name, String gender, String photo) {
    this.companyId = companyId;
    this.workId = workId;
    this.name = name;
    this.gender = gender;
    this.photo = photo;
}

public int getCompanyId() {
    return companyId;
}

public void setCompanyId(int companyId) {
    this.companyId = companyId;
}

public int getWorkId() {
    return workId;
}

public void setWorkId(int workId) {
    this.workId = workId;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public String getGender() {
    return gender;
}

public void setGender(String gender) {
    this.gender = gender;
}

public String getPhoto() {
    return photo;
}

public void setPhoto(String photo) {
    this.photo = photo;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### JDBC连接impala对kudu进行增删改查</span><br></pre></td></tr></table></figure>

<p>package cn.itcast.impala.impala;</p>
<p>import java.sql.*;</p>
<p>public class Contants {<br>    private static String JDBC_DRIVER=”com.cloudera.impala.jdbc41.Driver”;<br>    private static  String CONNECTION_URL=”jdbc:impala://node1:21050/default;auth=noSasl”;<br>     //定义数据库连接<br>    static Connection conn=null;<br>    //定义PreparedStatement对象<br>    static PreparedStatement ps=null;<br>    //定义查询的结果集<br>    static ResultSet rs= null;</p>
<pre><code>//数据库连接
public static Connection getConn(){
    try {
        Class.forName(JDBC_DRIVER);
        conn=DriverManager.getConnection(CONNECTION_URL);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return  conn;

}

//创建一个表
public static void createTable(){
    conn=getConn();
    String sql=&quot;CREATE TABLE impala_kudu_test&quot; +
            &quot;(&quot; +
            &quot;companyId BIGINT,&quot; +
            &quot;workId BIGINT,&quot; +
            &quot;name STRING,&quot; +
            &quot;gender STRING,&quot; +
            &quot;photo STRING,&quot; +
            &quot;PRIMARY KEY(companyId)&quot; +
            &quot;)&quot; +
            &quot;PARTITION BY HASH PARTITIONS 16 &quot; +
            &quot;STORED AS KUDU &quot; +
            &quot;TBLPROPERTIES (&quot; +
            &quot;&apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;,&quot; +
            &quot;&apos;kudu.table_name&apos; = &apos;impala_kudu_test&apos;&quot; +
            &quot;);&quot;;

    try {
        ps = conn.prepareStatement(sql);
        ps.execute();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}


//查询数据
public static ResultSet queryRows(){
    try {
        //定义执行的sql语句
        String sql=&quot;select * from impala_kudu_test&quot;;
        ps = getConn().prepareStatement(sql);
        rs= ps.executeQuery();
    } catch (SQLException e) {
        e.printStackTrace();
    }

    return  rs;
}

//打印结果
public  static void printRows(ResultSet rs){
    /**
     private int companyId;
     private int workId;
     private  String name;
     private  String gender;
     private  String photo;
     */

    try {
        while (rs.next()){
            //获取表的每一行字段信息
            int companyId = rs.getInt(&quot;companyId&quot;);
            int workId = rs.getInt(&quot;workId&quot;);
            String name = rs.getString(&quot;name&quot;);
            String gender = rs.getString(&quot;gender&quot;);
            String photo = rs.getString(&quot;photo&quot;);
            System.out.print(&quot;companyId:&quot;+companyId+&quot; &quot;);
            System.out.print(&quot;workId:&quot;+workId+&quot; &quot;);
            System.out.print(&quot;name:&quot;+name+&quot; &quot;);
            System.out.print(&quot;gender:&quot;+gender+&quot; &quot;);
            System.out.println(&quot;photo:&quot;+photo);

        }
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        if(ps!=null){
            try {
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn !=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}


//插入数据
public static void insertRows(Person person){
    conn=getConn();
    String sql=&quot;insert into table impala_kudu_test(companyId,workId,name,gender,photo) values(?,?,?,?,?)&quot;;

    try {
        ps=conn.prepareStatement(sql);
        //给占位符？赋值
        ps.setInt(1,person.getCompanyId());
        ps.setInt(2,person.getWorkId());
        ps.setString(3,person.getName());
        ps.setString(4,person.getGender());
        ps.setString(5,person.getPhoto());
        ps.execute();

    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        if(ps !=null){
            try {
                //关闭
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn !=null){
            try {
                  //关闭
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}

//更新数据
public static void updateRows(Person person){
   //定义执行的sql语句
    String sql=&quot;update impala_kudu_test set workId=&quot;+person.getWorkId()+
            &quot;,name=&apos;&quot;+person.getName()+&quot;&apos; ,&quot;+&quot;gender=&apos;&quot;+person.getGender()+&quot;&apos; ,&quot;+
            &quot;photo=&apos;&quot;+person.getPhoto()+&quot;&apos; where companyId=&quot;+person.getCompanyId();

    try {
        ps= getConn().prepareStatement(sql);
        ps.execute();
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        if(ps !=null){
            try {
                  //关闭
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn !=null){
            try {
                  //关闭
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

//删除数据
public   static void deleteRows(int companyId){

    //定义sql语句
    String sql=&quot;delete from impala_kudu_test where companyId=&quot;+companyId;
    try {
        ps =getConn().prepareStatement(sql);
        ps.execute();
    } catch (SQLException e) {
        e.printStackTrace();

    }
}</code></pre><p>   //删除表<br>    public static void dropTable() {<br>        String sql=”drop table if exists impala_kudu_test”;<br>        try {<br>            ps =getConn().prepareStatement(sql);<br>            ps.execute();<br>        } catch (SQLException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 代码测试运行</span><br></pre></td></tr></table></figure>

<p>package cn.itcast.impala.impala;</p>
<p>import java.sql.Connection;</p>
<p>public class ImpalaJdbcClient {<br>    public static void main(String[] args) {<br>        Connection conn = Contants.getConn();</p>
<pre><code>    //创建一个表
   Contants.createTable();

    //插入数据
   Contants.insertRows(new Person(1,100,&quot;lisi&quot;,&quot;male&quot;,&quot;lisi-photo&quot;));

    //查询表的数据
    ResultSet rs = Contants.queryRows();
    Contants.printRows(rs);

    //更新数据
    Contants.updateRows(new Person(1,200,&quot;zhangsan&quot;,&quot;male&quot;,&quot;zhangsan-photo&quot;));

    //删除数据
    Contants.deleteRows(1);

    //删除表
    Contants.dropTable();

}</code></pre><p>}<br>```</p>
<h1 id="六-Apache-KUDU的原理"><a href="#六-Apache-KUDU的原理" class="headerlink" title="六 Apache KUDU的原理"></a>六 Apache KUDU的原理</h1><h2 id="1．-table与schema"><a href="#1．-table与schema" class="headerlink" title="1． table与schema"></a>1． table与schema</h2><p>Kudu设计是面向结构化存储的，因此，Kudu的表需要用户在建表时定义它的Schema信息，这些Schema信息包含：列定义（含类型），Primary Key定义（用户指定的若干个列的有序组合）。数据的唯一性，依赖于用户所提供的Primary Key中的Column组合的值的唯一性。Kudu提供了Alter命令来增删列，但位于Primary Key中的列是不允许删除的。</p>
<p>从用户角度来看，Kudu是一种存储结构化数据表的存储系统。在一个Kudu集群中可以定义任意数量的table，每个table都需要预先定义好schema。每个table的列数是确定的，每一列都需要有名字和类型，每个表中可以把其中一列或多列定义为主键。这么看来，Kudu更像关系型数据库，而不是像HBase、Cassandra和MongoDB这些NoSQL数据库。不过Kudu目前还不能像关系型数据一样支持二级索引。</p>
<p>Kudu使用确定的列类型，而不是类似于NoSQL的“everything is byte”。带来好处：确定的列类型使Kudu可以进行类型特有的编码,可以提供元数据给其他上层查询工具。</p>
<h2 id="2-kudu底层数据模型"><a href="#2-kudu底层数据模型" class="headerlink" title="2 kudu底层数据模型"></a>2 kudu底层数据模型</h2><p>Kudu的底层数据文件的存储，未采用HDFS这样的较高抽象层次的分布式文件系统，而是自行开发了一套可基于Table/Tablet/Replica视图级别的底层存储系统。</p>
<p>这套实现基于如下的几个设计目标：</p>
<p>• 可提供快速的列式查询</p>
<p>• 可支持快速的随机更新</p>
<p>• 可提供更为稳定的查询性能保障</p>
<p><a href="https://manzhong.github.io/images/kudu/dcs.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/dcs.png" alt="img"></a></p>
<p>一张table会分成若干个tablet，每个tablet包括MetaData元信息及若干个RowSet。</p>
<p>RowSet包含一个MemRowSet及若干个DiskRowSet，DiskRowSet中包含一个BloomFile、Ad_hoc Index、BaseData、DeltaMem及若干个RedoFile和UndoFile。</p>
<p>MemRowSet：用于新数据insert及已在MemRowSet中的数据的更新，一个MemRowSet写满后会将数据刷到磁盘形成若干个DiskRowSet。默认是1G或者或者120S。</p>
<p>DiskRowSet：用于老数据的变更，后台定期对DiskRowSet做compaction，以删除没用的数据及合并历史数据，减少查询过程中的IO开销。</p>
<p>BloomFile：根据一个DiskRowSet中的key生成一个bloom filter，用于快速模糊定位某个key是否在DiskRowSet中。</p>
<p>Ad_hocIndex：是主键的索引，用于定位key在DiskRowSet中的具体哪个偏移位置。</p>
<p>BaseData是MemRowSet flush下来的数据，按列存储，按主键有序。</p>
<p>UndoFile是基于BaseData之前时间的历史数据，通过在BaseData上apply UndoFile中的记录，可以获得历史数据。</p>
<p>RedoFile是基于BaseData之后时间的变更记录，通过在BaseData上apply RedoFile中的记录，可获得较新的数据。</p>
<p>DeltaMem用于DiskRowSet中数据的变更，先写到内存中，写满后flush到磁盘形成RedoFile。</p>
<p>REDO与UNDO与关系型数据库中的REDO与UNDO日志类似（在关系型数据库中，REDO日志记录了更新后的数据，可以用来恢复尚未写入Data File的已成功事务更新的数据。而UNDO日志用来记录事务更新之前的数据，可以用来在事务失败时进行回滚）</p>
<p><a href="https://manzhong.github.io/images/kudu/dcs2.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/dcs2.png" alt="img"></a></p>
<p>MemRowSets可以对比理解成HBase中的MemStore, 而DiskRowSets可理解成HBase中的HFile。</p>
<p>MemRowSets中的数据被Flush到磁盘之后，形成DiskRowSets。 DisRowSets中的数据，按照32MB大小为单位，按序划分为一个个的DiskRowSet。 DiskRowSet中的数据按照Column进行组织，与Parquet类似。</p>
<p>这是Kudu可支持一些分析性查询的基础。每一个Column的数据被存储在一个相邻的数据区域，而这个数据区域进一步被细分成一个个的小的Page单元，与HBase File中的Block类似，对每一个Column Page可采用一些Encoding算法，以及一些通用的Compression算法。 既然可对Column Page可采用Encoding以及Compression算法，那么，对单条记录的更改就会比较困难了。</p>
<p>前面提到了Kudu可支持单条记录级别的更新/删除，是如何做到的？</p>
<p>与HBase类似，也是通过增加一条新的记录来描述这次更新/删除操作的。DiskRowSet是不可修改了，那么 KUDU 要如何应对数据的更新呢？在KUDU中，把DiskRowSet分为了两部分：base data、delta stores。base data 负责存储基础数据，delta stores负责存储 base data 中的变更数据.</p>
<p><a href="https://manzhong.github.io/images/kudu/dcs3.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/dcs3.png" alt="img"></a></p>
<p>如上图所示，数据从MemRowSet 刷到磁盘后就形成了一份 DiskRowSet（只包含 base data），每份 DiskRowSet 在内存中都会有一个对应的 DeltaMemStore，负责记录此 DiskRowSet 后续的数据变更（更新、删除）。DeltaMemStore 内部维护一个 B-树索引，映射到每个 row_offset 对应的数据变更。DeltaMemStore 数据增长到一定程度后转化成二进制文件存储到磁盘，形成一个 DeltaFile，随着 base data 对应数据的不断变更，DeltaFile 逐渐增长。</p>
<h2 id="3-tablet发现过程"><a href="#3-tablet发现过程" class="headerlink" title="3 tablet发现过程"></a>3 tablet发现过程</h2><p>当创建Kudu客户端时，其会从主服务器上获取tablet位置信息，然后直接与服务于该tablet的服务器进行交谈。</p>
<p>为了优化读取和写入路径，客户端将保留该信息的本地缓存，以防止他们在每个请求时需要查询主机的tablet位置信息。随着时间的推移，客户端的缓存可能会变得过时，并且当写入被发送到不再是tablet领导者的tablet服务器时，则将被拒绝。然后客户端将通过查询主服务器发现新领导者的位置来更新其缓存。</p>
<p><a href="https://manzhong.github.io/images/kudu/f.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/f.png" alt="img"></a></p>
<h2 id="4-kudu写流程"><a href="#4-kudu写流程" class="headerlink" title="4 kudu写流程"></a>4 kudu写流程</h2><p>当 Client 请求写数据时，先根据主键从Master Server中获取要访问的目标 Tablets，然后到依次对应的Tablet获取数据。</p>
<p>因为KUDU表存在主键约束，所以需要进行主键是否已经存在的判断，这里就涉及到之前说的索引结构对读写的优化了。一个Tablet中存在很多个RowSets，为了提升性能，我们要尽可能地减少要扫描的RowSets数量。</p>
<p>首先，我们先通过每个 RowSet 中记录的主键的（最大最小）范围，过滤掉一批不存在目标主键的RowSets，然后在根据RowSet中的布隆过滤器，过滤掉确定不存在目标主键的 RowSets，最后再通过RowSets中的 B-树索引，精确定位目标主键是否存在。</p>
<p>如果主键已经存在，则报错（主键重复），否则就进行写数据（写 MemRowSet）。</p>
<p><a href="https://manzhong.github.io/images/kudu/w.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/w.png" alt="img"></a></p>
<h2 id="5kudu读流程"><a href="#5kudu读流程" class="headerlink" title="5kudu读流程"></a>5kudu读流程</h2><p>数据读取过程大致如下：先根据要扫描数据的主键范围，定位到目标的Tablets，然后读取Tablets 中的RowSets。</p>
<p>在读取每个RowSet时，先根据主键过滤要scan范围，然后加载范围内的base data，再找到对应的delta stores，应用所有变更，最后union上MemRowSet中的内容，返回数据给Client。</p>
<p><a href="https://manzhong.github.io/images/kudu/r.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/r.png" alt="img"></a></p>
<h2 id="6kudu更新流程"><a href="#6kudu更新流程" class="headerlink" title="6kudu更新流程"></a>6kudu更新流程</h2><p>数据更新的核心是定位到待更新数据的位置，这块与写入的时候类似，就不展开了，等定位到具体位置后，然后将变更写到对应的delta store 中。</p>
<p><a href="https://manzhong.github.io/images/kudu/updata.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/updata.png" alt="img"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/kudu/" data-id="cjz2c0w9d000sagu5kubxz9dg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/08/Hue/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hue
        
      </div>
    </a>
  
  
    <a href="/2019/08/08/ClouderaManager/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">ClouderaManager</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/08/Hbase/">Hbase</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Hbase增强/">Hbase增强</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Storm/">Storm</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Scala入门/">Scala入门</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Scala进阶1/">Scala进阶1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>