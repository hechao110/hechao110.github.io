<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Scala进阶1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Scala 进阶一 类与对象scala是支持面向对象的，也有类和对象的概念。 创建类和对象  使用class关键字来定义类 使用var/val来定义成员变量 使用def来定义成员方法 使用new来创建一个实例对象   var name:String = ，表示使用默认值进行初始化 例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false…  val变量不能">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala进阶1">
<meta property="og:url" content="http://yoursite.com/2019/08/08/Scala进阶1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Scala 进阶一 类与对象scala是支持面向对象的，也有类和对象的概念。 创建类和对象  使用class关键字来定义类 使用var/val来定义成员变量 使用def来定义成员方法 使用new来创建一个实例对象   var name:String = ，表示使用默认值进行初始化 例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false…  val变量不能">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-08-08T04:02:20.658Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala进阶1">
<meta name="twitter:description" content="Scala 进阶一 类与对象scala是支持面向对象的，也有类和对象的概念。 创建类和对象  使用class关键字来定义类 使用var/val来定义成员变量 使用def来定义成员方法 使用new来创建一个实例对象   var name:String = ，表示使用默认值进行初始化 例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false…  val变量不能">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Scala进阶1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Scala进阶1/" class="article-date">
  <time datetime="2019-08-08T03:56:02.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Scala进阶1
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Scala-进阶"><a href="#Scala-进阶" class="headerlink" title="Scala 进阶"></a>Scala 进阶</h1><h1 id="一-类与对象"><a href="#一-类与对象" class="headerlink" title="一 类与对象"></a>一 类与对象</h1><p>scala是支持面向对象的，也有类和对象的概念。</p>
<p>创建类和对象</p>
<ul>
<li>使用<code>class</code>关键字来定义类</li>
<li>使用<code>var</code>/<code>val</code>来定义成员变量</li>
<li>使用<code>def</code>来定义成员方法</li>
<li>使用<code>new</code>来创建一个实例对象</li>
</ul>
<ol>
<li><p>var name:String = <em>，</em>表示使用默认值进行初始化</p>
<p>例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false…</p>
</li>
<li><p>val变量不能使用_来进行初始化，因为val是不可变的，所以必须手动指定一个默认值</p>
</li>
<li><p>main方法必须要放在一个scala的<code>object</code>（单例对象）中才能执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo4 &#123;</span><br><span class="line">  class Pe&#123;</span><br><span class="line">    var name:String=_</span><br><span class="line">    var age:Int =_</span><br><span class="line">    def add(m:String) = print(m)</span><br><span class="line">    private def a(a:String )= print(a)  //private不可被访问</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val pe = new Pe</span><br><span class="line">    pe.add(&quot;mm&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>geter和setter方法:</p>
<ol>
<li>scala会自动为成员变量生成scala语言的getter/setter</li>
<li>scala的getter为<code>字段名()</code>，setter为<code>字段名_=()</code></li>
<li>要生成Java的getter/setter，可以在成员变量上加一个<code>@BeanProperty</code>注解，这样将来去调用一些Java库的时候很有</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BeanProperty</span><br><span class="line">var name:String = _             // 姓名</span><br><span class="line"></span><br><span class="line">@BeanProperty</span><br><span class="line">val registerDate = new Date()   // 注册时间</span><br></pre></td></tr></table></figure>

<h1 id="二构造器"><a href="#二构造器" class="headerlink" title="二构造器"></a>二构造器</h1><h2 id="1-主构造器"><a href="#1-主构造器" class="headerlink" title="1 主构造器"></a>1 主构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Demo5 &#123;</span><br><span class="line">  class Per(var name:String =&quot;&quot;,var sex:String= &quot;&quot;)&#123;</span><br><span class="line">    print(&quot;构造&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ni = new Per(&quot;ni&quot;,&quot;男&quot;)</span><br><span class="line">    println(ni.name)</span><br><span class="line">    println(ni.sex)</span><br><span class="line"></span><br><span class="line">    val per = new Per()</span><br><span class="line">    println(ni.sex)</span><br><span class="line">    println(ni.name)</span><br><span class="line"></span><br><span class="line">    println(new Per(sex = &quot;女&quot;).sex)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-辅助构造器"><a href="#2-辅助构造器" class="headerlink" title="2 辅助构造器"></a>2 辅助构造器</h2><p>与定义方法一样,且方法名一定为this</p>
<p>注意:</p>
<p>辅助构造器第一行必须调用主构造器或者其他辅助构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">object Demo6 &#123;</span><br><span class="line"></span><br><span class="line">  class Cus(var name: String = &quot;&quot;, var add: String = &quot;&quot;) &#123;</span><br><span class="line">    //辅助构造器</span><br><span class="line">    def this(fu: Array[String]) &#123;</span><br><span class="line">      this(fu(0), fu(1))</span><br><span class="line">    &#125;</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">      this(name,&quot;郑州&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">   /* def this (add:String)&#123;</span><br><span class="line">      this(&quot;你猜&quot;,add)</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val cus = new Cus(Array[String](&quot;aa&quot;,&quot;北京&quot;))</span><br><span class="line">    println(cus.add)</span><br><span class="line">    val cus2 = new Cus(&quot;niu&quot;)</span><br><span class="line">    println(cus2.add)//郑州</span><br><span class="line">    print(cus2.name)//niu</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>主构造器直接在类名后面定义</li>
<li>主构造器中的参数列表会自动定义为私有的成员变量</li>
<li>一般在主构造器中直接使用val/var定义成员变量，这样看起来会更简洁</li>
<li>在辅助构造器中必须调用其他构造器（主构造器、其他辅助构造器）</li>
</ol>
<h2 id="三-单例对象-类似于java中的static"><a href="#三-单例对象-类似于java中的static" class="headerlink" title="三 单例对象 (类似于java中的static)"></a>三 单例对象 (类似于java中的static)</h2><p>scala要比Java更加面向对象，所以，scala中是没有Java中的静态成员的。如果将来我们需要用到static变量、static方法，就要用到scala中的单例对象——object。可以把object理解为全是包含静态字段、静态方法的class，object本质上也是一个class。</p>
<p><strong>定义object</strong></p>
<p>定义单例对象和定义类很像，就是把class换成object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">定义一个工具类，用来格式化日期时间</span><br><span class="line">object DateUtils &#123;</span><br><span class="line"></span><br><span class="line">  // 在object中定义的成员变量，相当于Java中定义一个静态变量</span><br><span class="line">  // 定义一个SimpleDateFormat日期时间格式化对象</span><br><span class="line">  val simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;)</span><br><span class="line"></span><br><span class="line">  // 构造代码</span><br><span class="line">  println(&quot;构造代码&quot;)</span><br><span class="line">    </span><br><span class="line">  // 相当于Java中定义一个静态方法</span><br><span class="line">  def format(date:Date) = simpleDateFormat.format(date)</span><br><span class="line"></span><br><span class="line">  // main是一个静态方法，所以必须要写在object中</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println &#123; DateUtils.format(new Date()) &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>使用<code>object 单例对象名</code>定义一个单例对象，可以用object作为工具类或者存放常量</li>
<li>在单例对象中定义的变量，类似于Java中的static成员变量</li>
<li>在单例对象中定义的方法，类似于Java中的static方法</li>
<li>object单例对象的构造代码可以直接写在花括号中</li>
<li>调用单例对象的方法，直接使用<code>单例对象名.方法名</code>，访问单例对象的成员变量也是使用<code>单例对象名.变量名</code></li>
<li>单例对象只能有一个<code>无参的主构造器</code>，不能添加其他参数</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">object Demo7 &#123;</span><br><span class="line">  object Dog&#123;</span><br><span class="line">    val num=4;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    print(Dog.num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用方法</span><br><span class="line">object Demo8 &#123;</span><br><span class="line">  object Uf&#123;</span><br><span class="line">    def add(): Unit =&#123;</span><br><span class="line">      print(&quot;-&quot; * 15)   //生成15 个-</span><br><span class="line">      print(&quot;nicai&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    Uf.add()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>伴生对象</strong></p>
<p>在Java中，经常会有一些类，同时有实例成员又有静态成员。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CustomerService &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = Logger.getLogger(&quot;customerService&quot;);</span><br><span class="line"></span><br><span class="line">    public void save(String customer) &#123;</span><br><span class="line">        logger.info(&quot;添加一个用户&quot;);</span><br><span class="line">        // 保存客户</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new CustomerService().save(&quot;客户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在scala中，可以使用<code>伴生对象</code>来实现。</p>
<p><strong>一个class和object具有同样的名字。这个object称为伴生对象，这个class称为伴生类</strong></p>
<p>注意:</p>
<p>半生类和伴生对象一样的名字</p>
<p>这两个要在同一个scala源文件中</p>
<p>这两个可以互相访问private属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">object Demo11 &#123;</span><br><span class="line">  //半生类</span><br><span class="line">  class Ssm()&#123;</span><br><span class="line">    def fin(): Unit =&#123;</span><br><span class="line">        print(Ssm.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //半生对象</span><br><span class="line">  object Ssm&#123;</span><br><span class="line">    var name=&quot;nicai&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ssm = new Ssm</span><br><span class="line">    ssm.fin()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="private-this-访问权限-表示只能在当前类中访问-伴生对象也不可访问"><a href="#private-this-访问权限-表示只能在当前类中访问-伴生对象也不可访问" class="headerlink" title="private[this] 访问权限 表示只能在当前类中访问,伴生对象也不可访问"></a>private[this] 访问权限 表示只能在当前类中访问,伴生对象也不可访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object Demo12 &#123;</span><br><span class="line">  class De(private[this] var name:String,var age:Int)</span><br><span class="line"></span><br><span class="line">  object De&#123;</span><br><span class="line">    def p(d:De): Unit =print(d.name)   //直接报错</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    De.p(new De(&quot;aa&quot;,788))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具类案例:</p>
<p>需求:</p>
<p>编写一个工具类专门格式化日期时间</p>
<p>定义一个方法用于将日期转换为年月日字符串 2012-10-15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo9 &#123;</span><br><span class="line">  object Forma&#123;</span><br><span class="line">    //java 中的类</span><br><span class="line">    private val format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line"></span><br><span class="line">    //定义方法</span><br><span class="line">    def fm(data:Date)=format.format(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(Forma.fm(new Date()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>apply方法</strong></p>
<p><strong>必须用在伴生对象中</strong></p>
<p>我们之前使用过这种方式来创建一个Array对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a=Array(1,2)</span><br></pre></td></tr></table></figure>

<p>这种写法非常简便，不需要再写一个new，然后敲一个空格，再写类名。如何直接使用类名来创建对象呢？</p>
<p>答案就是：**实现伴生对象的<code>apply</code>方法</p>
<p>伴生对象的apply方法用来快速地创建一个伴生类的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">object Demo13 &#123;</span><br><span class="line">  class Person(var name:String, var age:Int) &#123;</span><br><span class="line"></span><br><span class="line">    override def toString = s&quot;Person($name, $age)&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  object Person &#123;</span><br><span class="line">    // 实现apply方法</span><br><span class="line">    // 返回的是伴生类的对象</span><br><span class="line">    def apply(name:String, age:Int): Person = new Person(name, age)</span><br><span class="line"></span><br><span class="line">    // apply方法支持重载</span><br><span class="line">    def apply(name:String):Person = new Person(name, 20)</span><br><span class="line"></span><br><span class="line">    def apply(age:Int):Person = new Person(&quot;某某某&quot;, age)</span><br><span class="line"></span><br><span class="line">    def apply():Person = new Person(&quot;某某某&quot;, 20)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(Person(&quot;jjj&quot;).name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当遇到<code>类名(参数1, 参数2...)</code>会自动调用apply方法，在apply方法中来创建对象</li>
<li>定义apply时，如果参数列表是空，也不能省略括号()，否则引用的是伴生对象</li>
</ol>
<p><strong>main方法</strong></p>
<p>scala和Java一样，如果要运行一个程序，必须有一个main方法。而在Java中main方法是静态的，而在scala中没有静态方法。在scala中，这个main方法必须放在一个object中。</p>
<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Main5 &#123;</span><br><span class="line">  def main(args:Array[String]) = &#123;</span><br><span class="line">    println(&quot;hello, scala&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以继承自App Trait（特质），然后将需要编写在main方法中的代码，写在object的构造方法体内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object 	Main extends App&#123;</span><br><span class="line">println(&quot;heoo&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四继承"><a href="#四继承" class="headerlink" title="四继承"></a>四继承</h2><p>scala和Java一样，使用<strong>extends</strong>关键字来实现继承。可以在子类中定义父类中没有的字段和方法，或者重写父类的方法。</p>
<p>类和单例对象都可以从某个父类继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo14 &#123;</span><br><span class="line">  class Per()&#123;</span><br><span class="line">    var name=&quot;&quot;</span><br><span class="line">    def getName()=this.name</span><br><span class="line">  &#125;</span><br><span class="line">  class Student extends Per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val student = new Student</span><br><span class="line">    student.name=&quot;ni&quot;</span><br><span class="line">    println(student.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object Demo15&#123;</span><br><span class="line">  class Per()&#123;</span><br><span class="line">    var name=&quot;&quot;</span><br><span class="line">    def a()=print(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  object Stu extends Per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    Stu.name=&quot;ni&quot;</span><br><span class="line">    println(Stu.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="override-和supper"><a href="#override-和supper" class="headerlink" title="override 和supper"></a>override 和supper</h3><hr>
<ul>
<li>如果子类要覆盖父类中的一个非抽象方法，必须要使用override关键字</li>
<li>可以使用override关键字来重写一个val字段</li>
<li>可以使用super关键字来访问父类的成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Demo16 &#123;</span><br><span class="line">  class Per()&#123;</span><br><span class="line">    val name:String =&quot;22&quot;</span><br><span class="line">    var age:Int=0</span><br><span class="line">    def getName()=this.name</span><br><span class="line">  &#125;</span><br><span class="line">  class Stu extends Per&#123;</span><br><span class="line">    override val name: String = &quot;nn&quot;</span><br><span class="line"></span><br><span class="line">    override def getName(): String = &quot;ni&quot;+super.getName()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val stu = new Stu</span><br><span class="line">    println(stu.getName())  //ninn</span><br><span class="line">    println(stu.name)    //nn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型的判断与转换"><a href="#类型的判断与转换" class="headerlink" title="类型的判断与转换"></a>类型的判断与转换</h3><p>我们经常要在代码中进行类型的判断和类型的转换。在Java中，我们可以使用instanceof关键字、以及(类型)object来实现，在scala中如何实现呢？</p>
<p>scala中对象提供isInstanceOf和asInstanceOf方法。</p>
<ul>
<li>isInstanceOf判断对象是否为指定类的对象</li>
<li>asInstanceOf将对象转换为指定类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object Demo17 &#123;</span><br><span class="line">  class per</span><br><span class="line">  class Stu extends per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val stu = new Stu</span><br><span class="line">    if(stu.isInstanceOf[Stu])&#123;</span><br><span class="line">      stu.asInstanceOf[Stu]</span><br><span class="line">      print(stu)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      print(&quot;不是stu类型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getClass和classOf"><a href="#getClass和classOf" class="headerlink" title="getClass和classOf"></a>getClass和classOf</h3><p>isInstanceOf 只能判断出对象是否为指定类以及其子类的对象，而不能精确的判断出，对象就是指定类的对象。如果要求精确地判断出对象就是指定类的对象，那么就只能使用 getClass 和 classOf 。</p>
<ul>
<li>p.getClass可以精确获取对象的类型</li>
<li>classOf[x]可以精确获取类型</li>
<li>使用==操作符就可以直接比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">object Demo18 &#123;</span><br><span class="line">  class Per()</span><br><span class="line">  class Stu extends Per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val stu:Per=new Stu</span><br><span class="line"></span><br><span class="line">    if(stu.isInstanceOf[Per])&#123;</span><br><span class="line">      println(&quot;stu是一个per类型&quot;)      ///y</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      println(&quot;stu 不是一个per类型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(stu.getClass == classOf[Per])&#123;</span><br><span class="line">      println(&quot;stu是一个per类型&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      println(&quot;stu 不是一个per类型&quot;)     ////y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(stu.getClass == classOf[Stu])&#123;</span><br><span class="line">      println(&quot;stu是一个STU类型&quot;)       //y</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      println(&quot;stu 不是一个stu类型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用父类的constructor</strong></p>
<p>实例化子类对象，必须要调用父类的构造器，在scala中，只能在子类的<code>主构造器</code>中调用父类的构造器</p>
<p>步骤：</p>
<ol>
<li>创建一个Person类，编写带有一个可变的name字段的主构造器</li>
<li>创建一个Student类，继承自Person类<ul>
<li>编写带有一个name参数、clazz班级字段的主构造器</li>
<li>调用父类的构造器</li>
</ul>
</li>
<li>创建main方法，创建Student对象实例，并打印它的姓名、班级</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> class Person5(var name:String)</span><br><span class="line">// 直接在父类的类名后面调用父类构造器</span><br><span class="line">class Student5(name:String, var clazz:String) extends Person5(name)</span><br><span class="line"></span><br><span class="line">object Main5 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val s1 = new Student5(&quot;张三&quot;, &quot;三年二班&quot;)</span><br><span class="line">    println(s&quot;$&#123;s1.name&#125; - $&#123;s1.clazz&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果类的某个成员在当前类中的定义是不包含完整的，它就是一个<strong>抽象类</strong></p>
<p>不完整定义有两种情况：</p>
<ol>
<li>方法没有方法体</li>
<li>变量没有初始化</li>
</ol>
<p>没有方法体的方法称为<strong>抽象方法</strong>，没有初始化的变量称为<strong>抽象字段</strong>。定义抽象类和Java一样，在类前面加上<strong>abstract</strong>关键字就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//抽象方法</span><br><span class="line">object Demo19 &#123;</span><br><span class="line">   abstract class Sop()&#123;</span><br><span class="line">      def m():Double    //或者 def  m:Double</span><br><span class="line">    &#125;</span><br><span class="line">  class z(l:Double ) extends Sop&#123;</span><br><span class="line">    override def m:Double  = l*l</span><br><span class="line">  &#125;</span><br><span class="line">  class Cyc(r:Double) extends Sop&#123;</span><br><span class="line">    override def m:Double  =  Math.PI*r*r</span><br><span class="line">  &#125;</span><br><span class="line">  class Ju(l:Double,k:Double) extends Sop&#123;</span><br><span class="line">    override def m: Double = l*k</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val z = new z(12.3)</span><br><span class="line">    val cyc = new Cyc(2)</span><br><span class="line">    val ju = new Ju(1,3.0)</span><br><span class="line">    println(z.m)</span><br><span class="line">    println(cyc.m)</span><br><span class="line">    println(ju.m)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象字段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个人的抽象类</span><br><span class="line">abstract class Person6 &#123;</span><br><span class="line">  // 没有初始化的val字段就是抽象字段</span><br><span class="line">  val WHO_AM_I:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student6 extends Person6 &#123;</span><br><span class="line">  override val WHO_AM_I: String = &quot;学生&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Policeman6 extends Person6 &#123;</span><br><span class="line">  override val WHO_AM_I: String = &quot;警察&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Main6 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val p1 = new Student6</span><br><span class="line">    val p2 = new Policeman6</span><br><span class="line"></span><br><span class="line">    println(p1.WHO_AM_I)</span><br><span class="line">    println(p2.WHO_AM_I)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类是没有名称的子类，直接用来创建实例对象。Spark的源代码中有大量使用到匿名内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object Demo20 &#123;</span><br><span class="line">  abstract class Per()&#123;</span><br><span class="line">    def say()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val per = new Per &#123;</span><br><span class="line">      override def say(): Unit = println(&quot;nicai&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    per.say()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特质-trait"><a href="#特质-trait" class="headerlink" title="特质(trait)"></a>特质(trait)</h2><p>scala中没有接口的概念 替代的就是特质</p>
<ul>
<li>特质是scala中代码复用的基础单元</li>
<li>它可以将方法和字段定义封装起来，然后添加到类中</li>
<li>与类继承不一样的是，类继承要求每个类都只能继承<code>一个</code>超类，而一个类可以添加<code>任意数量</code>的特质。</li>
<li>特质的定义和抽象类的定义很像，但它是使用<code>trait</code>关键字</li>
</ul>
<h3 id="用法一-作为接口使用"><a href="#用法一-作为接口使用" class="headerlink" title="用法一 作为接口使用"></a>用法一 作为接口使用</h3><ul>
<li>使用<code>extends</code>来继承trait（scala不论是类还是特质，都是使用extends关键字）</li>
<li>如果要继承多个trait，则使用<code>with</code>关键字</li>
</ul>
<p><strong>继承单个特质</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo21 &#123;</span><br><span class="line">  trait Loger&#123;</span><br><span class="line">    def pr(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  class LogerE extends Loger&#123;</span><br><span class="line">    override def pr(msg: String): Unit = print(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var e:Loger=new LogerE()</span><br><span class="line">    e.pr(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承多个特质</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">object Demo22 &#123;</span><br><span class="line">  trait D1&#123;</span><br><span class="line">    def ms(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  trait D2&#123;</span><br><span class="line">    def ms():String</span><br><span class="line">  &#125;</span><br><span class="line">  class D3 extends D1 with D2&#123;</span><br><span class="line">    override def ms(msg: String): Unit = println(msg)</span><br><span class="line"></span><br><span class="line">    override def ms(): String = &quot;nicai&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = new D3</span><br><span class="line">    d.ms(&quot;ni&quot;)</span><br><span class="line">    println(d.ms())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>object 继承trait</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object Demo23 &#123;</span><br><span class="line">  trait D1&#123;</span><br><span class="line">    def m(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  object D2 extends D1&#123;</span><br><span class="line">    override def m(msg: String): Unit = print(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    D2.m(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在trait中可以定义抽象方法，不写方法体就是抽象方法</li>
<li>和继承类一样，使用extends来继承trait</li>
<li>继承多个trait，使用with关键字</li>
<li>单例对象也可以继承trait</li>
</ol>
<h3 id="特质-定义具体的方法"><a href="#特质-定义具体的方法" class="headerlink" title="特质 定义具体的方法"></a>特质 定义具体的方法</h3><p>和类一样，trait中还可以定义具体的方法。·</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo24 &#123;</span><br><span class="line">  trait D&#123;</span><br><span class="line">    def add(msg:String) = println(msg)</span><br><span class="line">  &#125;</span><br><span class="line">   class  D2 extends D&#123;</span><br><span class="line">     def add2()= add(&quot;nicai&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = new D2</span><br><span class="line">    d.add2()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trait中定义具体的字段和抽象字段"><a href="#trait中定义具体的字段和抽象字段" class="headerlink" title="trait中定义具体的字段和抽象字段"></a>trait中定义具体的字段和抽象字段</h3><ul>
<li>在trait中，可以混合使用具体方法和抽象方法</li>
<li>使用具体方法依赖于抽象方法，而抽象方法可以放到继承trait的子类中实现，这种设计方式也称为<strong>模板模式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">object Demo25 &#123;</span><br><span class="line">  trait D&#123;</span><br><span class="line">  val s = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line">    var TYPE:String</span><br><span class="line">    def pr(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  class D2 extends D&#123;</span><br><span class="line">    override var TYPE: String = &quot;控制台消息&quot;</span><br><span class="line"></span><br><span class="line">    override def pr(msg: String): Unit = println(s&quot;$&#123;TYPE&#125;:$&#123;s.format(new Date)&#125;:$&#123;msg&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = new D2</span><br><span class="line">    d.pr(&quot;nnicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用trait实现模板模式"><a href="#使用trait实现模板模式" class="headerlink" title="使用trait实现模板模式"></a>使用trait实现模板模式</h3><p>在特质中,具体方法依赖于抽象方法,而抽象 方法可以放在继承trait中的子类中实现,这种方式为模板设计模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Demo26 &#123;</span><br><span class="line">    trait  Logger&#123;</span><br><span class="line">      def  log(msg:String)</span><br><span class="line">      def info(msg:String) = log(msg)</span><br><span class="line">      def exce(msg:String) = log(msg)</span><br><span class="line">      def erro(msg:String) = log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  class LogE extends Logger&#123;</span><br><span class="line">    override def log(msg: String): Unit = println(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val e = new LogE</span><br><span class="line">    e.info(&quot;info&quot;)</span><br><span class="line">    e.exce(&quot;exec&quot;)</span><br><span class="line">    e.erro(&quot;erro&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象混入trait"><a href="#对象混入trait" class="headerlink" title="对象混入trait"></a>对象混入trait</h3><ul>
<li>trait还可以混入到<code>实例对象</code>中，给对象实例添加额外的行为</li>
<li>只有混入了trait的对象才具有trait中的方法，其他的类对象不具有trait中的行为</li>
<li>使用with将trait混入到实例对象中</li>
</ul>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var /val da=new 类 with 特质</span><br><span class="line">object Demo27 &#123;</span><br><span class="line">  trait Logger&#123;</span><br><span class="line">    def log()=println(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  class Aa</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val aa = new Aa with Logger</span><br><span class="line">    aa.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trait-实现调用链模式"><a href="#trait-实现调用链模式" class="headerlink" title="trait 实现调用链模式"></a>trait 实现调用链模式</h3><p>类继承了多个trait后，可以依次调用多个trait中的同一个方法，只要让多个trait中的同一个方法在最后都依次执行super关键字即可。类中调用多个tait中都有这个方法时，首先会从最右边的trait方法开始执行，然后依次往左执行，形成一个调用链条。</p>
<p>如支付连 等</p>
<p>说明 : 一个子类 继承多个父trait 且还有祖父trait 则 会先执行自己的 在执行从右到左的父trait(继承顺序相反),最后执行祖父trait</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">object Demo28 &#123;</span><br><span class="line">    trait Zf&#123;</span><br><span class="line">      def log(data:String ) = println(&quot;祖父&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  trait Login extends Zf&#123;</span><br><span class="line">    override def log(data: String): Unit =&#123;</span><br><span class="line">      println(&quot;父1&quot;)</span><br><span class="line">      super.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  trait Handle extends Zf&#123;</span><br><span class="line">    override def log(data: String): Unit = &#123;</span><br><span class="line">      println(&quot;父2&quot;)</span><br><span class="line">      super.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Ser() extends Handle with Login &#123;</span><br><span class="line">    override def log(data: String): Unit = &#123;</span><br><span class="line">     println(&quot;子类&quot;)</span><br><span class="line">      super.log(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ser = new Ser()</span><br><span class="line">    ser.log(&quot;nn&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子类</span><br><span class="line">//父1</span><br><span class="line">//父2</span><br><span class="line">//祖父</span><br></pre></td></tr></table></figure>

<h3 id="trait的构造机制"><a href="#trait的构造机制" class="headerlink" title="trait的构造机制"></a>trait的构造机制</h3><ul>
<li>trait也有构造代码，但和类不一样，特质不能有构造器参数</li>
<li>每个特质只有<strong>一个无参数</strong>的构造器。</li>
<li>一个类继承另一个类、以及多个trait，当创建该类的实例时，它的构造顺序如下：<ol>
<li>执行父类的构造器</li>
<li><code>从左到右</code>依次执行trait的构造器</li>
<li>如果trait有父trait，先构造父trait，如果多个trait有同样的父trait，则只初始化一次</li>
<li>执行子类构造器</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person_One &#123;</span><br><span class="line">  println(&quot;执行Person构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait Logger_One &#123;</span><br><span class="line">  println(&quot;执行Logger构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait MyLogger_One extends Logger_One &#123;</span><br><span class="line">  println(&quot;执行MyLogger构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait TimeLogger_One extends Logger_One &#123;</span><br><span class="line">  println(&quot;执行TimeLogger构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">class Student_One extends Person_One with MyLogger_One with TimeLogger_One &#123;</span><br><span class="line">  println(&quot;执行Student构造器!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">object exe_one &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val student = new Student_One</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 程序运行输出如下：</span><br><span class="line">// 执行Person构造器!</span><br><span class="line">// 执行Logger构造器!</span><br><span class="line">// 执行MyLogger构造器!</span><br><span class="line">// 执行TimeLogger构造器!</span><br><span class="line">// 执行Student构造器!</span><br></pre></td></tr></table></figure>

<p><strong>trait继承class</strong></p>
<ul>
<li>trait也可以继承class 会把class中的成员都继承下来</li>
<li>这个class就会成为所有该trait子类的超级父类。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyUtil &#123;</span><br><span class="line">  def printMsg(msg: String) = println(msg)</span><br><span class="line">&#125;</span><br><span class="line">trait Logger_Two extends MyUtil &#123;</span><br><span class="line">  def log(msg: String) = this.printMsg(&quot;log: &quot; + msg)</span><br><span class="line">&#125;</span><br><span class="line">class Person_Three(val name: String) extends Logger_Two &#123;</span><br><span class="line">    def sayHello &#123;</span><br><span class="line">        this.log(&quot;Hi, I&apos;m &quot; + this.name)</span><br><span class="line">        this.printMsg(&quot;Hello, I&apos;m &quot; + this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object Person_Three&#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">      val p=new Person_Three(&quot;Tom&quot;)</span><br><span class="line">      p.sayHello</span><br><span class="line">    //执行结果：</span><br><span class="line">//      log: Hi, I&apos;m Tom</span><br><span class="line">//      Hello, I&apos;m Tom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Scala进阶1/" data-id="cjz2c0w8t000hagu51eipqdnz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/08/Scala入门/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Scala入门
        
      </div>
    </a>
  
  
    <a href="/2019/08/08/Scala进阶2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Scala进阶2</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/08/Hbase/">Hbase</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Hbase增强/">Hbase增强</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Storm/">Storm</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Scala入门/">Scala入门</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Scala进阶1/">Scala进阶1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>