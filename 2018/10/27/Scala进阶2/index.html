<!DOCTYPE html><html lang="hc-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="一只沙皮狗的悲伤"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>Scala进阶2 | 一只沙皮狗的悲伤</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Scala进阶2</h1><a id="logo" href="/.">一只沙皮狗的悲伤</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Suche"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Scala进阶2</h1><div class="post-meta"><a href="/2018/10/27/Scala进阶2/#comments" class="comment-count"></a><p><span class="date">Oct 27, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Schlägt</i></i></span></p></div><div class="post-content"><p>一 样例类</p>
<p>样例类是一种特殊类，它可以用来快速定义一个用于<strong>保存数据</strong>的类（类似于Java POJO类），而且它会自动生成apply方法，允许我们快速地创建样例类实例对象。后面，在并发编程和spark、flink这些框架也都会经常使用它。</p>
<ol>
<li>样例类可以使用<strong>类名(参数1, 参数2…)</strong>快速创建实例对象</li>
<li>定义样例类成员变量时，可以指定var类型，表示可变。默认是不可变的 val 可省略</li>
<li>样例类自动生成了toString、equals、hashCode、copy方法</li>
<li>样例对象没有主构造器，可以使用样例对象来创建枚举、或者标识一类没有任何数据的消息</li>
</ol>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case class 样例类名(成员变量名1:类型1, 成员变量名2:类型2, 成员变量名3:类型3)</span><br></pre></td></tr></table></figure>

<p><strong>定义样例类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object Demo1 &#123;</span><br><span class="line">  case class Per(name:String, var age:Int)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val per = Per(&quot;你猜&quot;,25)</span><br><span class="line">    //per.name=&quot;njj&quot;   会报错</span><br><span class="line">    per.age=25  //正常可以修改</span><br><span class="line">    println(per)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="样例类的方法"><a href="#样例类的方法" class="headerlink" title="样例类的方法"></a>样例类的方法</h3><p>定义样例类编译器自动帮我们实现了一下几个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply   快速的用类名创建对象</span><br><span class="line">toString   与java同</span><br><span class="line">equals      比较两个样例类的成员变量是否相等  与==类似</span><br><span class="line">hashCode    如两个样例类的所有的成员变量的值相等 则hash值相等 否则 只要一个不同 则hash值就不等</span><br><span class="line">copy     样例类的克隆</span><br><span class="line">object Demo2 &#123;</span><br><span class="line">  case class Per(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val nicai = Per(&quot;nicai&quot;,55)</span><br><span class="line">    val nn = nicai.copy(&quot;nn&quot;)</span><br><span class="line">      //可以修改成员变量的值</span><br><span class="line">    println(nn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="样例对象"><a href="#样例对象" class="headerlink" title="样例对象"></a>样例对象</h3><p>使用case object可以创建样例对象。样例对象是单例的，而且它<strong>没有主构造器</strong>。样例对象是可序列化的。格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case object 样例对象名</span><br></pre></td></tr></table></figure>

<p>它主要用在两个地方：</p>
<ol>
<li>定义枚举</li>
<li>作为没有任何参数的消息传递（后面Akka编程会讲到）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">object Demo3 &#123;</span><br><span class="line">  //定义一个枚举</span><br><span class="line">  trait Sex</span><br><span class="line">  case object Man extends Sex</span><br><span class="line">  case object Wonmn extends Sex</span><br><span class="line"></span><br><span class="line"> case class Per(name:String,sex: Sex)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val per = Per(&quot;小明&quot;,Man)</span><br><span class="line">    val p = Per(&quot;小红&quot;,Wonmn)</span><br><span class="line">    println(per)</span><br><span class="line">    println(p)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case class StartSpeakingMessage(textToSpeak: String)</span><br><span class="line">// 消息如果没有任何参数，就可以定义为样例对象</span><br><span class="line">case object StopSpeakingMessage</span><br><span class="line">case object PauseSpeakingMessage</span><br><span class="line">case object ResumeSpeakingMessage</span><br></pre></td></tr></table></figure>

<h1 id="二模板匹配"><a href="#二模板匹配" class="headerlink" title="二模板匹配"></a>二模板匹配</h1><p>scala中有一个非常强大的模式匹配机制，可以应用在很多场景：</p>
<ul>
<li>switch语句</li>
<li>类型查询</li>
<li>以及快速获取数据</li>
</ul>
<h3 id="简单模式匹配"><a href="#简单模式匹配" class="headerlink" title="简单模式匹配"></a>简单模式匹配</h3><p>相当于java中的switch语句</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">变量 match &#123;</span><br><span class="line">    case &quot;常量1&quot; =&gt; 表达式1</span><br><span class="line">    case &quot;常量2&quot; =&gt; 表达式2</span><br><span class="line">    case &quot;常量3&quot; =&gt; 表达式3</span><br><span class="line">    case _ =&gt; 表达式4		// 默认匹配</span><br><span class="line">&#125;</span><br><span class="line">object Demo1 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val str = StdIn.readLine()   //从键盘录入</span><br><span class="line"></span><br><span class="line">    val unit = str match &#123;</span><br><span class="line">      case &quot;hadoop&quot; =&gt; &quot;nicai&quot;</span><br><span class="line">      case &quot;spaker&quot; =&gt; &quot;分布式计算框架&quot;</span><br><span class="line">      case _ =&gt; &quot;未匹配&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><p>根据不同的数据类型进行匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">变量 match &#123;</span><br><span class="line">    case 类型1变量名: 类型1 =&gt; 表达式1</span><br><span class="line">    case 类型2变量名: 类型2 =&gt; 表达式2</span><br><span class="line">    case 类型3变量名: 类型3 =&gt; 表达式3</span><br><span class="line">    ...</span><br><span class="line">    case _ =&gt; 表达式4</span><br><span class="line">&#125;</span><br><span class="line">object Demo2 &#123;</span><br><span class="line">  var  a:Any=&quot;hadoop&quot;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val unit = a match &#123;</span><br><span class="line">      case x: String =&gt; s&quot;$&#123;x&#125;字符串&quot;   //若后面没有用到这个变量 可以写为 _:String</span><br><span class="line">      case x: Int =&gt; &quot;整形&quot;</span><br><span class="line">      case x: Double =&gt; &quot;浮点型&quot;</span><br><span class="line">      case _ =&gt; &quot;没匹配&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守卫"><a href="#守卫" class="headerlink" title="守卫"></a>守卫</h3><p>在Java中，只能简单地添加多个case标签，例如：要匹配0-7，就需要写出来8个case语句。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">switch(a) &#123;</span><br><span class="line">    case 0: a += 1;</span><br><span class="line">    case 1: a += 1;</span><br><span class="line">    case 2: a += 1;</span><br><span class="line">    case 3: a += 1;</span><br><span class="line">    case 4: a += 2;</span><br><span class="line">    case 5: a += 2;</span><br><span class="line">    case 6: a += 2;</span><br><span class="line">    case 7: a += 2;</span><br><span class="line">    default: a = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在scala中，可以使用守卫来简化上述代码——也就是在<strong>case语句中添加if条件判断</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo3 &#123;</span><br><span class="line">    private val i: Int = StdIn.readInt()</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val unit = i match &#123;</span><br><span class="line">      case x if x &gt; 0 &amp;&amp; x &lt; 3 =&gt; &quot;0-3&quot;   </span><br><span class="line">      case x if x &gt; 3 &amp;&amp; x &lt; 10 =&gt; println(&quot;3-10&quot;)  //若这样鞋  则0-3 之后会打印()</span><br><span class="line">      case x if x &gt; 10 &amp;&amp; x &lt; 13 =&gt; println(&quot;10-13&quot;)</span><br><span class="line">      case _ =&gt; println(&quot;weipi&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配样例类"><a href="#匹配样例类" class="headerlink" title="匹配样例类"></a>匹配样例类</h3><p>scala可以使用模式匹配来匹配样例类，从而可以快速获取样例类中的成员数据。后续，我们在开发Akka案例时，还会用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object Demo4 &#123;</span><br><span class="line">  case class Per(name:String,age:Int)</span><br><span class="line">  case class Stu(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ni:Any = Per(&quot;ni&quot;,55)              //若不为any则会报错</span><br><span class="line">    val unit = ni match &#123;</span><br><span class="line">      case Per(name, age) =&gt; s&quot;$&#123;name&#125;:$&#123;age&#125;per&quot;</span><br><span class="line">      case Stu(name, age) =&gt; s&quot;$&#123;name&#125;:$&#123;age&#125;stu&quot;</span><br><span class="line">      case _ =&gt; &quot;未匹配&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配集合"><a href="#匹配集合" class="headerlink" title="匹配集合"></a>匹配集合</h3><p>1 匹配数组</p>
<ul>
<li><p>依次修改代码定义以下三个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array(1,x,y)   // 以1开头，后续的两个元素不固定</span><br><span class="line">Array(0)       // 只匹配一个0元素的元素</span><br><span class="line">Array(0, ...)  // 可以任意数量，但是以0开头</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式匹配上述数组</p>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val arr = Array(1, 3, 5)</span><br><span class="line">arr match &#123;</span><br><span class="line">    case Array(1, x, y) =&gt; println(x + &quot; &quot; + y)</span><br><span class="line">    case Array(0) =&gt; println(&quot;only 0&quot;)</span><br><span class="line">    case Array(0, _*) =&gt; println(&quot;0 ...&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;something else&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2匹配列表</p>
<ul>
<li><p>依次修改代码定义以下三个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List(0)                // 只保存0一个元素的列表</span><br><span class="line">List(0,...)           // 以0开头的列表，数量不固定</span><br><span class="line">List(x,y)               // 只包含两个元素的列表</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式匹配上述列表</p>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val list = List(0, 1, 2)</span><br><span class="line"></span><br><span class="line">list match &#123;</span><br><span class="line">    case 0 :: Nil =&gt; println(&quot;只有0的列表&quot;)</span><br><span class="line">    case 0 :: tail =&gt; println(&quot;0开头的列表&quot;)</span><br><span class="line">    case x :: y :: Nil =&gt; println(s&quot;只有另两个元素$&#123;x&#125;, $&#123;y&#125;的列表&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;未匹配&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 匹配元组</p>
<ul>
<li><p>依次修改代码定义以下两个元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1, x, y)        // 以1开头的、一共三个元素的元组</span><br><span class="line">(x, y, 5)   // 一共有三个元素，最后一个元素为5的元组</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式匹配上述元素</p>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val tuple = (2, 2, 5)</span><br><span class="line"></span><br><span class="line">tuple match &#123;</span><br><span class="line">    case (1, x, y) =&gt; println(s&quot;三个元素，1开头的元组：1, $&#123;x&#125;, $&#123;y&#125;&quot;)</span><br><span class="line">    case (x, y, 5) =&gt; println(s&quot;三个元素，5结尾的元组：$&#123;x&#125;, $&#123;y&#125;, 5&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;未匹配&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量声明中的模式匹配"><a href="#变量声明中的模式匹配" class="headerlink" title="变量声明中的模式匹配"></a>变量声明中的模式匹配</h3><p>在定义变量的时候，可以使用模式匹配快速获取数据。</p>
<p>1 获取数组中的元素</p>
<ul>
<li>生成包含0-10数字的数组，使用模式匹配分别获取第二个、第三个、第四个元素</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.matchdemo</span><br><span class="line">//变量声明中的模式匹配</span><br><span class="line">object Demo8 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var array=(0 to 10).toArray</span><br><span class="line">    var Array(_,x,y,z,_*)=array</span><br><span class="line">    println(x)  //1</span><br><span class="line">    println(y)  //2</span><br><span class="line">    println(z)   //3</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 获取列表中的数据</p>
<ul>
<li>生成包含0-10数字的列表，使用模式匹配分别获取第一个、第二个元素</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.matchdemo</span><br><span class="line">//变量声明中的模式匹配</span><br><span class="line">object Demo9 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var a= (0 to 10).toList</span><br><span class="line">    var x :: y :: tail =a</span><br><span class="line"></span><br><span class="line">    println(x) //0</span><br><span class="line">    println(y)  //1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="option类型"><a href="#option类型" class="headerlink" title="option类型"></a>option类型</h3><p>scala中，Option类型来表示可选值。这种类型的数据有两种形式：</p>
<p>Some(x)：表示实际的值</p>
<p>None：表示没有值</p>
<p>使用Option类型，可以用来有效避免空引用(null)异常。也就是说，将来我们返回某些数据时，可以返回一个Option类型来替代。</p>
<p>getOrElse方法</p>
<p>使用getOrElse方法，当Option对应的实例是None时，可以指定一个默认值，从而避免空指针异常</p>
<ol>
<li>scala鼓励使用Option类型来封装数据，可以有效减少，在代码中判断某个值是否为null</li>
<li>可以使用getOrElse方法来针对None返回一个默认值</li>
</ol>
<p>例子一</p>
<ul>
<li>定义一个两个数相除的方法，使用Option类型来封装结果</li>
<li>然后使用模式匹配来打印结果<ul>
<li>不是除零，打印结果</li>
<li>除零打印异常错误</li>
</ul>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> package com.nicai.demo.matchdemo</span><br><span class="line"></span><br><span class="line">object Demo10 &#123;</span><br><span class="line">  def div(a:Double,b:Int): Option[Double] =&#123;</span><br><span class="line">    if (b != 0)&#123;</span><br><span class="line">      Some(a/b)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      None</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val option = div(15.2,2)</span><br><span class="line">    val unit = option match &#123;</span><br><span class="line">      case Some(x) =&gt; x</span><br><span class="line">      case None =&gt; &quot;除数不可为0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)  //7.6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子二</p>
<ul>
<li>重写上述案例，使用getOrElse方法，当除零时，或者默认值为0</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.matchdemo</span><br><span class="line"></span><br><span class="line">object Demo11 &#123;</span><br><span class="line">  def div(a: Double, b: Int):Option[Double]= &#123;</span><br><span class="line">    if( b != 0)&#123;</span><br><span class="line">      Some(a/b)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      None</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = div(15.6,0).getOrElse(0)</span><br><span class="line">    println(d)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>偏函数可以提供了简洁的语法，可以简化函数的定义。配合集合的函数式编程，可以让代码更加优雅。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>偏函数被包在花括号内没有match的一组case语句是一个偏函数</li>
<li>偏函数是PartialFunction[A, B]的一个实例<ul>
<li>A代表输入参数类型</li>
<li>B代表返回结果类型</li>
</ul>
</li>
</ul>
<p>可以理解为：偏函数是一个参数和一个返回值的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.PartialFunctionDemo</span><br><span class="line"></span><br><span class="line">object Demo12 &#123;</span><br><span class="line"></span><br><span class="line">  private val value: PartialFunction[Int, String] = &#123;</span><br><span class="line">    case 1 =&gt; &quot;一&quot;</span><br><span class="line">    case 2 =&gt; &quot;二&quot;</span><br><span class="line">    case _ =&gt; &quot;其他&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(value(1))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个列表，包含1-10的数字</li>
<li>请将1-3的数字都转换为[1-3]</li>
<li>请将4-8的数字都转换为[4-8]</li>
<li>将其他的数字转换为(8-*]</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val list = (1 to 10).toList</span><br><span class="line"></span><br><span class="line">val list2 = list.map&#123;</span><br><span class="line">    case x if x &gt;= 1 &amp;&amp; x &lt;= 3 =&gt; &quot;[1-3]&quot;</span><br><span class="line">    case x if x &gt;= 4 &amp;&amp; x &lt;= 8 =&gt; &quot;[4-8]&quot;</span><br><span class="line">    case x if x &gt; 8 =&gt; &quot;(8-*]&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(list2)</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>在scala中，可以很方便地使用正则表达式来匹配数据。</p>
<p>scala中提供了Regex类来定义正则表达式，要构造一个RegEx对象，直接使用String类的r方法即可。</p>
<p>建议使用三个双引号来表示正则表达式，不然就得对正则中的反斜杠来进行转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val regEx = &quot;&quot;&quot;正则表达式&quot;&quot;&quot;.r</span><br></pre></td></tr></table></figure>

<p>findAllMatchIn方法</p>
<p>使用findAllMatchIn方法可以获取所有正则匹配到的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例说明</span><br><span class="line"></span><br><span class="line">定义一个正则表达式，来匹配邮箱是否合法</span><br><span class="line">合法邮箱测试：qq12344@163.com</span><br><span class="line">不合法邮箱测试：qq12344@.com</span><br><span class="line">val r = &quot;&quot;&quot;.+@.+\..+&quot;&quot;&quot;.r</span><br><span class="line"></span><br><span class="line">val eml1 = &quot;qq12344@163.com&quot;</span><br><span class="line">val eml2 = &quot;qq12344@.com&quot;</span><br><span class="line"></span><br><span class="line">if(r.findAllMatchIn(eml1).size &gt; 0) &#123;  //z\size  为0 没有匹配上  大于0 为匹配上</span><br><span class="line">    println(eml1 + &quot;邮箱合法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    println(eml1 + &quot;邮箱不合法&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(r.findAllMatchIn(eml2).size &gt; 0) &#123;</span><br><span class="line">    println(eml2 + &quot;邮箱合法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    println(eml2 + &quot;邮箱不合法&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找出以下列表中的所有不合法的邮箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;</span><br><span class="line">package com.nicai.demo.zhengzebiaodashi</span><br><span class="line">//匹配多个邮箱</span><br><span class="line">object Demo15 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var a= List(&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;)</span><br><span class="line"></span><br><span class="line">    val r=&quot;&quot;&quot;.+@.+\.com&quot;&quot;&quot;.r</span><br><span class="line">    val strings = a.filter &#123;</span><br><span class="line">      //过滤出不合法的</span><br><span class="line">      case x if r.findAllMatchIn(x).size == 0 =&gt; true</span><br><span class="line">      case _ =&gt; false</span><br><span class="line">    &#125;</span><br><span class="line">    println(strings)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有以下邮箱列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用正则表达式进行模式匹配，匹配出来邮箱运营商的名字。例如：邮箱<a href="mailto:zhansan@163.com" target="_blank" rel="noopener">zhansan@163.com</a>，需要将163匹配出来</p>
<ul>
<li>使用括号来匹配分组</li>
</ul>
</li>
<li><p>打印匹配到的邮箱以及运营商</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.zhengzebiaodashi</span><br><span class="line"></span><br><span class="line">object Demo16 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    //括号为分组</span><br><span class="line">    val re =&quot;&quot;&quot;.+@(.+)\.com&quot;&quot;&quot;.r   //此处必为 val</span><br><span class="line">    var li=List(&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;)</span><br><span class="line">    val strings = li.map &#123;</span><br><span class="line">      //company为分组的名字  就是分组的字段</span><br><span class="line">      case x@re(company) =&gt; s&quot;$&#123;x&#125; -&gt; $&#123;company&#125;&quot;</span><br><span class="line">      case x =&gt; s&quot;$&#123;x&#125; + 未知&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(strings)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>来看看下面一段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">   val i = 10 / 0</span><br><span class="line"></span><br><span class="line">    println(&quot;你好！&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at ForDemo$.main(ForDemo.scala:3)</span><br><span class="line">    at ForDemo.main(ForDemo.scala)</span><br></pre></td></tr></table></figure>

<p>执行程序，可以看到scala抛出了异常，而且没有打印出来”你好”。说明程序出现错误后就终止了。</p>
<p>那怎么解决该问题呢？</p>
<p>在scala中，可以使用异常处理来解决这个问题</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">catch &#123;</span><br><span class="line">    case ex:异常类型1 =&gt; // 代码</span><br><span class="line">    case ex:异常类型2 =&gt; // 代码</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>try中的代码是我们编写的业务处理代码</li>
<li>在catch中表示当出现某个异常时，需要执行的代码</li>
<li>在finally中，是不管是否出现异常都会执行的代码</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例说明</strong></p>
<ul>
<li>使用try..catch来捕获除零异常</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.exceptionDemo</span><br><span class="line"></span><br><span class="line">object Demo17 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      var a= 4/0</span><br><span class="line">    &#125;catch &#123;</span><br><span class="line">      case ex:Exception =&gt; println(ex.getMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###抛出异常</p>
<p>我们也可以在一个方法中，抛出异常。语法格式和Java类似，使用<code>throw new Exception...</code></p>
<p>例子:</p>
<ul>
<li>在main方法中抛出一个异常</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> package com.nicai.demo.exceptionDemo</span><br><span class="line"></span><br><span class="line">object Demo18 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    throw new Exception(&quot;这是一个异常&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.Exception: 这是一个异常</span><br><span class="line">    at ForDemo$.main(ForDemo.scala:3)</span><br><span class="line">    at ForDemo.main(ForDemo.scala)</span><br></pre></td></tr></table></figure>

<ul>
<li>scala不需要在方法上声明要抛出的异常，它已经解决了再Java中被认为是设计失败的检查型异常。</li>
</ul>
<p>下面是Java代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    throw new Exception(&quot;这是一个异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提取器"><a href="#提取器" class="headerlink" title="提取器"></a>提取器</h2><p>我们之前已经使用过scala中非常强大的模式匹配功能了，通过模式匹配，我们可以快速匹配样例类中的成员变量.</p>
<p>那是不是所有的类都可以进行这样的模式匹配呢？答案是：</p>
<p><code>不可以</code>的。要支持模式匹配，必须要实现一个<strong>提取器</strong>。</p>
<p><strong>样例类自动实现了apply、unapply方法</strong></p>
<h2 id="定义提取器"><a href="#定义提取器" class="headerlink" title="定义提取器"></a>定义提取器</h2><p>之前我们学习过了，实现一个类的伴生对象中的apply方法，可以用类名来快速构建一个对象。伴生对象中，还有一个unapply方法。与apply相反，unapply是将该类的对象，拆解为一个个的元素。</p>
<p>要实现一个类的提取器，只需要在该类的伴生对象中实现一个unapply方法即可</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def unapply(stu:Student):Option[(类型1, 类型2, 类型3...)] = &#123;</span><br><span class="line">    if(stu != null) &#123;</span><br><span class="line">        Some((变量1, 变量2, 变量3...))</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例说明</strong></p>
<ul>
<li>创建一个Student类，包含姓名年龄两个字段</li>
<li>实现一个类的解构器，并使用match表达式进行模式匹配，提取类中的字段。</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.tiquqi</span><br><span class="line"></span><br><span class="line">object Demo19 &#123;</span><br><span class="line">  class Stu(var name:String,var age:Int)</span><br><span class="line">  object Stu&#123;</span><br><span class="line">    def apply(name: String, age: Int): Stu = new Stu(name, age)</span><br><span class="line"></span><br><span class="line">    def unapply(stu :Stu) = &#123;</span><br><span class="line">      val tuple =(stu.name,stu.age)</span><br><span class="line">      Some(tuple)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val nicai = Stu(&quot;nicai&quot;,55)</span><br><span class="line">    val unit = nicai match &#123;</span><br><span class="line">      case Stu(name, age) =&gt; s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>scala和Java一样，类和特质、方法都可以支持泛型。我们在学习集合的时候，一般都会涉及到泛型。</p>
<h2 id="定义一个泛型方法"><a href="#定义一个泛型方法" class="headerlink" title="定义一个泛型方法"></a>定义一个泛型方法</h2><p>在scala中，使用方括号来定义类型参数。</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 方法名[泛型名称](..) = &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例说明</strong></p>
<ul>
<li>用一个方法来获取任意类型数组的中间的元素<ul>
<li>不考虑泛型直接实现（基于Array[Int]实现）</li>
<li>加入泛型支持</li>
</ul>
</li>
</ul>
<p><strong>参考代码</strong></p>
<p>不考虑泛型的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def getMiddle(arr:Array[Int]) = arr(arr.length / 2)</span><br><span class="line"></span><br><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">  val arr1 = Array(1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">  println(getMiddle(arr1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入泛型支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line">object Demo20 &#123;</span><br><span class="line">  def getMid[T](array: Array[T])= array(array.length/2)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(getMid(Array(1, 2, 3)))</span><br><span class="line">    println(getMid(Array(&quot;dd&quot;, &quot;uu&quot;, &quot;sss&quot;)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##泛型类</p>
<p>scala的类也可以定义泛型。接下来，我们来学习如何定义scala的泛型类</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类[T](val 变量名: T)</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个泛型类，直接在类名后面加上方括号，指定要使用的泛型参数</li>
<li>指定类对应的泛型参数后，就使用这些类型参数来定义变量了</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line">object Demo21 &#123;</span><br><span class="line">  case class Per[y] (name:y,age:y)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val list = List(</span><br><span class="line">      Per(&quot;NJJS&quot;, 45),</span><br><span class="line">      Per(&quot;jsjj&quot;, 789),</span><br><span class="line">      Per(56456, &quot;SSS&quot;)</span><br><span class="line">    )</span><br><span class="line">    println(list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上下界"><a href="#上下界" class="headerlink" title="上下界"></a>上下界</h2><p>需求：</p>
<p>我们在定义方法/类的泛型时，限定必须从哪个类继承、或者必须是哪个类的父类。此时，就需要使用到上下界。</p>
<p><strong>上界定义:</strong></p>
<p>使用<code>&lt;: 类型名</code>表示给类型添加一个<strong>上界</strong>，表示泛型参数必须要从该类（或本身）继承</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[T &lt;: 类型]</span><br></pre></td></tr></table></figure>

<p><strong>示例说明</strong></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line">object Demo22 &#123;</span><br><span class="line">   //上界</span><br><span class="line">  class  Per</span><br><span class="line">  class Stu extends Per</span><br><span class="line">  class Man extends Stu</span><br><span class="line">  def m[t &lt;: Stu](a:Array[t]) = println(a)   //Per 本身及其子类</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    // 编译报错</span><br><span class="line">   // m(Array(new Per))</span><br><span class="line">    m(Array(new Stu))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下界</strong></p>
<p>上界是要求必须是某个类的子类，或者必须从某个类继承，而下界是必须是<strong>某个类的父类</strong>（或本身）</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[T &gt;: 类型]</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>如果类既有上界、又有下界。下界写在前面，上界写在后面 (同时又上下界,可能会守不住,即范围之外的也可以)</p>
<p><strong>示例说明</strong></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object Demo23 &#123;</span><br><span class="line">//下界</span><br><span class="line"></span><br><span class="line">  class  Per</span><br><span class="line">  class Stu extends Per</span><br><span class="line">  class Man extends Stu</span><br><span class="line">  def m[T &gt;: Stu](a:Array[T])= println(a)  //Stu  本身及其父类</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    m(Array(new Stu))</span><br><span class="line">    m(Array(new Per))</span><br><span class="line">    //会报错</span><br><span class="line">    //m(Array(new Man))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协变-逆变-非变"><a href="#协变-逆变-非变" class="headerlink" title="协变 逆变 非变"></a>协变 逆变 非变</h2><p>spark的源代码中大量使用到了协变、逆变、非变，学习该知识点对我们将来阅读spark源代码很有帮助。</p>
<p>来看一个类型转换的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Pair[T]</span><br><span class="line"></span><br><span class="line">object Pair &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val p1 = Pair(&quot;hello&quot;)</span><br><span class="line">    // 编译报错，无法将p1转换为p2</span><br><span class="line">    val p2:Pair[AnyRef] = p1</span><br><span class="line"></span><br><span class="line">    println(p2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何让带有泛型的类支持类型转换呢？</p>
<p><strong>非变</strong></p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Pair[T]&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认泛型类是非变的</li>
<li>类型B是A的子类型，Pair[A]和Pair[B]没有任何从属关系</li>
<li>Java是一样的</li>
</ul>
<p><a href="https://manzhong.github.io/images/scala/fxn.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/fxn.png" alt="img"></a></p>
<h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Pair[+T]</span><br></pre></td></tr></table></figure>

<ul>
<li>类型B是A的子类型，Pair[B]可以认为是Pair[A]的子类型</li>
<li>参数化类型的方向和类型的方向是一致的。</li>
</ul>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Pair[-T]</span><br></pre></td></tr></table></figure>

<ul>
<li>类型B是A的子类型，Pair[A]反过来可以认为是Pair[B]的子类型</li>
<li>参数化类型的方向和类型的方向是相反的</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Super</span><br><span class="line">class Sub extends Super</span><br><span class="line"></span><br><span class="line">class Temp1[T]</span><br><span class="line">class Temp2[+T]</span><br><span class="line">class Temp3[-T]</span><br><span class="line"></span><br><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val a:Temp1[Sub] = new Temp1[Sub]</span><br><span class="line">    // 编译报错</span><br><span class="line">    // 非变</span><br><span class="line">    //val b:Temp1[Super] = a</span><br><span class="line"></span><br><span class="line">    // 协变</span><br><span class="line">    val c: Temp2[Sub] = new Temp2[Sub]</span><br><span class="line">    val d: Temp2[Super] = c</span><br><span class="line"></span><br><span class="line">    // 逆变</span><br><span class="line">    val e: Temp3[Super] = new Temp3[Super]</span><br><span class="line">    val f: Temp3[Sub] = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Actor并发编程"><a href="#Actor并发编程" class="headerlink" title="Actor并发编程"></a>Actor并发编程</h2><p>scala的Actor并发编程模型可以用来开发比Java线程效率更高的并发程序。我们学习scala Actor的目的主要是为后续学习Akka做准备。</p>
<h2 id="Java并发编程的问题"><a href="#Java并发编程的问题" class="headerlink" title="Java并发编程的问题"></a>Java并发编程的问题</h2><p>在Java并发编程中，每个对象都有一个逻辑监视器（monitor），可以用来控制对象的多线程访问。我们添加sychronized关键字来标记，需要进行同步加锁访问。这样，通过加锁的机制来确保同一时间只有一个线程访问共享数据。但这种方式存在资源争夺、以及死锁问题，程序越大问题越麻烦。</p>
<p>思索问题</p>
<p><a href="https://manzhong.github.io/images/scala/xcss.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/xcss.png" alt="img"></a></p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.Demo;</span><br><span class="line"></span><br><span class="line">public class MyLock &#123;</span><br><span class="line">    public static Object obja = new Object();</span><br><span class="line">    public static Object objb = new Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DieLock extends Thread &#123;</span><br><span class="line">    private boolean flag;</span><br><span class="line"></span><br><span class="line">    public DieLock(boolean flag) &#123;</span><br><span class="line">         this.flag=flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            synchronized (MyLock.obja)&#123;</span><br><span class="line">                System.out.println(&quot;a&quot;);</span><br><span class="line">                synchronized (MyLock.objb)&#123;</span><br><span class="line">                    System.out.println(&quot;b&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            synchronized (MyLock.objb)&#123;</span><br><span class="line">                System.out.println(&quot;bb&quot;);</span><br><span class="line">                synchronized (MyLock.obja)&#123;</span><br><span class="line">                    System.out.println(&quot;aa&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DieLock lock1 = new DieLock(true);</span><br><span class="line">        DieLock lock2 = new DieLock(false);</span><br><span class="line">        lock1.start();</span><br><span class="line">        lock2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Artor并发编程模型"><a href="#Artor并发编程模型" class="headerlink" title="Artor并发编程模型"></a>Artor并发编程模型</h3><p>Actor并发编程模型，是scala提供给程序员的一种与Java并发编程完全不一样的并发编程模型，是一种基于事件模型的并发机制。Actor并发编程模型是一种不共享数据，依赖消息传递的一种并发编程模式，有效避免资源争夺、死锁等情况。</p>
<p><a href="https://manzhong.github.io/images/scala/bf.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/bf.png" alt="img"></a></p>
<h3 id="java-并发编程-与Actor并发编程对比"><a href="#java-并发编程-与Actor并发编程对比" class="headerlink" title="java 并发编程 与Actor并发编程对比"></a>java 并发编程 与Actor并发编程对比</h3><table>
<thead>
<tr>
<th align="left">Java内置线程模型</th>
<th align="left">scala Actor模型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“共享数据-锁”模型 (share data and lock)</td>
<td align="left">share nothing</td>
</tr>
<tr>
<td align="left">每个object有一个monitor，监视线程对共享数据的访问</td>
<td align="left">不共享数据，Actor之间通过Message通讯</td>
</tr>
<tr>
<td align="left">加锁代码使用synchronized标识</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">死锁问题</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">每个线程内部是顺序执行的</td>
<td align="left">每个Actor内部是顺序执行的</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<p>scala在2.11.x版本中加入了Akka并发编程框架，老版本已经废弃。Actor的编程模型和Akka很像，我们这里学习Actor的目的是为学习Akka做准备。</p>
<h3 id="创建Actor"><a href="#创建Actor" class="headerlink" title="创建Actor"></a>创建Actor</h3><p>创建Actor的方式和Java中创建线程很类似，也是通过继承来创建。</p>
<p>使用方式</p>
<ol>
<li>定义class或object继承Actor特质</li>
<li>重写act方法</li>
<li>调用Actor的start方法执行Actor</li>
</ol>
<p>类似于Java线程，这里的每个Actor是并行执行的</p>
<p><strong>示例说明</strong></p>
<p>创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20</p>
<ul>
<li>使用class继承Actor创建（如果需要在程序中创建多个相同的Actor）</li>
<li>使用object继承Actor创建（如果在程序中只创建一个Actor）</li>
</ul>
<p><strong>参考代码</strong></p>
<p>使用class继承Actor创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object _05ActorDemo &#123;</span><br><span class="line">  class Actor1 extends Actor &#123;</span><br><span class="line">    override def act(): Unit = (1 to 10).foreach(println(_))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Actor2 extends Actor &#123;</span><br><span class="line">    override def act(): Unit = (11 to 20).foreach(println(_))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    new Actor1().start()</span><br><span class="line">    new Actor2().start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用object继承Actor创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo26 &#123;</span><br><span class="line">  object  A1 extends Actor&#123;</span><br><span class="line">    override def act(): Unit = (1 to 10).foreach(println(_)+&quot;,&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  object A2 extends Actor &#123;</span><br><span class="line">    override def act(): Unit = (11 to 20).foreach(print(_)+&quot;,&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    A1.start()</span><br><span class="line">     A2.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Actor程序运行流程"><a href="#Actor程序运行流程" class="headerlink" title="Actor程序运行流程"></a>Actor程序运行流程</h2><ol>
<li>调用start()方法启动Actor</li>
<li>自动执行<strong>act</strong>()方法</li>
<li>向Actor发送消息</li>
<li>act方法执行完成后，程序会调用<strong>exit()</strong>方法</li>
</ol>
<h3 id="发送消息-与接收消息"><a href="#发送消息-与接收消息" class="headerlink" title="发送消息 与接收消息"></a>发送消息 与接收消息</h3><p>我们之前介绍Actor的时候，说过Actor是基于事件（消息）的并发编程模型，那么Actor是如何发送消息和接收消息的呢？</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p><strong>发送消息</strong></p>
<p>我们可以使用三种方式来发送消息：</p>
<table>
<thead>
<tr>
<th align="left"><strong>！</strong></th>
<th align="left"><strong>发送异步消息，没有返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>!?</strong></td>
<td align="left"><strong>发送同步消息，等待返回值</strong></td>
</tr>
<tr>
<td align="left"><strong>!!</strong></td>
<td align="left"><strong>发送异步消息，返回值是Future[Any]</strong></td>
</tr>
</tbody></table>
<p>例如：</p>
<p>要给actor1发送一个异步字符串消息，使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actor1 ! &quot;你好!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>接收消息</strong></p>
<p>Actor中使用receive方法来接收消息，需要给receive方法传入一个偏函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    case 变量名1:消息类型1 =&gt; 业务处理1,</span><br><span class="line">    case 变量名2:消息类型2 =&gt; 业务处理2,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>receive方法只接收一次消息，接收完后继续执行act方法</p>
<p><strong>示例说明</strong></p>
<ul>
<li>创建两个Actor（ActorSender、ActorReceiver）</li>
<li>ActorSender发送一个异步字符串消息给ActorReceiver</li>
<li>ActorReceive接收到该消息后，打印出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo27 &#123;</span><br><span class="line">//发送消息 与 接收消息</span><br><span class="line">//发送</span><br><span class="line">  object  MsgSender extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      MsgReceiver ! &quot;nicai&quot;    //给谁发消息</span><br><span class="line">      TimeUnit.SECONDS.sleep(3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //接收</span><br><span class="line">  object MsgReceiver extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      receive&#123;</span><br><span class="line">        case msg: String =&gt; println(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgSender.start()</span><br><span class="line">    MsgReceiver.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持续接收消息"><a href="#持续接收消息" class="headerlink" title="持续接收消息"></a>持续接收消息</h3><p>通过上一个案例，ActorReceiver调用receive来接收消息，但接收一次后，Actor就退出了。</p>
<p>我们希望ActorReceiver能够一直接收消息，怎么实现呢？</p>
<p>——我们只需要使用一个while(true)循环，不停地调用receive来接收消息就可以啦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo27 &#123;</span><br><span class="line">//发送消息 与 接收消息</span><br><span class="line">//发送</span><br><span class="line">  object  MsgSender extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      MsgReceiver ! &quot;nicai&quot;</span><br><span class="line">      TimeUnit.SECONDS.sleep(3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //接收</span><br><span class="line">  object MsgReceiver extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      receive&#123;</span><br><span class="line">        case msg: String =&gt; println(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgSender.start()</span><br><span class="line">    MsgReceiver.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用loop和react-优化接收消息"><a href="#使用loop和react-优化接收消息" class="headerlink" title="使用loop和react 优化接收消息"></a>使用loop和react 优化接收消息</h3><p>上述代码，使用while循环来不断接收消息。</p>
<ul>
<li>如果当前Actor没有接收到消息，线程就会处于阻塞状态</li>
<li>如果有很多的Actor，就有可能会导致很多线程都是处于阻塞状态</li>
<li>每次有新的消息来时，重新创建线程来处理</li>
<li>频繁的线程创建、销毁和切换，会影响运行效率</li>
</ul>
<p>在scala中，可以使用loop + react来复用线程。比while + receive更高效</p>
<p>使用loop + react重写上述案例</p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 持续接收消息</span><br><span class="line">loop &#123;</span><br><span class="line">    react &#123;</span><br><span class="line">        case msg:String =&gt; println(&quot;接收到消息：&quot; + msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改写:</span><br><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo29 &#123;</span><br><span class="line">  object MsgSender extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      while(true)&#123;</span><br><span class="line">        MsgReceice ! &quot;NICAII&quot;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  object MsgReceice extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      loop&#123;</span><br><span class="line">        react&#123;</span><br><span class="line">          case msg :String =&gt; println(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgReceice.start()</span><br><span class="line">    MsgSender.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送和接收自定义消息"><a href="#发送和接收自定义消息" class="headerlink" title="发送和接收自定义消息"></a>发送和接收自定义消息</h3><p>我们前面发送的消息是字符串类型，Actor中也支持发送自定义消息，常见的如：使用样例类封装消息，然后进行发送处理。</p>
<p><strong>例子1</strong></p>
<p><strong>示例说明</strong></p>
<ul>
<li>创建一个MsgActor，并向它发送一个同步消息，该消息包含两个字段（id、message）</li>
<li>MsgActor回复一个消息，该消息包含两个字段（message、name）</li>
<li>打印回复消息</li>
</ul>
<p>注意:</p>
<ul>
<li>使用<code>!?</code>来发送同步消息</li>
<li>在Actor的act方法中，可以使用sender获取发送者的Actor引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//同步的方式</span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">//发送和接收自定义消息</span><br><span class="line">object Demo30 &#123;</span><br><span class="line"> //封装发送消息</span><br><span class="line"> case  class Msg(name:String,Age:Int)</span><br><span class="line">  //封装回复消息</span><br><span class="line"> case class ReplyMsg(name:String,addres:String)</span><br><span class="line">  //接收消息</span><br><span class="line">  object MsgActor extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      loop&#123;</span><br><span class="line">        react&#123;</span><br><span class="line">          case Msg(name,age) =&gt;&#123;</span><br><span class="line">            println(&quot;收到消息&quot;+s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;)</span><br><span class="line">            //获取发送者队象 并回复消息</span><br><span class="line">            sender ! ReplyMsg(&quot;wobucai&quot;,&quot;bbb&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgActor.start()</span><br><span class="line">//发送消息 并获取返回的消息</span><br><span class="line">    val unit:Any = MsgActor !? Msg(&quot;nicai&quot;,22)</span><br><span class="line">    //转换 消息类型</span><br><span class="line">    if(unit.isInstanceOf[ReplyMsg])&#123;</span><br><span class="line">      println(&quot;回复消息&quot;+unit.asInstanceOf[ReplyMsg])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例2</strong></p>
<ul>
<li>创建一个MsgActor，并向它发送一个异步无返回消息，该消息包含两个字段（message, company）</li>
<li>使用<code>!</code>发送异步无返回消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//异步无返回值</span><br><span class="line">import com.nicai.demo.actorDemo.Demo30.Msg</span><br><span class="line">import scala.actors.Actor</span><br><span class="line">object Demo31 &#123;</span><br><span class="line">  //封装 消息</span><br><span class="line">  case class Mag(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">  object  MsgActor extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      loop&#123;</span><br><span class="line">        react&#123;</span><br><span class="line">          case Msg(name,age) =&gt; &#123;</span><br><span class="line">            println(s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgActor.start()</span><br><span class="line">    //发送消息</span><br><span class="line">    MsgActor ! Msg(&quot;你猜&quot;,55)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子3</strong></p>
<ul>
<li><p>创建一个MsgActor，并向它发送一个异步有返回消息，该消息包含两个字段（id、message）</p>
</li>
<li><p>MsgActor回复一个消息，该消息包含两个字段（message、name）</p>
</li>
<li><p>打印回复消息</p>
<p>注意:</p>
</li>
<li><p>使用<code>!!</code>发送异步有返回消息</p>
</li>
<li><p>发送后，返回类型为Future[Any]的对象</p>
</li>
<li><p>Future表示异步返回数据的封装，虽获取到Future的返回值，但不一定有值，可能在将来某一时刻才会返回消息</p>
</li>
<li><p>Future的isSet()可检查是否已经收到返回消息，apply()方法可获取返回数据</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//异步有返回值</span><br><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo32 &#123;</span><br><span class="line">    //封装发送消息</span><br><span class="line">  case class Msg(name:String ,age: Int)</span><br><span class="line">  //封装返回消息</span><br><span class="line">  case class ReMsg(name:String ,age: Int)</span><br><span class="line"></span><br><span class="line">  //设置接收消息</span><br><span class="line">  object  MsgActor extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line"></span><br><span class="line">        loop&#123;</span><br><span class="line">          react&#123;</span><br><span class="line">            case Msg(name,age) =&gt;&#123;</span><br><span class="line">              println(s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;)</span><br><span class="line">              //返回消息</span><br><span class="line">              sender ! ReMsg(&quot;NICAI&quot;,4564)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgActor.start()</span><br><span class="line"></span><br><span class="line">    val unit = MsgActor !! Msg(&quot;温暖你的空间&quot;,777)</span><br><span class="line">    //if(unit.isInstanceOf[ReMsg])&#123;</span><br><span class="line">      //检查是否已经收到返回消息  apply()方法可获取返回数据</span><br><span class="line">      // 等待所有结果都已返回</span><br><span class="line">    while(!unit.isSet)&#123; &#125;</span><br><span class="line">println(unit.apply().asInstanceOf[ReMsg])</span><br><span class="line">    //&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##WordCount案例</p>
<p>我们要使用Actor并发编程模型实现多文件的单词统计</p>
<p>需求:</p>
<p>给定几个文本文件（文本文件都是以空格分隔的），使用Actor并发编程来统计单词的数量</p>
<p><a href="https://manzhong.github.io/images/scala/wc.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/wc.png" alt="img"></a></p>
<p><strong>实现思路</strong></p>
<ol>
<li>MainActor获取要进行单词统计的文件</li>
<li>根据文件数量创建对应的WordCountActor</li>
<li>将文件名封装为消息发送给WordCountActor</li>
<li>WordCountActor接收消息，并统计单个文件的单词计数</li>
<li>将单词计数结果发送给MainActor</li>
<li>MainActor等待所有的WordCountActor都已经成功返回消息，然后进行结果合并</li>
</ol>
<h2 id="步骤1-获取文件列表"><a href="#步骤1-获取文件列表" class="headerlink" title="步骤1 | 获取文件列表"></a>步骤1 | 获取文件列表</h2><p><strong>实现思路</strong></p>
<p>在main方法中读取指定目录(${project_root_dir}/data/)下的所有文件，并打印所有的文件名</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建用于测试的数据文件</li>
<li>加载工程根目录，获取到所有文件</li>
<li>将每一个文件名，添加目录路径</li>
<li>打印所有文件名</li>
</ol>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取文件目录</span><br><span class="line">   // val DIR=&quot;G:\\develop\\bigdatas\\BigData\\day22Scala3\\data/&quot;</span><br><span class="line">    val DIR=&quot;day22Scala3/data/&quot;   //当为maven的子工程时 不可使用 &quot;./data/&quot;</span><br><span class="line">    //获取文件流</span><br><span class="line">    val list = new File(DIR).list().toList</span><br><span class="line">    //把每个文件加上前缀 形成完整路径</span><br><span class="line">    val pathAll = list.map(DIR + _)</span><br><span class="line">    println(pathAll)</span><br></pre></td></tr></table></figure>

<h2 id="步骤2-创建WordCountActor"><a href="#步骤2-创建WordCountActor" class="headerlink" title="步骤2 | 创建WordCountActor"></a>步骤2 | 创建WordCountActor</h2><p><strong>实现思路</strong></p>
<p>根据文件数量创建WordCountActor，为了方便后续发送消息给Actor，将每个Actor与文件名关联在一起</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建WordCountActor</li>
<li>将文件列表转换为WordCountActor</li>
<li>为了后续方便发送消息给Actor，将Actor列表和文件列表拉链到一起</li>
<li>打印测试</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取wordcountList</span><br><span class="line"> val wordCountList = list.map &#123;</span><br><span class="line">   fileNmae =&gt; new WordCountActor()</span><br><span class="line"> &#125;</span><br><span class="line"> //每个 文件路径与 wordcount建立连接</span><br><span class="line"> val tuplesList = wordCountList.zip(pathAll)</span><br><span class="line"> println(tuplesList)</span><br></pre></td></tr></table></figure>

<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class WordCountActor extends Actor&#123;</span><br><span class="line">  override def act(): Unit = &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤3-启动Actor-发送-接收任务消息"><a href="#步骤3-启动Actor-发送-接收任务消息" class="headerlink" title="步骤3 | 启动Actor/发送/接收任务消息"></a>步骤3 | 启动Actor/发送/接收任务消息</h2><p><strong>实现思路</strong></p>
<p>启动所有WordCountActor，并发送单词统计任务消息给每个WordCountActor</p>
<p><strong>注意</strong></p>
<p>此处应发送异步有返回消息</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建一个WordCountTask样例类消息，封装要进行单词计数的文件名</li>
<li>启动所有WordCountTask，并发送异步有返回消息</li>
<li>获取到所有的WordCount中获取到的消息（封装到一个Future列表中）</li>
<li>在WordCountActor中接收并打印消息</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动 actor /发送和接收消息</span><br><span class="line">   tuplesList.map&#123;</span><br><span class="line">     actorFileName =&gt;&#123;</span><br><span class="line">       val actor = actorFileName._1</span><br><span class="line">       actor.start()</span><br><span class="line">       val future = actor !! Msg(actorFileName._2)</span><br><span class="line">       future</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>MessagePackage.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 单词统计任务消息</span><br><span class="line">  * @param fileName 文件名</span><br><span class="line">  */</span><br><span class="line">case class Msg(name:String)</span><br></pre></td></tr></table></figure>

<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class WordCountActor extends Actor&#123;</span><br><span class="line">  override def act(): Unit = &#123;</span><br><span class="line">    loop&#123;</span><br><span class="line">      react&#123;</span><br><span class="line">        //获取消息</span><br><span class="line">        case Msg(fileName) =&gt; println(&quot;对&quot;+fileName+&quot;进行单词统计&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤4-消息统计文件单词计数"><a href="#步骤4-消息统计文件单词计数" class="headerlink" title="步骤4 | 消息统计文件单词计数"></a>步骤4 | 消息统计文件单词计数</h2><p><strong>实现思路</strong></p>
<p>读取文件文本，并统计出来单词的数量。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(hadoop, 3), (spark, 1)...</span><br></pre></td></tr></table></figure>

<p><strong>实现步骤</strong></p>
<ol>
<li>读取文件内容，并转换为列表</li>
<li>按照空格切割文本，并转换为一个一个的单词</li>
<li>为了方便进行计数，将单词转换为元组</li>
<li>按照单词进行分组，然后再进行聚合统计</li>
<li>打印聚合统计结果</li>
</ol>
<p><strong>参考代码</strong></p>
<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class WordCountActor extends Actor&#123;</span><br><span class="line">  override def act(): Unit = &#123;</span><br><span class="line">    loop&#123;</span><br><span class="line">      react&#123;</span><br><span class="line">        //获取消息</span><br><span class="line">        case Msg(fileName) =&gt; println(&quot;对&quot;+fileName+&quot;进行单词统计&quot;)</span><br><span class="line">          //一 读取文件 获取列表  hadoop sqoop hadoop</span><br><span class="line">        val wordLineList = Source.fromFile(fileName).getLines().toList</span><br><span class="line">          //二 切割字符串,转换为一个一个的单词[hadoop, sqoop, hadoop]</span><br><span class="line">        val wordList = wordLineList.flatMap(_.split(&quot; &quot;))</span><br><span class="line">          //三将单词转换为元组  [&lt;hadoop,1&gt;, &lt;sqoop,1&gt;, &lt;hadoop,1&gt;]</span><br><span class="line">        val wordAndCountList = wordList.map(_ -&gt; 1)</span><br><span class="line">          // 四 对其进行分组 聚合计算</span><br><span class="line">        //4.1 分组 &#123;hadoop-&gt;List(&lt;hadoop,1&gt;,&lt;hadoop,1&gt;), sqoop-&gt;List(&lt;sqoop,1&gt;)&#125;</span><br><span class="line">        val wordGroubList = wordAndCountList.groupBy(_._1)</span><br><span class="line">          //4.2 聚合  &#123;hadoop-&gt;2, sqoop-&gt;1&#125;</span><br><span class="line">        var wordSum=wordGroubList.map&#123;</span><br><span class="line">          keyValue =&gt;</span><br><span class="line">            keyValue._1 -&gt; keyValue._2.map(_._2).sum</span><br><span class="line">        &#125;</span><br><span class="line">          println(wordSum)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤5-封装单词计数结果回复给MainActor"><a href="#步骤5-封装单词计数结果回复给MainActor" class="headerlink" title="步骤5 | 封装单词计数结果回复给MainActor"></a>步骤5 | 封装单词计数结果回复给MainActor</h2><p><strong>实现思路</strong></p>
<ul>
<li>将单词计数的结果封装为一个样例类消息，并发送给MainActor</li>
<li>MainActor等待所有WordCount均已返回后获取到每个WordCountActor单词计算后的结果</li>
</ul>
<p><strong>实现步骤</strong></p>
<ol>
<li>定义一个样例类封装单词计数结果</li>
<li>将单词计数结果发送给MainActor</li>
<li>MainActor中检测所有WordActor是否均已返回，如果均已返回，则获取并转换结果</li>
<li>打印结果</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MessagePackage.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 单词统计结果</span><br><span class="line">  * @param wordCount 单词计数</span><br><span class="line">  */</span><br><span class="line">//封装单词统计结果</span><br><span class="line">case class WordCountResult(wordSum:Map[String,Int])</span><br></pre></td></tr></table></figure>

<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//6将结果封装到样例类中,发送给WcMain</span><br><span class="line">sender ! WordCountResult(wordSum)</span><br></pre></td></tr></table></figure>

<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编写一个while循环来等待所有的Actor都已经返回数据</span><br><span class="line">     while (futureList.filter(!_.isSet).size!=0)&#123;&#125;</span><br><span class="line">   // 获取Future中封装的数据</span><br><span class="line">     val wordCountResultList = futureList.map(_.apply().asInstanceOf[WordCountResult])</span><br><span class="line">   // 获取样例类中封装的单词统计结果</span><br><span class="line">   val stringToInts = wordCountResultList.map(_.wordSum)</span><br><span class="line">   println(stringToInts)</span><br></pre></td></tr></table></figure>

<h2 id="步骤6-结果合并"><a href="#步骤6-结果合并" class="headerlink" title="步骤6 | 结果合并"></a>步骤6 | 结果合并</h2><p><strong>实现思路</strong></p>
<p>对接收到的所有单词计数进行合并。因为该部分已经在WordCountActor已经编写过，所以抽取这部分一样的代码到一个工具类中，再调用合并得到最终结果</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建一个用于单词合并的工具类</li>
<li>抽取重复代码为一个方法</li>
<li>在MainActor调用该合并方法，计算得到最终结果，并打印</li>
</ol>
<p><strong>参考代码</strong></p>
<p>WordCountUtil.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 单词分组统计</span><br><span class="line">  * @param wordCountList 单词计数列表</span><br><span class="line">  * @return 分组聚合结果</span><br><span class="line">  */</span><br><span class="line">def reduce(wordCountList:List[(String, Int)]) = &#123;</span><br><span class="line">  // 按照单词进行分组</span><br><span class="line">  // [单词分组] = &#123;hadoop-&gt;List(hadoop-&gt;1, hadoop-&gt;1, hadoop-&gt;1), spark-&gt;List(spark -&gt;1)&#125;</span><br><span class="line">  val grouped: Map[String, List[(String, Int)]] = wordCountList.groupBy(_._1)</span><br><span class="line">  // 将分组内的数据进行聚合</span><br><span class="line">  // [单词计数] = (hadoop, 3), (spark, 1)</span><br><span class="line">  val wordCount: Map[String, Int] = grouped.map &#123;</span><br><span class="line">    tuple =&gt;</span><br><span class="line">      // 单词</span><br><span class="line">      val word = tuple._1</span><br><span class="line">      // 进行计数</span><br><span class="line">      // 获取到所有的单词数量，然后进行累加</span><br><span class="line">      val total = tuple._2.map(_._2).sum</span><br><span class="line">      word -&gt; total</span><br><span class="line">  &#125;</span><br><span class="line">  wordCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 扁平化后再聚合计算</span><br><span class="line">val result: Map[String, Int] = WordCountUtil.reduce(resultList.flatten)</span><br><span class="line"></span><br><span class="line">println(&quot;最终结果:&quot; + result)</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>Ursprünglicher Autor: hechao</p><p>Ursprünglicher Link: <a href="http://yoursite.com/2018/10/27/Scala进阶2/">http://yoursite.com/2018/10/27/Scala进阶2/</a></p><p>Copyright-Erklärung: Bitte geben Sie die Quelle des Nachdrucks an.</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>Aktie:</span></div></div><div class="post-nav"><a href="/2018/11/04/Yarn-资源调度/" class="pre">Yarn-资源调度</a><a href="/2018/10/01/Scala进阶1/" class="next">Scala进阶1</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#样例类的方法"><span class="toc-text">样例类的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#样例对象"><span class="toc-text">样例对象</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#二模板匹配"><span class="toc-text">二模板匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单模式匹配"><span class="toc-text">简单模式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配类型"><span class="toc-text">匹配类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守卫"><span class="toc-text">守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配样例类"><span class="toc-text">匹配样例类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配集合"><span class="toc-text">匹配集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量声明中的模式匹配"><span class="toc-text">变量声明中的模式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#option类型"><span class="toc-text">option类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏函数"><span class="toc-text">偏函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式"><span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常处理"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获异常"><span class="toc-text">捕获异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提取器"><span class="toc-text">提取器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义提取器"><span class="toc-text">定义提取器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义一个泛型方法"><span class="toc-text">定义一个泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-1"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-1"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上下界"><span class="toc-text">上下界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协变-逆变-非变"><span class="toc-text">协变 逆变 非变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协变"><span class="toc-text">协变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆变"><span class="toc-text">逆变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actor并发编程"><span class="toc-text">Actor并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java并发编程的问题"><span class="toc-text">Java并发编程的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Artor并发编程模型"><span class="toc-text">Artor并发编程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-并发编程-与Actor并发编程对比"><span class="toc-text">java 并发编程 与Actor并发编程对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Actor"><span class="toc-text">创建Actor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actor程序运行流程"><span class="toc-text">Actor程序运行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送消息-与接收消息"><span class="toc-text">发送消息 与接收消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用方式"><span class="toc-text">使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#持续接收消息"><span class="toc-text">持续接收消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用loop和react-优化接收消息"><span class="toc-text">使用loop和react 优化接收消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送和接收自定义消息"><span class="toc-text">发送和接收自定义消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤1-获取文件列表"><span class="toc-text">步骤1 | 获取文件列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤2-创建WordCountActor"><span class="toc-text">步骤2 | 创建WordCountActor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤3-启动Actor-发送-接收任务消息"><span class="toc-text">步骤3 | 启动Actor/发送/接收任务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤4-消息统计文件单词计数"><span class="toc-text">步骤4 | 消息统计文件单词计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤5-封装单词计数结果回复给MainActor"><span class="toc-text">步骤5 | 封装单词计数结果回复给MainActor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#步骤6-结果合并"><span class="toc-text">步骤6 | 结果合并</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/08/SparkRDD/">SparkRDD</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/08/Spark入门/">Spark入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/24/shell/">shell</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/18/Scala高级/">Scala高级</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/04/Yarn-资源调度/">Yarn-资源调度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/27/Scala进阶2/">Scala进阶2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/01/Scala进阶1/">Scala进阶1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/25/Scala入门/">Scala入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/Oozie/">Oozie</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/数据库/">数据库</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Sitemap</a> |  <a href="/atom.xml">Abonnieren Sie diese Site</a> |  <a href="/about/">Kontaktieren Sie den Blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">hechao.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>