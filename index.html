<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MapReduce" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/MapReduce/" class="article-date">
  <time datetime="2019-08-08T03:22:02.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/MapReduce/">MapReduce</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="hadoop的核心-MapReduce"><a href="#hadoop的核心-MapReduce" class="headerlink" title="hadoop的核心 MapReduce"></a>hadoop的核心 MapReduce</h1><h2 id="1-MapReduce-介绍"><a href="#1-MapReduce-介绍" class="headerlink" title="1. MapReduce 介绍"></a>1. MapReduce 介绍</h2><p>MapReduce思想在生活中处处可见。或多或少都曾接触过这种思想。MapReduce的思想核心是“分而治之”，适用于大量复杂的任务处理场景（大规模数据处理场景）。</p>
<ul>
<li>Map负责“分”，即把复杂的任务分解为若干个“简单的任务”来并行处理。可以进行拆分的前提<strong>是这些小任务可以并行计算，彼此间几乎没有依赖关系</strong>。</li>
<li>Reduce负责“合”，即对map阶段的结果进行全局汇总。</li>
<li>MapReduce运行在yarn集群<ol>
<li>ResourceManager</li>
<li>NodeManager</li>
</ol>
</li>
</ul>
<p>这两个阶段合起来正是MapReduce思想的体现。</p>
<p>还有一个比较形象的语言解释MapReduce:</p>
<p>我们要数图书馆中的所有书。你数1号书架，我数2号书架。这就是“Map”。我们人越多，数书就更快。</p>
<p>现在我们到一起，把所有人的统计数加在一起。这就是“Reduce”。</p>
<h3 id="1-1-MapReduce-设计构思"><a href="#1-1-MapReduce-设计构思" class="headerlink" title="1.1. MapReduce 设计构思"></a>1.1. MapReduce 设计构思</h3><p>MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在Hadoop集群上。</p>
<p>MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。为程序员提供一个抽象和高层的编程接口和框架。程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理：</p>
<p>Map和Reduce为程序员提供了一个清晰的操作接口抽象描述。MapReduce中定义了如下的Map和Reduce两个抽象的编程接口，由用户去编程实现.Map和Reduce,MapReduce处理的数据类型是&lt;key,value&gt;键值对。</p>
<ul>
<li>Map: <code>(k1; v1) → [(k2; v2)]</code></li>
<li>Reduce: <code>(k2; [v2]) → [(k3; v3)]</code></li>
</ul>
<p>一个完整的mapreduce程序在分布式运行时有三类实例进程：</p>
<ol>
<li><code>MRAppMaster</code> 负责整个程序的过程调度及状态协调</li>
<li><code>MapTask</code> 负责map阶段的整个数据处理流程</li>
<li><code>ReduceTask</code> 负责reduce阶段的整个数据处理流程</li>
</ol>
<h2 id="2-MapReduce-编程规范"><a href="#2-MapReduce-编程规范" class="headerlink" title="2. MapReduce 编程规范"></a>2. MapReduce 编程规范</h2><p>MapReduce 的开发一共有八个步骤, 其中 Map 阶段分为 2 个步骤，Shuffle 阶段 4 个步骤，Reduce 阶段分为 2 个步骤</p>
<p><a href="https://manzhong.github.io/images/MapReduce/lc.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/lc.jpg" alt="img"></a></p>
<h5 id="Map-阶段-2-个步骤"><a href="#Map-阶段-2-个步骤" class="headerlink" title="Map 阶段 2 个步骤"></a>Map 阶段 2 个步骤</h5><ol>
<li>设置 InputFormat 类, 将数据切分为 Key-Value<strong>(K1和V1)</strong> 对, 输入到第二步 <strong>k1为源数据的每行的偏移量,v1为行数据</strong></li>
<li>自定义 Map 逻辑, 将第一步的结果转换成另外的 Key-Value（<strong>K2和V2</strong>） 对, 输出结果</li>
</ol>
<h5 id="Shuffle-阶段-4-个步骤"><a href="#Shuffle-阶段-4-个步骤" class="headerlink" title="Shuffle 阶段 4 个步骤"></a>Shuffle 阶段 4 个步骤</h5><ol>
<li><p>对输出的 Key-Value 对进行<strong>分区</strong> 自定义类继承Partitioner类 方法 getPartition 类的参数与k2v2同</p>
<p>reduce的默认分区只有一个,k2的哈希值与上int的最大值,模上ReduceTask的个数 指定分区就是相同类型的,共性的数据发送到同一个reduce中处理.</p>
</li>
<li><p>对不同分区的数据按照相同的 Key <strong>排序</strong> 自定义类实现WritableComparable 成员变量为不要排序的列</p>
</li>
<li><p>(可选) 对分组过的数据初步<strong>规约</strong>, 降低数据的网络拷贝 每个map都会产生大量本地输出 作用: 对map端的输出先做一次合并,减少在map和reduce节点间的数据传输量,提高网络io性能</p>
<p>应用前提: 不能影响最终业务逻辑</p>
<p>自定义类 继承 Reduce类</p>
</li>
<li><p>对数据进行<strong>分组</strong>, 相同 Key 的 Value 放入一个集合中</p>
</li>
</ol>
<h5 id="Reduce-阶段-2-个步骤"><a href="#Reduce-阶段-2-个步骤" class="headerlink" title="Reduce 阶段 2 个步骤"></a>Reduce 阶段 2 个步骤</h5><ol>
<li>对多个 Map 任务的结果进行排序以及合并, 编写 Reduce 函数实现自己的逻辑, 对输入的 Key-Value 进行处理, 转为新的 Key-Value（<strong>K3和V3</strong>）输出</li>
<li>设置 OutputFormat 处理并保存 Reduce 输出的 Key-Value 数据</li>
</ol>
<h2 id="3-WordCount"><a href="#3-WordCount" class="headerlink" title="3. WordCount"></a>3. WordCount</h2><blockquote>
<p>需求: 在一堆给定的文本文件中统计输出每一个单词出现的总次数</p>
</blockquote>
<h5 id="Step-1-数据格式准备"><a href="#Step-1-数据格式准备" class="headerlink" title="Step 1. 数据格式准备"></a>Step 1. 数据格式准备</h5><ol>
<li><p>创建一个新的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers</span><br><span class="line">vim wordcount.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>向其中放入以下内容并保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello,world,hadoop</span><br><span class="line">hive,sqoop,flume,hello</span><br><span class="line">kitty,tom,jerry,world</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传到 HDFS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir /wordcount/</span><br><span class="line">hdfs dfs -put wordcount.txt /wordcount/</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="Step-2-Mapper"><a href="#Step-2-Mapper" class="headerlink" title="Step 2. Mapper"></a>Step 2. Mapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountMapper extends Mapper&lt;LongWritable,Text,Text,LongWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] split = line.split(&quot;,&quot;);</span><br><span class="line">        for (String word : split) &#123;</span><br><span class="line">            context.write(new Text(word),new LongWritable(1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-3-Reducer"><a href="#Step-3-Reducer" class="headerlink" title="Step 3. Reducer"></a>Step 3. Reducer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class WordCountReducer extends Reducer&lt;Text,LongWritable,Text,LongWritable&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 自定义我们的reduce逻辑</span><br><span class="line">     * 所有的key都是我们的单词，所有的values都是我们单词出现的次数</span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @param context</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        long count = 0;</span><br><span class="line">        for (LongWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key,new LongWritable(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-4-定义主类-描述-Job-并提交-Job"><a href="#Step-4-定义主类-描述-Job-并提交-Job" class="headerlink" title="Step 4. 定义主类, 描述 Job 并提交 Job"></a>Step 4. 定义主类, 描述 Job 并提交 Job</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), JobMain.class.getSimpleName());</span><br><span class="line">        //打包到集群上面运行时候，必须要添加以下配置，指定程序的main函数</span><br><span class="line">        job.setJarByClass(JobMain.class);</span><br><span class="line">        //第一步：读取输入文件解析成key，value对</span><br><span class="line">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        TextInputFormat.addInputPath(job,new Path(&quot;hdfs://192.168.52.250:8020/wordcount&quot;));</span><br><span class="line"></span><br><span class="line">        //第二步：设置我们的mapper类</span><br><span class="line">        job.setMapperClass(WordCountMapper.class);</span><br><span class="line">        //设置我们map阶段完成之后的输出类型</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(LongWritable.class);</span><br><span class="line">        //第三步，第四步，第五步，第六步，省略</span><br><span class="line">        //第七步：设置我们的reduce类</span><br><span class="line">        job.setReducerClass(WordCountReducer.class);</span><br><span class="line">        //设置我们reduce阶段完成之后的输出类型</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(LongWritable.class);</span><br><span class="line">        //第八步：设置输出类以及输出路径</span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">        TextOutputFormat.setOutputPath(job,new Path(&quot;hdfs://192.168.52.250:8020/wordcount_out&quot;));</span><br><span class="line">        boolean b = job.waitForCompletion(true);</span><br><span class="line">        return b?0:1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 程序main函数的入口类</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        Tool tool  =  new JobMain();</span><br><span class="line">        int run = ToolRunner.run(configuration, tool, args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h5><p>如果遇到如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.AccessControlException): Permission denied: user=admin, access=WRITE, inode=&quot;/&quot;:root:supergroup:drwxr-xr-x</span><br></pre></td></tr></table></figure>

<p>直接将hdfs-site.xml当中的权限关闭即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>最后重启一下 HDFS 集群</p>
<h5 id="小细节"><a href="#小细节" class="headerlink" title="小细节"></a>小细节</h5><p>本地运行完成之后，就可以打成jar包放到服务器上面去运行了，实际工作当中，都是将代码打成jar包，开发main方法作为程序的入口，然后放到集群上面去运行</p>
<h2 id="4-MapReduce-运行模式"><a href="#4-MapReduce-运行模式" class="headerlink" title="4. MapReduce 运行模式"></a>4. MapReduce 运行模式</h2><h5 id="本地运行模式"><a href="#本地运行模式" class="headerlink" title="本地运行模式"></a>本地运行模式</h5><ol>
<li>MapReduce 程序是被提交给 LocalJobRunner 在本地以单进程的形式运行</li>
<li>处理的数据及输出结果可以在本地文件系统, 也可以在hdfs上</li>
<li>怎样实现本地运行? 写一个程序, 不要带集群的配置文件, 本质是程序的 <code>conf</code> 中是否有 <code>mapreduce.framework.name=local</code> 以及 <code>yarn.resourcemanager.hostname=local</code> 参数</li>
<li>本地模式非常便于进行业务逻辑的 <code>Debug</code>, 只要在 idea 中打断点即可</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configuration.set(&quot;mapreduce.framework.name&quot;,&quot;local&quot;);</span><br><span class="line">configuration.set(&quot; yarn.resourcemanager.hostname&quot;,&quot;local&quot;);</span><br><span class="line">TextInputFormat.addInputPath(job,new Path(&quot;file:///F:\\wordcount\\input&quot;));</span><br><span class="line">TextOutputFormat.setOutputPath(job,new Path(&quot;file:///F:\\wordcount\\output&quot;));</span><br></pre></td></tr></table></figure>

<h5 id="集群运行模式"><a href="#集群运行模式" class="headerlink" title="集群运行模式"></a>集群运行模式</h5><ol>
<li>将 MapReduce 程序提交给 Yarn 集群, 分发到很多的节点上并发执行</li>
<li>处理的数据和输出结果应该位于 HDFS 文件系统</li>
<li>提交集群的实现步骤: 将程序打成JAR包，然后在集群的任意一个节点上用hadoop命令启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop_hdfs_operate-1.0-SNAPSHOT.jar cn.itcast.hdfs.demo1.JobMain</span><br></pre></td></tr></table></figure>

<h2 id="5-MapReduce-分区"><a href="#5-MapReduce-分区" class="headerlink" title="5. MapReduce 分区"></a>5. MapReduce 分区</h2><p>在 MapReduce 中, 通过我们指定分区, 会将同一个分区的数据发送到同一个 Reduce 当中进行处理</p>
<p>例如: 为了数据的统计, 可以把一批类似的数据发送到同一个 Reduce 当中, 在同一个 Reduce 当中统计相同类型的数据, 就可以实现类似的数据分区和统计等</p>
<p>其实就是相同类型的数据, 有共性的数据, 送到一起去处理</p>
<p>Reduce 当中默认的分区只有一个</p>
<blockquote>
<p>Step 1. 定义 Mapper</p>
</blockquote>
<p>这个 Mapper 程序不做任何逻辑, 也不对 Key-Value 做任何改变, 只是接收数据, 然后往下发送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyMapper extends Mapper&lt;LongWritable,Text,Text,NullWritable&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        context.write(value,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-2-定义-Reducer-逻辑"><a href="#Step-2-定义-Reducer-逻辑" class="headerlink" title="Step 2. 定义 Reducer 逻辑"></a>Step 2. 定义 Reducer 逻辑</h5><p>这个 Reducer 也不做任何处理, 将数据原封不动的输出即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyReducer extends Reducer&lt;Text,NullWritable,Text,NullWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;NullWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        context.write(key,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-3-自定义-Partitioner"><a href="#Step-3-自定义-Partitioner" class="headerlink" title="Step 3. 自定义 Partitioner"></a>Step 3. 自定义 Partitioner</h5><p>主要的逻辑就在这里, 这也是这个案例的意义, 通过 Partitioner 将数据分发给不同的 Reducer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PartitonerOwn extends Partitioner&lt;Text,LongWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getPartition(Text text, LongWritable longWritable, int i) &#123;</span><br><span class="line">        if(text.toString().length() &gt;=5 )&#123;</span><br><span class="line">            return  0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-4-Main-入口"><a href="#Step-4-Main-入口" class="headerlink" title="Step 4. Main 入口"></a>Step 4. Main 入口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class PartitionMain  extends Configured implements Tool &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception&#123;</span><br><span class="line">        int run = ToolRunner.run(new Configuration(), new PartitionMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), PartitionMain.class.getSimpleName());</span><br><span class="line">        job.setJarByClass(PartitionMain.class);</span><br><span class="line">        //第一步 </span><br><span class="line">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">        TextInputFormat.addInputPath(job,new Path(&quot;hdfs://192.168.52.250:8020/partitioner&quot;));</span><br><span class="line">        TextOutputFormat.setOutputPath(job,new Path(&quot;hdfs://192.168.52.250:8020/outpartition&quot;));</span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        /**</span><br><span class="line">         * 设置我们的分区类，以及我们的reducetask的个数，注意reduceTask的个数一定要与我们的</span><br><span class="line">         * 分区数保持一致</span><br><span class="line">         */</span><br><span class="line">        job.setPartitionerClass(MyPartitioner.class);</span><br><span class="line">        job.setNumReduceTasks(2);</span><br><span class="line">        boolean b = job.waitForCompletion(true);</span><br><span class="line">        return b?0:1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-MapReduce-排序和序列化"><a href="#6-MapReduce-排序和序列化" class="headerlink" title="6. MapReduce 排序和序列化"></a>6. MapReduce 排序和序列化</h2><ul>
<li>序列化 (Serialization) 是指把结构化对象转化为字节流</li>
<li>反序列化 (Deserialization) 是序列化的逆过程. 把字节流转为结构化对象. 当要在进程间传递对象或持久化对象的时候, 就需要序列化对象成字节流, 反之当要将接收到或从磁盘读取的字节流转换为对象, 就要进行反序列化</li>
<li>Java 的序列化 (Serializable) 是一个重量级序列化框架, 一个对象被序列化后, 会附带很多额外的信息 (各种校验信息, header, 继承体系等）, 不便于在网络中高效传输. 所以, Hadoop 自己开发了一套序列化机制(Writable), 精简高效. 不用像 Java 对象类一样传输多层的父子关系, 需要哪个属性就传输哪个属性值, 大大的减少网络传输的开销</li>
<li>Writable 是 Hadoop 的序列化格式, Hadoop 定义了这样一个 Writable 接口. 一个类要支持可序列化只需实现这个接口即可</li>
<li>另外 Writable 有一个子接口是 WritableComparable, WritableComparable 是既可实现序列化, 也可以对key进行比较, 我们这里可以通过自定义 Key 实现 WritableComparable 来实现我们的排序功能</li>
</ul>
<p>数据格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a	1</span><br><span class="line">a	9</span><br><span class="line">b	3</span><br><span class="line">a	7</span><br><span class="line">b	8</span><br><span class="line">b	10</span><br><span class="line">a	5</span><br></pre></td></tr></table></figure>

<p>要求:</p>
<ul>
<li>第一列按照字典顺序进行排列</li>
<li>第一列相同的时候, 第二列按照升序进行排列</li>
</ul>
<p>解决思路:</p>
<ul>
<li>将 Map 端输出的 <code>&lt;key,value&gt;</code> 中的 key 和 value 组合成一个新的 key (newKey), value值不变</li>
<li>这里就变成 <code>&lt;(key,value),value&gt;</code>, 在针对 newKey 排序的时候, 如果 key 相同, 就再对value进行排序</li>
</ul>
<h5 id="Step-1-自定义类型和比较器"><a href="#Step-1-自定义类型和比较器" class="headerlink" title="Step 1. 自定义类型和比较器"></a>Step 1. 自定义类型和比较器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">public class PairWritable implements WritableComparable&lt;PairWritable&gt; &#123;</span><br><span class="line">    // 组合key,第一部分是我们第一列，第二部分是我们第二列</span><br><span class="line">    private String first;</span><br><span class="line">    private int second;</span><br><span class="line">    public PairWritable() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public PairWritable(String first, int second) &#123;</span><br><span class="line">        this.set(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 方便设置字段</span><br><span class="line">     */</span><br><span class="line">    public void set(String first, int second) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">        this.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 反序列化</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void readFields(DataInput input) throws IOException &#123;</span><br><span class="line">        this.first = input.readUTF();</span><br><span class="line">        this.second = input.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 序列化</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void write(DataOutput output) throws IOException &#123;</span><br><span class="line">        output.writeUTF(first);</span><br><span class="line">        output.writeInt(second);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * 重写比较器</span><br><span class="line">     */</span><br><span class="line">    public int compareTo(PairWritable o) &#123;</span><br><span class="line">        //每次比较都是调用该方法的对象与传递的参数进行比较，说白了就是第一行与第二行比较完了之后的结果与第三行比较，</span><br><span class="line">        //得出来的结果再去与第四行比较，依次类推</span><br><span class="line">        System.out.println(o.toString());</span><br><span class="line">        System.out.println(this.toString());</span><br><span class="line">        int comp = this.first.compareTo(o.first);</span><br><span class="line">        if (comp != 0) &#123;</span><br><span class="line">            return comp;</span><br><span class="line">        &#125; else &#123; // 若第一个字段相等，则比较第二个字段</span><br><span class="line">            return Integer.valueOf(this.second).compareTo(</span><br><span class="line">                    Integer.valueOf(o.getSecond()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSecond() &#123;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSecond(int second) &#123;</span><br><span class="line">        this.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getFirst() &#123;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFirst(String first) &#123;</span><br><span class="line">        this.first = first;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;PairWritable&#123;&quot; +</span><br><span class="line">                &quot;first=&apos;&quot; + first + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, second=&quot; + second +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-2-Mapper-1"><a href="#Step-2-Mapper-1" class="headerlink" title="Step 2. Mapper"></a>Step 2. Mapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SortMapper extends Mapper&lt;LongWritable,Text,PairWritable,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private PairWritable mapOutKey = new PairWritable();</span><br><span class="line">    private IntWritable mapOutValue = new IntWritable();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public  void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String lineValue = value.toString();</span><br><span class="line">        String[] strs = lineValue.split(&quot;\t&quot;);</span><br><span class="line">        //设置组合key和value ==&gt; &lt;(key,value),value&gt;</span><br><span class="line">        mapOutKey.set(strs[0], Integer.valueOf(strs[1]));</span><br><span class="line">        mapOutValue.set(Integer.valueOf(strs[1]));</span><br><span class="line">        context.write(mapOutKey, mapOutValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-3-Reducer-1"><a href="#Step-3-Reducer-1" class="headerlink" title="Step 3. Reducer"></a>Step 3. Reducer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SortReducer extends Reducer&lt;PairWritable,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Text outPutKey = new Text();</span><br><span class="line">    @Override</span><br><span class="line">    public void reduce(PairWritable key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">//迭代输出</span><br><span class="line">        for(IntWritable value : values) &#123;</span><br><span class="line">            outPutKey.set(key.getFirst());</span><br><span class="line">            context.write(outPutKey, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-4-Main-入口-1"><a href="#Step-4-Main-入口-1" class="headerlink" title="Step 4. Main 入口"></a>Step 4. Main 入口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:创建job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;mapreduce_sort&quot;);</span><br><span class="line"></span><br><span class="line">        //2:配置job任务(八个步骤)</span><br><span class="line">            //第一步:设置输入类和输入的路径</span><br><span class="line">            job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">            ///TextInputFormat.addInputPath(job, new Path(&quot;hdfs://node01:8020/input/sort_input&quot;));</span><br><span class="line">            TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\sort_input&quot;));</span><br><span class="line"></span><br><span class="line">            //第二步: 设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(SortMapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(SortBean.class);</span><br><span class="line">            job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line">            //第三，四，五，六</span><br><span class="line"></span><br><span class="line">            //第七步：设置Reducer类和类型</span><br><span class="line">            job.setReducerClass(SortReducer.class);</span><br><span class="line">            job.setOutputKeyClass(SortBean.class);</span><br><span class="line">            job.setOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //第八步: 设置输出类和输出的路径</span><br><span class="line">            job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">            //TextOutputFormat.setOutputPath(job, new Path(&quot;hdfs://node01:8020/out/sort_out&quot;));</span><br><span class="line">            TextOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\sort_out&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3:等待任务结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line"></span><br><span class="line">        return bl?0:1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line"></span><br><span class="line">        //启动job任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line"></span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MapReduce-中的计数器"><a href="#MapReduce-中的计数器" class="headerlink" title="MapReduce 中的计数器"></a>MapReduce 中的计数器</h2><p>计数器是收集作业统计信息的有效手段之一，用于质量控制或应用级统计。计数器还可辅助诊断系统故障。如果需要将日志信息传输到 map 或 reduce 任务， 更好的方法通常是看能否用一个计数器值来记录某一特定事件的发生。对于大型分布式作业而言，使用计数器更为方便。除了因为获取计数器值比输出日志更方便，还有根据计数器值统计特定事件的发生次数要比分析一堆日志文件容易得多。</p>
<p>hadoop内置计数器列表</p>
<table>
<thead>
<tr>
<th align="left"><strong>MapReduce任务计数器</strong></th>
<th align="left"><strong>org.apache.hadoop.mapreduce.TaskCounter</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">文件系统计数器</td>
<td align="left">org.apache.hadoop.mapreduce.FileSystemCounter</td>
</tr>
<tr>
<td align="left">FileInputFormat计数器</td>
<td align="left">org.apache.hadoop.mapreduce.lib.input.FileInputFormatCounter</td>
</tr>
<tr>
<td align="left">FileOutputFormat计数器</td>
<td align="left">org.apache.hadoop.mapreduce.lib.output.FileOutputFormatCounter</td>
</tr>
<tr>
<td align="left">作业计数器</td>
<td align="left">org.apache.hadoop.mapreduce.JobCounter</td>
</tr>
</tbody></table>
<p><strong>每次mapreduce执行完成之后，我们都会看到一些日志记录出来，其中最重要的一些日志记录如下截图</strong></p>
<p><strong>所有的这些都是MapReduce的计数器的功能，既然MapReduce当中有计数器的功能，我们如何实现自己的计数器？？？</strong></p>
<blockquote>
<p><strong>需求：以以上分区代码为案例，统计map接收到的数据记录条数</strong></p>
</blockquote>
<h5 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h5><p><strong>第一种方式定义计数器，通过context上下文对象可以获取我们的计数器，进行记录</strong><br><strong>通过context上下文对象，在map端使用计数器进行统计</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PartitionMapper  extends Mapper&lt;LongWritable,Text,Text,NullWritable&gt;&#123;</span><br><span class="line">    //map方法将K1和V1转为K2和V2</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws Exception&#123;</span><br><span class="line">        Counter counter = context.getCounter(&quot;MR_COUNT&quot;, &quot;MyRecordCounter&quot;);</span><br><span class="line">        counter.increment(1L);</span><br><span class="line">        context.write(value,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行程序之后就可以看到我们自定义的计数器在map阶段读取了七条数据</strong></p>
<h5 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a><strong>第二种方式</strong></h5><p><strong>通过enum枚举类型来定义计数器</strong><br>统计reduce端数据的输入的key有多少个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class PartitionerReducer extends Reducer&lt;Text,NullWritable,Text,NullWritable&gt; &#123;</span><br><span class="line">   public static enum Counter&#123;</span><br><span class="line">       MY_REDUCE_INPUT_RECORDS,MY_REDUCE_INPUT_BYTES</span><br><span class="line">   &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;NullWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">       context.getCounter(Counter.MY_REDUCE_INPUT_RECORDS).increment(1L);</span><br><span class="line">       context.write(key, NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规约Combiner"><a href="#规约Combiner" class="headerlink" title="规约Combiner"></a>规约Combiner</h2><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>每一个 map 都可能会产生大量的本地输出，Combiner 的作用就是对 map 端的输出先做一次合并，以减少在 map 和 reduce 节点之间的数据传输量，以提高网络IO 性能，是 MapReduce 的一种优化手段之一</p>
<ul>
<li>combiner 是 MR 程序中 Mapper 和 Reducer 之外的一种组件</li>
<li>combiner 组件的父类就是 Reducer</li>
<li>combiner 和 reducer 的区别在于运行的位置<ul>
<li>Combiner 是在每一个 maptask 所在的节点运行</li>
<li>Reducer 是接收全局所有 Mapper 的输出结果</li>
</ul>
</li>
<li>combiner 的意义就是对每一个 maptask 的输出进行局部汇总，以减小网络传输量</li>
</ul>
<h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ol>
<li>自定义一个 combiner 继承 Reducer，重写 reduce 方法</li>
<li>在 job 中设置 <code>job.setCombinerClass(CustomCombiner.class)</code></li>
</ol>
<p>combiner 能够应用的前提是不能影响最终的业务逻辑，而且，combiner 的输出 kv 应该跟 reducer 的输入 kv 类型要对应起来</p>
<h2 id="MapReduce案例-流量统计"><a href="#MapReduce案例-流量统计" class="headerlink" title="MapReduce案例-流量统计"></a>MapReduce案例-流量统计</h2><h3 id="需求一-统计求和"><a href="#需求一-统计求和" class="headerlink" title="需求一: 统计求和"></a>需求一: 统计求和</h3><p>统计每个手机号的上行数据包总和，下行数据包总和，上行总流量之和，下行总流量之和<br>分析：以手机号码作为key值，上行流量，下行流量，上行总流量，下行总流量四个字段作为value值，然后以这个key，和value作为map阶段的输出，reduce阶段的输入</p>
<h5 id="Step-1-自定义map的输出value对象FlowBean"><a href="#Step-1-自定义map的输出value对象FlowBean" class="headerlink" title="Step 1: 自定义map的输出value对象FlowBean"></a>Step 1: 自定义map的输出value对象FlowBean</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class FlowBean implements Writable &#123;</span><br><span class="line">    private Integer upFlow;</span><br><span class="line">    private Integer  downFlow;</span><br><span class="line">    private Integer upCountFlow;</span><br><span class="line">    private Integer downCountFlow;</span><br><span class="line">    @Override</span><br><span class="line">    public void write(DataOutput out) throws IOException &#123;</span><br><span class="line">        out.writeInt(upFlow);</span><br><span class="line">        out.writeInt(downFlow);</span><br><span class="line">        out.writeInt(upCountFlow);</span><br><span class="line">        out.writeInt(downCountFlow);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void readFields(DataInput in) throws IOException &#123;</span><br><span class="line">        this.upFlow = in.readInt();</span><br><span class="line">        this.downFlow = in.readInt();</span><br><span class="line">        this.upCountFlow = in.readInt();</span><br><span class="line">        this.downCountFlow = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">    public FlowBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public FlowBean(Integer upFlow, Integer downFlow, Integer upCountFlow, Integer downCountFlow) &#123;</span><br><span class="line">        this.upFlow = upFlow;</span><br><span class="line">        this.downFlow = downFlow;</span><br><span class="line">        this.upCountFlow = upCountFlow;</span><br><span class="line">        this.downCountFlow = downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getUpFlow() &#123;</span><br><span class="line">        return upFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUpFlow(Integer upFlow) &#123;</span><br><span class="line">        this.upFlow = upFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getDownFlow() &#123;</span><br><span class="line">        return downFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDownFlow(Integer downFlow) &#123;</span><br><span class="line">        this.downFlow = downFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getUpCountFlow() &#123;</span><br><span class="line">        return upCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUpCountFlow(Integer upCountFlow) &#123;</span><br><span class="line">        this.upCountFlow = upCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getDownCountFlow() &#123;</span><br><span class="line">        return downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDownCountFlow(Integer downCountFlow) &#123;</span><br><span class="line">        this.downCountFlow = downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;FlowBean&#123;&quot; +</span><br><span class="line">                &quot;upFlow=&quot; + upFlow +</span><br><span class="line">                &quot;, downFlow=&quot; + downFlow +</span><br><span class="line">                &quot;, upCountFlow=&quot; + upCountFlow +</span><br><span class="line">                &quot;, downCountFlow=&quot; + downCountFlow +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-2-定义FlowMapper类"><a href="#Step-2-定义FlowMapper类" class="headerlink" title="Step 2: 定义FlowMapper类"></a>Step 2: 定义FlowMapper类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FlowCountMapper extends Mapper&lt;LongWritable,Text,Text,FlowBean&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">       //1:拆分手机号</span><br><span class="line">        String[] split = value.toString().split(&quot;\t&quot;);</span><br><span class="line">        String phoneNum = split[1];</span><br><span class="line">        //2:获取四个流量字段</span><br><span class="line">        FlowBean flowBean = new FlowBean();</span><br><span class="line">        flowBean.setUpFlow(Integer.parseInt(split[6]));</span><br><span class="line">        flowBean.setDownFlow(Integer.parseInt(split[7]));</span><br><span class="line">        flowBean.setUpCountFlow(Integer.parseInt(split[8]));</span><br><span class="line">        flowBean.setDownCountFlow(Integer.parseInt(split[9]));</span><br><span class="line"></span><br><span class="line">        //3:将k2和v2写入上下文中</span><br><span class="line">        context.write(new Text(phoneNum), flowBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-3-定义FlowReducer类"><a href="#Step-3-定义FlowReducer类" class="headerlink" title="Step 3: 定义FlowReducer类"></a>Step 3: 定义FlowReducer类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FlowCountReducer extends Reducer&lt;Text,FlowBean,Text,FlowBean&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;FlowBean&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">       //封装新的FlowBean</span><br><span class="line">        FlowBean flowBean = new FlowBean();</span><br><span class="line">        Integer upFlow = 0;</span><br><span class="line">        Integer  downFlow = 0;</span><br><span class="line">        Integer upCountFlow = 0;</span><br><span class="line">        Integer downCountFlow = 0;</span><br><span class="line">        for (FlowBean value : values) &#123;</span><br><span class="line">            upFlow  += value.getUpFlow();</span><br><span class="line">            downFlow += value.getDownFlow();</span><br><span class="line">            upCountFlow += value.getUpCountFlow();</span><br><span class="line">            downCountFlow += value.getDownCountFlow();</span><br><span class="line">        &#125;</span><br><span class="line">        flowBean.setUpFlow(upFlow);</span><br><span class="line">        flowBean.setDownFlow(downFlow);</span><br><span class="line">        flowBean.setUpCountFlow(upCountFlow);</span><br><span class="line">        flowBean.setDownCountFlow(downCountFlow);</span><br><span class="line">        //将K3和V3写入上下文中</span><br><span class="line">        context.write(key, flowBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-4-程序main函数入口FlowMain"><a href="#Step-4-程序main函数入口FlowMain" class="headerlink" title="Step 4: 程序main函数入口FlowMain"></a>Step 4: 程序main函数入口FlowMain</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line"></span><br><span class="line">    //该方法用于指定一个job任务</span><br><span class="line">    @Override</span><br><span class="line">        public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:创建一个job任务对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;mapreduce_flowcount&quot;);</span><br><span class="line">        //如果打包运行出错，则需要加该配置</span><br><span class="line">        job.setJarByClass(JobMain.class);</span><br><span class="line">        //2:配置job任务对象(八个步骤)</span><br><span class="line"></span><br><span class="line">        //第一步:指定文件的读取方式和读取路径</span><br><span class="line">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        //TextInputFormat.addInputPath(job, new Path(&quot;hdfs://node01:8020/wordcount&quot;));</span><br><span class="line">        TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\flowcount_input&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //第二步:指定Map阶段的处理方式和数据类型</span><br><span class="line">         job.setMapperClass(FlowCountMapper.class);</span><br><span class="line">         //设置Map阶段K2的类型</span><br><span class="line">          job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        //设置Map阶段V2的类型</span><br><span class="line">          job.setMapOutputValueClass(FlowBean.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          //第三（分区），四 （排序）</span><br><span class="line">          //第五步: 规约(Combiner)</span><br><span class="line">          //第六步 分组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          //第七步：指定Reduce阶段的处理方式和数据类型</span><br><span class="line">          job.setReducerClass(FlowCountReducer.class);</span><br><span class="line">          //设置K3的类型</span><br><span class="line">           job.setOutputKeyClass(Text.class);</span><br><span class="line">          //设置V3的类型</span><br><span class="line">           job.setOutputValueClass(FlowBean.class);</span><br><span class="line"></span><br><span class="line">           //第八步: 设置输出类型</span><br><span class="line">           job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">           //设置输出的路径</span><br><span class="line">           TextOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\flowcount_out&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //等待任务结束</span><br><span class="line">           boolean bl = job.waitForCompletion(true);</span><br><span class="line"></span><br><span class="line">           return bl ? 0:1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line"></span><br><span class="line">        //启动job任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需求二-上行流量倒序排序（递减排序）"><a href="#需求二-上行流量倒序排序（递减排序）" class="headerlink" title="需求二: 上行流量倒序排序（递减排序）"></a>需求二: 上行流量倒序排序（递减排序）</h3><p>分析，以需求一的输出数据作为排序的输入数据，自定义FlowBean,以FlowBean为map输出的key，以手机号作为Map输出的value，因为MapReduce程序会对Map阶段输出的key进行排序</p>
<h5 id="Step-1-定义FlowBean实现WritableComparable实现比较排序"><a href="#Step-1-定义FlowBean实现WritableComparable实现比较排序" class="headerlink" title="Step 1: 定义FlowBean实现WritableComparable实现比较排序"></a>Step 1: 定义FlowBean实现WritableComparable实现比较排序</h5><p>Java 的 compareTo 方法说明:</p>
<ul>
<li>compareTo 方法用于将当前对象与方法的参数进行比较。</li>
<li>如果指定的数与参数相等返回 0。</li>
<li>如果指定的数小于参数返回 -1。</li>
<li>如果指定的数大于参数返回 1。</li>
</ul>
<p>例如：<code>o1.compareTo(o2);</code> 返回正数的话，当前对象（调用 compareTo 方法的对象 o1）要排在比较对象（compareTo 传参对象 o2）后面，返回负数的话，放在前面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class FlowBean implements WritableComparable&lt;FlowBean&gt; &#123;</span><br><span class="line">    private Integer upFlow;</span><br><span class="line">    private Integer  downFlow;</span><br><span class="line">    private Integer upCountFlow;</span><br><span class="line">    private Integer downCountFlow;</span><br><span class="line">    public FlowBean() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FlowBean(Integer upFlow, Integer downFlow, Integer upCountFlow, Integer downCountFlow) &#123;</span><br><span class="line">        this.upFlow = upFlow;</span><br><span class="line">        this.downFlow = downFlow;</span><br><span class="line">        this.upCountFlow = upCountFlow;</span><br><span class="line">        this.downCountFlow = downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void write(DataOutput out) throws IOException &#123;</span><br><span class="line">        out.writeInt(upFlow);</span><br><span class="line">        out.writeInt(downFlow);</span><br><span class="line">        out.writeInt(upCountFlow);</span><br><span class="line">        out.writeInt(downCountFlow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void readFields(DataInput in) throws IOException &#123;</span><br><span class="line">        upFlow = in.readInt();</span><br><span class="line">        downFlow = in.readInt();</span><br><span class="line">        upCountFlow = in.readInt();</span><br><span class="line">        downCountFlow = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getUpFlow() &#123;</span><br><span class="line">        return upFlow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUpFlow(Integer upFlow) &#123;</span><br><span class="line">        this.upFlow = upFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getDownFlow() &#123;</span><br><span class="line">        return downFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setDownFlow(Integer downFlow) &#123;</span><br><span class="line">        this.downFlow = downFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Integer getUpCountFlow() &#123;</span><br><span class="line">        return upCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUpCountFlow(Integer upCountFlow) &#123;</span><br><span class="line">        this.upCountFlow = upCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer getDownCountFlow() &#123;</span><br><span class="line">        return downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDownCountFlow(Integer downCountFlow) &#123;</span><br><span class="line">        this.downCountFlow = downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return upFlow+&quot;\t&quot;+downFlow+&quot;\t&quot;+upCountFlow+&quot;\t&quot;+downCountFlow;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(FlowBean o) &#123;</span><br><span class="line">        return this.upCountFlow &gt; o.upCountFlow ?-1:1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-2-定义FlowMapper"><a href="#Step-2-定义FlowMapper" class="headerlink" title="Step 2: 定义FlowMapper"></a>Step 2: 定义FlowMapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FlowCountSortMapper extends Mapper&lt;LongWritable,Text,FlowBean,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        FlowBean flowBean = new FlowBean();</span><br><span class="line">        String[] split = value.toString().split(&quot;\t&quot;);</span><br><span class="line"></span><br><span class="line">        //获取手机号，作为V2</span><br><span class="line">        String phoneNum = split[0];</span><br><span class="line">        //获取其他流量字段,封装flowBean，作为K2</span><br><span class="line">        flowBean.setUpFlow(Integer.parseInt(split[1]));</span><br><span class="line">        flowBean.setDownFlow(Integer.parseInt(split[2]));</span><br><span class="line">        flowBean.setUpCountFlow(Integer.parseInt(split[3]));</span><br><span class="line">        flowBean.setDownCountFlow(Integer.parseInt(split[4]));</span><br><span class="line"></span><br><span class="line">        //将K2和V2写入上下文中</span><br><span class="line">        context.write(flowBean, new Text(phoneNum));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-3-定义FlowReducer"><a href="#Step-3-定义FlowReducer" class="headerlink" title="Step 3: 定义FlowReducer"></a>Step 3: 定义FlowReducer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class FlowCountSortReducer extends Reducer&lt;FlowBean,Text,Text,FlowBean&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(FlowBean key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        for (Text value : values) &#123;</span><br><span class="line">            context.write(value, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-4-程序main函数入口"><a href="#Step-4-程序main函数入口" class="headerlink" title="Step 4: 程序main函数入口"></a>Step 4: 程序main函数入口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured  implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] strings) throws Exception &#123;</span><br><span class="line">        //创建一个任务对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;mapreduce_flowcountsort&quot;);</span><br><span class="line"></span><br><span class="line">        //打包放在集群运行时，需要做一个配置</span><br><span class="line">        job.setJarByClass(JobMain.class);</span><br><span class="line">        //第一步:设置读取文件的类: K1 和V1</span><br><span class="line">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        TextInputFormat.addInputPath(job, new Path(&quot;hdfs://node01:8020/out/flowcount_out&quot;));</span><br><span class="line"></span><br><span class="line">        //第二步：设置Mapper类</span><br><span class="line">        job.setMapperClass(FlowCountSortMapper.class);</span><br><span class="line">        //设置Map阶段的输出类型: k2 和V2的类型</span><br><span class="line">        job.setMapOutputKeyClass(FlowBean.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        //第三,四，五，六步采用默认方式(分区，排序，规约，分组)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //第七步 ：设置文的Reducer类</span><br><span class="line">        job.setReducerClass(FlowCountSortReducer.class);</span><br><span class="line">        //设置Reduce阶段的输出类型</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(FlowBean.class);</span><br><span class="line"></span><br><span class="line">        //设置Reduce的个数</span><br><span class="line"></span><br><span class="line">        //第八步:设置输出类</span><br><span class="line">        job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">        //设置输出的路径</span><br><span class="line">        TextOutputFormat.setOutputPath(job, new Path(&quot;hdfs://node01:8020/out/flowcountsort_out&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        boolean b = job.waitForCompletion(true);</span><br><span class="line">        return b?0:1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line"></span><br><span class="line">        //启动一个任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="需求三-手机号码分区"><a href="#需求三-手机号码分区" class="headerlink" title="需求三: 手机号码分区"></a>需求三: 手机号码分区</h3><p>在需求一的基础上，继续完善，将不同的手机号分到不同的数据文件的当中去，需要自定义分区来实现，这里我们自定义来模拟分区，将以下数字开头的手机号进行分开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">135 开头数据到一个分区文件</span><br><span class="line">136 开头数据到一个分区文件</span><br><span class="line">137 开头数据到一个分区文件</span><br><span class="line">其他分区</span><br></pre></td></tr></table></figure>

<h5 id="自定义分区"><a href="#自定义分区" class="headerlink" title="自定义分区"></a>自定义分区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FlowPartition extends Partitioner&lt;Text,FlowBean&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getPartition(Text text, FlowBean flowBean, int i) &#123;</span><br><span class="line">        String line = text.toString();</span><br><span class="line">        if (line.startsWith(&quot;135&quot;))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(line.startsWith(&quot;136&quot;))&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(line.startsWith(&quot;137&quot;))&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="作业运行设置"><a href="#作业运行设置" class="headerlink" title="作业运行设置"></a>作业运行设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.setPartitionerClass(FlowPartition.class);</span><br><span class="line"> job.setNumReduceTasks(4);</span><br></pre></td></tr></table></figure>

<h5 id="修改输入输出路径-并放入集群运行"><a href="#修改输入输出路径-并放入集群运行" class="headerlink" title="修改输入输出路径, 并放入集群运行"></a>修改输入输出路径, 并放入集群运行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextInputFormat.addInputPath(job,new Path(&quot;hdfs://node01:8020/partition_flow/&quot;));</span><br><span class="line">TextOutputFormat.setOutputPath(job,new Path(&quot;hdfs://node01:8020/partition_out&quot;));</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/MapReduce/" data-id="cjz2496do0003x0u5ehdhkhjk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MapReduce2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/MapReduce2/" class="article-date">
  <time datetime="2019-08-08T03:21:13.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/MapReduce2/">MapReduce2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MapReduce详解"><a href="#MapReduce详解" class="headerlink" title="MapReduce详解"></a>MapReduce详解</h1><h2 id="1-MapReduce的运行机制详解"><a href="#1-MapReduce的运行机制详解" class="headerlink" title="1 .MapReduce的运行机制详解"></a>1 .MapReduce的运行机制详解</h2><p> 全流程:</p>
<p><a href="https://manzhong.github.io/images/MapReduce/1-MapReduce%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E5%85%A8%E6%B5%81%E7%A8%8B.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/1-MapReduce%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-%E5%85%A8%E6%B5%81%E7%A8%8B.jpg" alt="img"></a></p>
<h3 id="1-1-MapTask-工作机制"><a href="#1-1-MapTask-工作机制" class="headerlink" title="1.1:MapTask 工作机制"></a>1.1:MapTask 工作机制</h3><p>简单概述：inputFile通过split被逻辑切分为多个split文件，通过Record按行读取内容给map（用户自己实现的）进行处理，数据被map处理结束之后交给OutputCollector收集器，对其结果key进行分区（默认使用hash分区），然后写入buffer，每个map task都有一个内存缓冲区，存储着map的输出结果，当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式存放到磁盘，当整个map task结束后再对磁盘中这个map task产生的所有临时文件做合并，生成最终的正式输出文件，然后等待reduce task来拉数据</p>
<h5 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h5><ol>
<li><p>读取数据组件 <strong>InputFormat</strong> (默认 TextInputFormat) 会通过 <code>getSplits</code> 方法对输入目录中文件进行逻辑切片规划得到 <code>block</code>, 有多少个 <code>block</code>就对应启动多少个 <code>MapTask</code>.</p>
</li>
<li><p>将输入文件切分为 <code>block</code> 之后, 由 <code>RecordReader</code> 对象 (默认是LineRecordReader) 进行<strong>读取</strong>, 以 <code>\n</code> 作为分隔符, 读取一行数据, 返回 <code>&lt;key，value&gt;</code>. Key 表示每行首字符偏移值, Value 表示这一行文本内容</p>
</li>
<li><p>读取 <code>block</code> 返回 <code>&lt;key,value&gt;</code>, <strong>进入用户自己继承的 Mapper 类中</strong>，执行用户重写的 map 函数, RecordReader 读取一行这里调用一次</p>
</li>
<li><p>Mapper 逻辑结束之后, 将 Mapper 的每条结果通过 <code>context.write</code> 进行collect数据收集. 在 collect 中, 会先对其进行分区处理，默认使用 <strong>HashPartitioner</strong></p>
<ul>
<li><blockquote>
<p>MapReduce 提供 <code>Partitioner</code> 接口, 它的作用就是根据 <code>Key</code> 或 <code>Value</code> 及 <code>Reducer</code> 的数量来决定当前的这对输出数据最终应该交由哪个 <code>Reduce task</code> 处理, 默认对 Key Hash 后再以 Reducer 数量取模. 默认的取模方式只是为了平均 Reducer 的处理能力, 如果用户自己对 Partitioner 有需求, 可以订制并设置到 Job 上</p>
</blockquote>
</li>
</ul>
</li>
<li><p>接下来, 会将数据写入内存, 内存中这片区域叫做环形缓冲区, 缓冲区的作用是批量收集 Mapper 结果, 减少磁盘 IO 的影响. 我们的 <strong>Key/Value 对以及 Partition 的结果都会被写入缓冲区</strong>. 当然, 写入之前，Key 与 Value 值都会被序列化成字节数组</p>
<ul>
<li><blockquote>
<p>环形缓冲区其实是一个数组, 数组中存放着 Key, Value 的序列化数据和 Key, Value 的元数据信息, 包括 Partition, Key 的起始位置, Value 的起始位置以及 Value 的长度. 环形结构是一个抽象概念</p>
</blockquote>
</li>
<li><blockquote>
<p>缓冲区是有大小限制, 默认是 100MB. 当 Mapper 的输出结果很多时, 就可能会撑爆内存, 所以需要在一定条件下将缓冲区中的数据临时写入磁盘, 然后重新利用这块缓冲区. 这个从内存往磁盘写数据的过程被称为 Spill, 中文可译为溢写. 这个溢写是由单独线程来完成, 不影响往缓冲区写 Mapper 结果的线程. 溢写线程启动时不应该阻止 Mapper 的结果输出, 所以整个缓冲区有个溢写的比例 <code>spill.percent</code>. 这个比例默认是 0.8, 也就是当缓冲区的数据已经达到阈值 <code>buffer size * spill percent = 100MB * 0.8 = 80MB</code>, 溢写线程启动, 锁定这 80MB 的内存, 执行溢写过程. Mapper 的输出结果还可以往剩下的 20MB 内存中写, 互不影响</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当溢写线程启动后, 需要<strong>对这 80MB 空间内的 Key 做排序 (Sort)</strong>. 排序是 MapReduce 模型默认的行为, 这里的排序也是对序列化的字节做的排序</p>
<ul>
<li><blockquote>
<p>如果 Job 设置过 Combiner, 那么现在就是使用 Combiner 的时候了. 将有相同 Key 的 Key/Value 对的 Value 加起来, 减少溢写到磁盘的数据量. Combiner 会优化 MapReduce 的中间结果, 所以它在整个模型中会多次使用</p>
</blockquote>
</li>
<li><blockquote>
<p>那哪些场景才能使用 Combiner 呢? 从这里分析, Combiner 的输出是 Reducer 的输入, Combiner 绝不能改变最终的计算结果. Combiner 只应该用于那种 Reduce 的输入 Key/Value 与输出 Key/Value 类型完全一致, 且不影响最终结果的场景. 比如累加, 最大值等. Combiner 的使用一定得慎重, 如果用好, 它对 Job 执行效率有帮助, 反之会影响 Reducer 的最终结果</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>合并溢写文件</strong>, 每次溢写会在磁盘上生成一个临时文件 (写之前判断是否有 Combiner), 如果 Mapper 的输出结果真的很大, 有多次这样的溢写发生, 磁盘上相应的就会有多个临时文件存在. 当整个数据处理结束之后开始对磁盘中的临时文件进行 Merge 合并, 因为最终的文件只有一个, 写入磁盘, 并且为这个文件提供了一个索引文件, 以记录每个reduce对应数据的偏移量</p>
</li>
</ol>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">默认值</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>mapreduce.task.io.sort.mb</code></td>
<td align="left">100</td>
<td align="left">设置环型缓冲区的内存值大小</td>
</tr>
<tr>
<td align="left"><code>mapreduce.map.sort.spill.percent</code></td>
<td align="left">0.8</td>
<td align="left">设置溢写的比例</td>
</tr>
<tr>
<td align="left"><code>mapreduce.cluster.local.dir</code></td>
<td align="left"><code>${hadoop.tmp.dir}/mapred/local</code></td>
<td align="left">溢写数据目录</td>
</tr>
<tr>
<td align="left"><code>mapreduce.task.io.sort.factor</code></td>
<td align="left">10</td>
<td align="left">设置一次合并多少个溢写文件</td>
</tr>
</tbody></table>
<h3 id="1-2-ReduceTask-工作机制"><a href="#1-2-ReduceTask-工作机制" class="headerlink" title="1.2 :ReduceTask 工作机制"></a>1.2 :ReduceTask 工作机制</h3><p>Reduce 大致分为 copy、sort、reduce 三个阶段，重点在前两个阶段。copy 阶段包含一个 eventFetcher 来获取已完成的 map 列表，由 Fetcher 线程去 copy 数据，在此过程中会启动两个 merge 线程，分别为 inMemoryMerger 和 onDiskMerger，分别将内存中的数据 merge 到磁盘和将磁盘中的数据进行 merge。待数据 copy 完成之后，copy 阶段就完成了，开始进行 sort 阶段，sort 阶段主要是执行 finalMerge 操作，纯粹的 sort 阶段，完成之后就是 reduce 阶段，调用用户定义的 reduce 函数进行处理</p>
<h5 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤"></a>详细步骤</h5><ol>
<li><strong>Copy阶段</strong>，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求maptask获取属于自己的文件。</li>
<li><strong>Merge阶段</strong>。这里的merge如map端的merge动作，只是数组中存放的是不同map端copy来的数值。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活。merge有三种形式：内存到内存；内存到磁盘；磁盘到磁盘。默认情况下第一种形式不启用。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。与map 端类似，这也是溢写的过程，这个过程中如果你设置有Combiner，也是会启用的，然后在磁盘中生成了众多的溢写文件。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的文件。</li>
<li><strong>合并排序</strong>。把分散的数据合并成一个大的数据后，还会再对合并后的数据排序。</li>
<li><strong>对排序后的键值对调用reduce方法</strong>，键相等的键值对调用一次reduce方法，每次调用会产生零个或者多个键值对，最后把这些输出的键值对写入到HDFS文件中。</li>
</ol>
<h3 id="1-3-Shuffle-过程"><a href="#1-3-Shuffle-过程" class="headerlink" title="1.3:Shuffle 过程"></a>1.3:Shuffle 过程</h3><p>map 阶段处理的数据如何传递给 reduce 阶段，是 MapReduce 框架中最关键的一个流程，这个流程就叫 shuffle<br>shuffle: 洗牌、发牌 ——（核心机制：数据分区，排序，分组，规约，合并等过程）</p>
<p>shuffle 是 Mapreduce 的核心，它分布在 Mapreduce 的 map 阶段和 reduce 阶段。一般把从 Map 产生输出开始到 Reduce 取得数据作为输入之前的过程称作 shuffle。</p>
<ol>
<li><strong>Collect阶段</strong>：将 MapTask 的结果输出到默认大小为 100M 的环形缓冲区，保存的是 key/value，Partition 分区信息等。</li>
<li><strong>Spill阶段</strong>：当内存中的数据量达到一定的阀值的时候，就会将数据写入本地磁盘，在将数据写入磁盘之前需要对数据进行一次排序的操作，如果配置了 combiner，还会将有相同分区号和 key 的数据进行排序。</li>
<li><strong>Merge阶段</strong>：把所有溢出的临时文件进行一次合并操作，以确保一个 MapTask 最终只产生一个中间数据文件。</li>
<li><strong>Copy阶段</strong>：ReduceTask 启动 Fetcher 线程到已经完成 MapTask 的节点上复制一份属于自己的数据，这些数据默认会保存在内存的缓冲区中，当内存的缓冲区达到一定的阀值的时候，就会将数据写到磁盘之上。</li>
<li><strong>Merge阶段</strong>：在 ReduceTask 远程复制数据的同时，会在后台开启两个线程对内存到本地的数据文件进行合并操作。</li>
<li><strong>Sort阶段</strong>：在对数据进行合并的同时，会进行排序操作，由于 MapTask 阶段已经对数据进行了局部的排序，ReduceTask 只需保证 Copy 的数据的最终整体有效性即可。<br>Shuffle 中的缓冲区大小会影响到 mapreduce 程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快<br>缓冲区的大小可以通过参数调整, 参数：mapreduce.task.io.sort.mb 默认100M</li>
</ol>
<h2 id="2-案例-Reduce-端实现-JOIN"><a href="#2-案例-Reduce-端实现-JOIN" class="headerlink" title="2. 案例: Reduce 端实现 JOIN"></a>2. 案例: Reduce 端实现 JOIN</h2><p><a href="https://manzhong.github.io/images/MapReduce/2-Reduce%E7%AB%AFjoin%E6%93%8D%E4%BD%9C.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/2-Reduce%E7%AB%AFjoin%E6%93%8D%E4%BD%9C.bmp" alt="img"></a></p>
<p><a href="https://manzhong.github.io/images/MapReduce/3-Reduce%E7%AB%AFjoin%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/3-Reduce%E7%AB%AFjoin%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98.bmp" alt="img"></a></p>
<h3 id="2-1-需求"><a href="#2-1-需求" class="headerlink" title="2.1. 需求"></a>2.1. 需求</h3><blockquote>
<p>假如数据量巨大，两表的数据是以文件的形式存储在 HDFS 中, 需要用 MapReduce 程序来实现以下 SQL 查询运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; select  a.id,a.date,b.name,b.category_id,b.price from t_order a left join t_product b on a.pid = b.id</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="商品表"><a href="#商品表" class="headerlink" title="商品表"></a>商品表</h5><table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">pname</th>
<th align="left">category_id</th>
<th align="left">price</th>
</tr>
</thead>
<tbody><tr>
<td align="left">P0001</td>
<td align="left">小米5</td>
<td align="left">1000</td>
<td align="left">2000</td>
</tr>
<tr>
<td align="left">P0002</td>
<td align="left">锤子T1</td>
<td align="left">1000</td>
<td align="left">3000</td>
</tr>
</tbody></table>
<h5 id="订单数据表"><a href="#订单数据表" class="headerlink" title="订单数据表"></a>订单数据表</h5><table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">date</th>
<th align="left">pid</th>
<th align="left">amount</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1001</td>
<td align="left">20150710</td>
<td align="left">P0001</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">1002</td>
<td align="left">20150710</td>
<td align="left">P0002</td>
<td align="left">3</td>
</tr>
</tbody></table>
<h3 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h3><p>通过将关联的条件作为map输出的key，将两表满足join条件的数据并携带数据所来源的文件信息，发往同一个reduce task，在reduce中进行数据的串联</p>
<h4 id="Step-1-定义-Mapper"><a href="#Step-1-定义-Mapper" class="headerlink" title="Step 1: 定义 Mapper"></a>Step 1: 定义 Mapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ReduceJoinMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:判断数据来自哪个文件</span><br><span class="line">        FileSplit fileSplit = (FileSplit) context.getInputSplit();</span><br><span class="line">        String fileName = fileSplit.getPath().getName();</span><br><span class="line">        if(fileName.equals(&quot;product.txt&quot;))&#123;</span><br><span class="line">            //数据来自商品表</span><br><span class="line">            //2:将K1和V1转为K2和V2,写入上下文中</span><br><span class="line">            String[] split = value.toString().split(&quot;,&quot;);</span><br><span class="line">            String productId = split[0];</span><br><span class="line"></span><br><span class="line">            context.write(new Text(productId), value);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //数据来自订单表</span><br><span class="line">            //2:将K1和V1转为K2和V2,写入上下文中</span><br><span class="line">            String[] split = value.toString().split(&quot;,&quot;);</span><br><span class="line">            String productId = split[2];</span><br><span class="line"></span><br><span class="line">            context.write(new Text(productId), value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step-2-定义-Reducer"><a href="#Step-2-定义-Reducer" class="headerlink" title="Step 2: 定义 Reducer"></a>Step 2: 定义 Reducer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ReduceJoinMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:判断数据来自哪个文件</span><br><span class="line"></span><br><span class="line">        FileSplit fileSplit = (FileSplit) context.getInputSplit();</span><br><span class="line">        String fileName = fileSplit.getPath().getName();</span><br><span class="line">        if(fileName.equals(&quot;product.txt&quot;))&#123;</span><br><span class="line">            //数据来自商品表</span><br><span class="line">            //2:将K1和V1转为K2和V2,写入上下文中</span><br><span class="line">            String[] split = value.toString().split(&quot;,&quot;);</span><br><span class="line">            String productId = split[0];</span><br><span class="line"></span><br><span class="line">            context.write(new Text(productId), value);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //数据来自订单表</span><br><span class="line">            //2:将K1和V1转为K2和V2,写入上下文中</span><br><span class="line">            String[] split = value.toString().split(&quot;,&quot;);</span><br><span class="line">            String productId = split[2];</span><br><span class="line"></span><br><span class="line">            context.write(new Text(productId), value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Step-3-定义主类"><a href="#Step-3-定义主类" class="headerlink" title="Step 3: 定义主类"></a>Step 3: 定义主类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ReduceJoinReducer extends Reducer&lt;Text,Text,Text,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">       //1:遍历集合,获取V3 (first +second)</span><br><span class="line">        String first = &quot;&quot;;</span><br><span class="line">        String second = &quot;&quot;;</span><br><span class="line">        for (Text value : values) &#123;</span><br><span class="line">            if(value.toString().startsWith(&quot;p&quot;))&#123;</span><br><span class="line">                first = value.toString();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                second += value.toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //2:将K3和V3写入上下文中</span><br><span class="line">        context.write(key, new Text(first+&quot;\t&quot;+second));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-案例-Map端实现-JOIN"><a href="#3-案例-Map端实现-JOIN" class="headerlink" title="3. 案例: Map端实现 JOIN"></a>3. 案例: Map端实现 JOIN</h2><p><a href="https://manzhong.github.io/images/MapReduce/4-Map%E7%AB%AFjoin%E6%93%8D%E4%BD%9C.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/4-Map%E7%AB%AFjoin%E6%93%8D%E4%BD%9C.bmp" alt="img"></a></p>
<h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p> 适用于关联表中有小表的情形.</p>
<p> 使用分布式缓存,可以将小表分发到所有的map节点，这样，map节点就可以在本地对自己所读到的大表数据进行join并输出最终结果，可以大大提高join操作的并发度，加快处理速度</p>
<h4 id="3-2-实现步骤"><a href="#3-2-实现步骤" class="headerlink" title="3.2 实现步骤"></a>3.2 实现步骤</h4><p>先在mapper类中预先定义好小表，进行join</p>
<p>引入实际场景中的解决方案：一次加载数据库或者用</p>
<h5 id="Step-1：定义Mapper"><a href="#Step-1：定义Mapper" class="headerlink" title="Step 1：定义Mapper"></a>Step 1：定义Mapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class MapJoinMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">    private HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    //第一件事情:将分布式缓存的小表数据读取到本地Map集合(只需要做一次)</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void setup(Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:获取分布式缓存文件列表</span><br><span class="line">        URI[] cacheFiles =  context.getCacheFiles();</span><br><span class="line"></span><br><span class="line">        //2:获取指定的分布式缓存文件的文件系统(FileSystem)</span><br><span class="line">        FileSystem fileSystem = FileSystem.get(cacheFiles[0], context.getConfiguration());</span><br><span class="line"></span><br><span class="line">        //3:获取文件的输入流</span><br><span class="line">        FSDataInputStream inputStream = fileSystem.open(new Path(cacheFiles[0]));</span><br><span class="line"></span><br><span class="line">        //4:读取文件内容, 并将数据存入Map集合</span><br><span class="line">           //4.1 将字节输入流转为字符缓冲流FSDataInputStream ---&gt;BufferedReader</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">           //4.2 读取小表文件内容,以行位单位,并将读取的数据存入map集合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String line = null;</span><br><span class="line">        while((line = bufferedReader.readLine()) != null)&#123;</span><br><span class="line">            String[] split = line.split(&quot;,&quot;);</span><br><span class="line"></span><br><span class="line">            map.put(split[0], line);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //5:关闭流</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        fileSystem.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二件事情:对大表的处理业务逻辑,而且要实现大表和小表的join操作</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            //1:从行文本数据中获取商品的id: p0001 , p0002  得到了K2</span><br><span class="line">            String[] split = value.toString().split(&quot;,&quot;);</span><br><span class="line">            String productId = split[2];  //K2</span><br><span class="line"></span><br><span class="line">            //2:在Map集合中,将商品的id作为键,获取值(商品的行文本数据) ,将value和值拼接,得到V2</span><br><span class="line">            String productLine = map.get(productId);</span><br><span class="line">            String valueLine = productLine+&quot;\t&quot;+value.toString(); //V2</span><br><span class="line">            //3:将K2和V2写入上下文中</span><br><span class="line">            context.write(new Text(productId), new Text(valueLine));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Step-2：定义主类"><a href="#Step-2：定义主类" class="headerlink" title="Step 2：定义主类"></a>Step 2：定义主类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain  extends Configured implements Tool&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:获取job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;map_join_job&quot;);</span><br><span class="line"></span><br><span class="line">        //2:设置job对象(将小表放在分布式缓存中)</span><br><span class="line">            //将小表放在分布式缓存中</span><br><span class="line">           // DistributedCache.addCacheFile(new URI(&quot;hdfs://node01:8020/cache_file/product.txt&quot;), super.getConf());</span><br><span class="line">           job.addCacheFile(new URI(&quot;hdfs://node01:8020/cache_file/product.txt&quot;));</span><br><span class="line"></span><br><span class="line">           //第一步:设置输入类和输入的路径</span><br><span class="line">            job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">            TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\map_join_input&quot;));</span><br><span class="line">            //第二步:设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(MapJoinMapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(Text.class);</span><br><span class="line">            job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">            //第八步:设置输出类和输出路径</span><br><span class="line">            job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">            TextOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\map_join_out&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3:等待任务结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line">        return bl ? 0 :1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        //启动job任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-案例-求共同好友"><a href="#4-案例-求共同好友" class="headerlink" title="4. 案例:求共同好友"></a>4. 案例:求共同好友</h2><p>分析图:</p>
<p><a href="https://manzhong.github.io/images/MapReduce/5-%E6%B1%82%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/5-%E6%B1%82%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B.bmp" alt="img"></a></p>
<h3 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4.1 需求分析"></a>4.1 需求分析</h3><p>以下是qq的好友列表数据，冒号前是一个用户，冒号后是该用户的所有好友（数据中的好友关系是单向的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A:B,C,D,F,E,O</span><br><span class="line">B:A,C,E,K</span><br><span class="line">C:A,B,D,E,I </span><br><span class="line">D:A,E,F,L</span><br><span class="line">E:B,C,D,M,L</span><br><span class="line">F:A,B,C,D,E,O,M</span><br><span class="line">G:A,C,D,E,F</span><br><span class="line">H:A,C,D,E,O</span><br><span class="line">I:A,O</span><br><span class="line">J:B,O</span><br><span class="line">K:A,C,D</span><br><span class="line">L:D,E,F</span><br><span class="line">M:E,F,G</span><br><span class="line">O:A,H,I,J</span><br></pre></td></tr></table></figure>

<p>求出哪些人两两之间有共同好友，及他俩的共同好友都有谁？</p>
<h3 id="4-2-实现步骤"><a href="#4-2-实现步骤" class="headerlink" title="4.2 实现步骤"></a>4.2 实现步骤</h3><h5 id="第一步：代码实现"><a href="#第一步：代码实现" class="headerlink" title="第一步：代码实现"></a>第一步：代码实现</h5><p><strong>Mapper类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Step1Mapper extends Mapper&lt;LongWritable,Text,Text,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">         //1:以冒号拆分行文本数据: 冒号左边就是V2</span><br><span class="line">        String[] split = value.toString().split(&quot;:&quot;);</span><br><span class="line">        String userStr = split[0];</span><br><span class="line"></span><br><span class="line">        //2:将冒号右边的字符串以逗号拆分,每个成员就是K2</span><br><span class="line">        String[] split1 = split[1].split(&quot;,&quot;);</span><br><span class="line">        for (String s : split1) &#123;</span><br><span class="line">            //3:将K2和v2写入上下文中</span><br><span class="line">            context.write(new Text(s), new Text(userStr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Reducer类:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Step1Reducer extends Reducer&lt;Text,Text,Text,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:遍历集合,并将每一个元素拼接,得到K3</span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line"></span><br><span class="line">        for (Text value : values) &#123;</span><br><span class="line">            buffer.append(value.toString()).append(&quot;-&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //2:K2就是V3</span><br><span class="line">        //3:将K3和V3写入上下文中</span><br><span class="line">        context.write(new Text(buffer.toString()), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JobMain:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:获取Job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;common_friends_step1_job&quot;);</span><br><span class="line"></span><br><span class="line">        //2:设置job任务</span><br><span class="line">            //第一步:设置输入类和输入路径</span><br><span class="line">            job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">            TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\common_friends_step1_input&quot;));</span><br><span class="line"></span><br><span class="line">            //第二步:设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(Step1Mapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(Text.class);</span><br><span class="line">            job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">            //第三,四,五,六</span><br><span class="line"></span><br><span class="line">            //第七步:设置Reducer类和数据类型</span><br><span class="line">            job.setReducerClass(Step1Reducer.class);</span><br><span class="line">            job.setOutputKeyClass(Text.class);</span><br><span class="line">            job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">            //第八步:设置输出类和输出的路径</span><br><span class="line">            job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">            TextOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\common_friends_step1_out&quot;));</span><br><span class="line"></span><br><span class="line">        //3:等待job任务结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return bl ? 0: 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line"></span><br><span class="line">        //启动job任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line"></span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第二步：代码实现"><a href="#第二步：代码实现" class="headerlink" title="第二步：代码实现"></a>第二步：代码实现</h5><p><strong>Mapper类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Step2Mapper extends Mapper&lt;LongWritable,Text,Text,Text&gt; &#123;</span><br><span class="line">    /*</span><br><span class="line">     K1           V1</span><br><span class="line"></span><br><span class="line">     0            A-F-C-J-E-	B</span><br><span class="line">    ----------------------------------</span><br><span class="line"></span><br><span class="line">     K2             V2</span><br><span class="line">     A-C            B</span><br><span class="line">     A-E            B</span><br><span class="line">     A-F            B</span><br><span class="line">     C-E            B</span><br><span class="line"></span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:拆分行文本数据,结果的第二部分可以得到V2</span><br><span class="line">        String[] split = value.toString().split(&quot;\t&quot;);</span><br><span class="line">        String   friendStr =split[1];</span><br><span class="line"></span><br><span class="line">        //2:继续以&apos;-&apos;为分隔符拆分行文本数据第一部分,得到数组</span><br><span class="line">        String[] userArray = split[0].split(&quot;-&quot;);</span><br><span class="line"></span><br><span class="line">        //3:对数组做一个排序</span><br><span class="line">        Arrays.sort(userArray);</span><br><span class="line"></span><br><span class="line">        //4:对数组中的元素进行两两组合,得到K2</span><br><span class="line">        /*</span><br><span class="line">          A-E-C -----&gt;  A  C  E</span><br><span class="line"></span><br><span class="line">          A  C  E</span><br><span class="line">            A  C  E</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        for (int i = 0; i &lt;userArray.length -1 ; i++) &#123;</span><br><span class="line">            for (int j = i+1; j  &lt; userArray.length ; j++) &#123;</span><br><span class="line">                //5:将K2和V2写入上下文中</span><br><span class="line">                context.write(new Text(userArray[i] +&quot;-&quot;+userArray[j]), new Text(friendStr));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Reducer类:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Step2Reducer extends Reducer&lt;Text,Text,Text,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:原来的K2就是K3</span><br><span class="line">        //2:将集合进行遍历,将集合中的元素拼接,得到V3</span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line">        for (Text value : values) &#123;</span><br><span class="line">            buffer.append(value.toString()).append(&quot;-&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //3:将K3和V3写入上下文中</span><br><span class="line">        context.write(key, new Text(buffer.toString()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JobMain:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:获取Job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;common_friends_step2_job&quot;);</span><br><span class="line"></span><br><span class="line">        //2:设置job任务</span><br><span class="line">            //第一步:设置输入类和输入路径</span><br><span class="line">            job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">            TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\out\\common_friends_step1_out&quot;));</span><br><span class="line"></span><br><span class="line">            //第二步:设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(Step2Mapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(Text.class);</span><br><span class="line">            job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">            //第三,四,五,六</span><br><span class="line"></span><br><span class="line">            //第七步:设置Reducer类和数据类型</span><br><span class="line">            job.setReducerClass(Step2Reducer.class);</span><br><span class="line">            job.setOutputKeyClass(Text.class);</span><br><span class="line">            job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">            //第八步:设置输出类和输出的路径</span><br><span class="line">            job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">            TextOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\common_friends_step2_out&quot;));</span><br><span class="line"></span><br><span class="line">        //3:等待job任务结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line">        return bl ? 0: 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        //启动job任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-自定义InputFormat合并小文件"><a href="#1-自定义InputFormat合并小文件" class="headerlink" title="1. 自定义InputFormat合并小文件"></a>1. 自定义InputFormat合并小文件</h2><p><a href="https://manzhong.github.io/images/MapReduce/1-%E8%87%AA%E5%AE%9A%E4%B9%89InputFormat.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/1-%E8%87%AA%E5%AE%9A%E4%B9%89InputFormat.bmp" alt="img"></a></p>
<h3 id="1-1-需求"><a href="#1-1-需求" class="headerlink" title="1.1 需求"></a><strong>1.1 需求</strong></h3><p>无论hdfs还是mapreduce，对于小文件都有损效率，实践中，又难免面临处理大量小文件的场景，此时，就需要有相应解决方案</p>
<h3 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a><strong>1.2 分析</strong></h3><p>小文件的优化无非以下几种方式：</p>
<p>1、 在数据采集的时候，就将小文件或小批数据合成大文件再上传HDFS</p>
<p>2、 在业务处理之前，在HDFS上使用mapreduce程序对小文件进行合并</p>
<p>3、 在mapreduce处理时，可采用combineInputFormat提高效率</p>
<h3 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a><strong>1.3 实现</strong></h3><p>本节实现的是上述第二种方式</p>
<p>程序的核心机制：</p>
<p>自定义一个InputFormat</p>
<p>改写RecordReader，实现一次读取一个完整文件封装为KV</p>
<p>在输出时使用SequenceFileOutPutFormat输出合并文件</p>
<p>代码如下：</p>
<h4 id="自定义InputFromat"><a href="#自定义InputFromat" class="headerlink" title="自定义InputFromat"></a><strong>自定义InputFromat</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyInputFormat extends FileInputFormat&lt;NullWritable,BytesWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public RecordReader&lt;NullWritable, BytesWritable&gt; createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:创建自定义RecordReader对象</span><br><span class="line">        MyRecordReader myRecordReader = new MyRecordReader();</span><br><span class="line">        //2:将inputSplit和context对象传给MyRecordReader</span><br><span class="line">        myRecordReader.initialize(inputSplit, taskAttemptContext);</span><br><span class="line">        return myRecordReader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     设置文件是否可以被切割</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isSplitable(JobContext context, Path filename) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义RecordReader"><a href="#自定义RecordReader" class="headerlink" title="自定义RecordReader"></a><strong>自定义</strong>RecordReader</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecordReader extends RecordReader&lt;NullWritable,BytesWritable&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Configuration configuration = null;</span><br><span class="line">    private  FileSplit fileSplit = null;</span><br><span class="line">    private boolean processed = false;</span><br><span class="line">    private BytesWritable bytesWritable = new BytesWritable();</span><br><span class="line">    private  FileSystem fileSystem = null;</span><br><span class="line">    private  FSDataInputStream inputStream = null;</span><br><span class="line">    //进行初始化工作</span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line">        //获取文件的切片</span><br><span class="line">          fileSplit= (FileSplit)inputSplit;</span><br><span class="line"></span><br><span class="line">        //获取Configuration对象</span><br><span class="line">         configuration = taskAttemptContext.getConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //该方法用于获取K1和V1</span><br><span class="line">    /*</span><br><span class="line">     K1: NullWritable</span><br><span class="line">     V1: BytesWritable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean nextKeyValue() throws IOException, InterruptedException &#123;</span><br><span class="line">        if(!processed)&#123;</span><br><span class="line">            //1:获取源文件的字节输入流</span><br><span class="line">            //1.1 获取源文件的文件系统 (FileSystem)</span><br><span class="line">             fileSystem = FileSystem.get(configuration);</span><br><span class="line">            //1.2 通过FileSystem获取文件字节输入流</span><br><span class="line">             inputStream = fileSystem.open(fileSplit.getPath());</span><br><span class="line"></span><br><span class="line">            //2:读取源文件数据到普通的字节数组(byte[])</span><br><span class="line">            byte[] bytes = new byte[(int) fileSplit.getLength()];</span><br><span class="line">            IOUtils.readFully(inputStream, bytes, 0, (int)fileSplit.getLength());</span><br><span class="line"></span><br><span class="line">            //3:将字节数组中数据封装到BytesWritable ,得到v1</span><br><span class="line"></span><br><span class="line">            bytesWritable.set(bytes, 0, (int)fileSplit.getLength());</span><br><span class="line"></span><br><span class="line">            processed = true;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回K1</span><br><span class="line">    @Override</span><br><span class="line">    public NullWritable getCurrentKey() throws IOException, InterruptedException &#123;</span><br><span class="line">        return NullWritable.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回V1</span><br><span class="line">    @Override</span><br><span class="line">    public BytesWritable getCurrentValue() throws IOException, InterruptedException &#123;</span><br><span class="line">        return bytesWritable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取文件读取的进度</span><br><span class="line">    @Override</span><br><span class="line">    public float getProgress() throws IOException, InterruptedException &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //进行资源释放</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws IOException &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">        fileSystem.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mapper类"><a href="#Mapper类" class="headerlink" title="Mapper类:"></a>Mapper类:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SequenceFileMapper extends Mapper&lt;NullWritable,BytesWritable,Text,BytesWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(NullWritable key, BytesWritable value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:获取文件的名字,作为K2</span><br><span class="line">        FileSplit fileSplit = (FileSplit) context.getInputSplit();</span><br><span class="line">        String fileName = fileSplit.getPath().getName();</span><br><span class="line"></span><br><span class="line">        //2:将K2和V2写入上下文中</span><br><span class="line">        context.write(new Text(fileName), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主类"><a href="#主类" class="headerlink" title="主类:"></a>主类:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:获取job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;sequence_file_job&quot;);</span><br><span class="line"></span><br><span class="line">        //2:设置job任务</span><br><span class="line">            //第一步:设置输入类和输入的路径</span><br><span class="line">            job.setInputFormatClass(MyInputFormat.class);</span><br><span class="line">            MyInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\myInputformat_input&quot;));</span><br><span class="line"></span><br><span class="line">            //第二步:设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(SequenceFileMapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(Text.class);</span><br><span class="line">            job.setMapOutputValueClass(BytesWritable.class);</span><br><span class="line"></span><br><span class="line">            //第七步: 不需要设置Reducer类,但是必须设置数据类型</span><br><span class="line">            job.setOutputKeyClass(Text.class);</span><br><span class="line">            job.setOutputValueClass(BytesWritable.class);</span><br><span class="line"></span><br><span class="line">            //第八步:设置输出类和输出的路径</span><br><span class="line">            job.setOutputFormatClass(SequenceFileOutputFormat.class);</span><br><span class="line">            SequenceFileOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\myinputformat_out&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3:等待job任务执行结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line">        return bl ? 0 : 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line"></span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line"></span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-自定义outputFormat"><a href="#2-自定义outputFormat" class="headerlink" title="2. 自定义outputFormat"></a>2. 自定义outputFormat</h2><p><a href="https://manzhong.github.io/images/MapReduce/2-%E8%87%AA%E5%AE%9A%E4%B9%89OutputFormat.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/2-%E8%87%AA%E5%AE%9A%E4%B9%89OutputFormat.bmp" alt="img"></a></p>
<h3 id="2-1-需求-1"><a href="#2-1-需求-1" class="headerlink" title="2.1 需求"></a><strong>2.1</strong> <strong>需求</strong></h3><p>现在有一些订单的评论数据，需求，将订单的好评与差评进行区分开来，将最终的数据分开到不同的文件夹下面去，数据内容参见资料文件夹，其中数据第九个字段表示好评，中评，差评。0：好评，1：中评，2：差评</p>
<h3 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a><strong>2.2 分析</strong></h3><p>程序的关键点是要在一个mapreduce程序中根据数据的不同输出两类结果到不同目录，这类灵活的输出需求可以通过自定义outputformat来实现</p>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a><strong>2.3 实现</strong></h3><p>实现要点：</p>
<p>1、 在mapreduce中访问外部资源</p>
<p>2、 自定义outputformat，改写其中的recordwriter，改写具体输出数据的方法write()</p>
<h4 id="第一步：自定义MyOutputFormat"><a href="#第一步：自定义MyOutputFormat" class="headerlink" title="第一步：自定义MyOutputFormat"></a><strong>第一步</strong>：自定义MyOutputFormat</h4><p><strong>MyOutputFormat类:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyOutputFormat extends FileOutputFormat&lt;Text,NullWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public RecordWriter&lt;Text, NullWritable&gt; getRecordWriter(TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:获取目标文件的输出流(两个)</span><br><span class="line">        FileSystem fileSystem = FileSystem.get(taskAttemptContext.getConfiguration());</span><br><span class="line">        FSDataOutputStream goodCommentsOutputStream = fileSystem.create(new Path(&quot;file:///D:\\out\\good_comments\\good_comments.txt&quot;));</span><br><span class="line">        FSDataOutputStream badCommentsOutputStream = fileSystem.create(new Path(&quot;file:///D:\\out\\bad_comments\\bad_comments.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2:将输出流传给MyRecordWriter</span><br><span class="line">        MyRecordWriter myRecordWriter = new MyRecordWriter(goodCommentsOutputStream,badCommentsOutputStream);</span><br><span class="line"></span><br><span class="line">        return myRecordWriter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MyRecordReader类:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecordWriter extends RecordWriter&lt;Text,NullWritable&gt; &#123;</span><br><span class="line">    private FSDataOutputStream goodCommentsOutputStream;</span><br><span class="line">    private FSDataOutputStream badCommentsOutputStream;</span><br><span class="line"></span><br><span class="line">    public MyRecordWriter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyRecordWriter(FSDataOutputStream goodCommentsOutputStream, FSDataOutputStream badCommentsOutputStream) &#123;</span><br><span class="line">        this.goodCommentsOutputStream = goodCommentsOutputStream;</span><br><span class="line">        this.badCommentsOutputStream = badCommentsOutputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param text  行文本内容</span><br><span class="line">     * @param nullWritable</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void write(Text text, NullWritable nullWritable) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:从行文本数据中获取第9个字段</span><br><span class="line">        String[] split = text.toString().split(&quot;\t&quot;);</span><br><span class="line">        String numStr = split[9];</span><br><span class="line"></span><br><span class="line">        //2:根据字段的值,判断评论的类型,然后将对应的数据写入不同的文件夹文件中</span><br><span class="line">        if(Integer.parseInt(numStr) &lt;= 1)&#123;</span><br><span class="line">            //好评或者中评</span><br><span class="line">            goodCommentsOutputStream.write(text.toString().getBytes());</span><br><span class="line">            goodCommentsOutputStream.write(&quot;\r\n&quot;.getBytes());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //差评</span><br><span class="line">            badCommentsOutputStream.write(text.toString().getBytes());</span><br><span class="line">            badCommentsOutputStream.write(&quot;\r\n&quot;.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close(TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException &#123;</span><br><span class="line">        IOUtils.closeStream(goodCommentsOutputStream);</span><br><span class="line">        IOUtils.closeStream(badCommentsOutputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二步：自定义Mapper类"><a href="#第二步：自定义Mapper类" class="headerlink" title="第二步：自定义Mapper类"></a><strong>第二步</strong>：自定义Mapper类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyOutputFormatMapper extends Mapper&lt;LongWritable,Text,Text,NullWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        context.write(value, NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步-主类JobMain"><a href="#第三步-主类JobMain" class="headerlink" title="第三步:主类JobMain"></a>第三步:主类JobMain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:获取job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;myoutputformat_job&quot;);</span><br><span class="line"></span><br><span class="line">        //2:设置job任务</span><br><span class="line">            //第一步:设置输入类和输入的路径</span><br><span class="line">            job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">            TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\myoutputformat_input&quot;));</span><br><span class="line"></span><br><span class="line">            //第二步:设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(MyOutputFormatMapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(Text.class);</span><br><span class="line">            job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line">            //第八步:设置输出类和输出的路径</span><br><span class="line">            job.setOutputFormatClass(MyOutputFormat.class);</span><br><span class="line">            MyOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\myoutputformat_out&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3:等待任务结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line">        return bl ? 0 : 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-自定义分组求取topN"><a href="#3-自定义分组求取topN" class="headerlink" title="3. 自定义分组求取topN"></a>3. 自定义分组求取topN</h2><p><a href="https://manzhong.github.io/images/MapReduce/3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E6%B1%82TopN.bmp" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/MapReduce/3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E6%B1%82TopN.bmp" alt="img"></a></p>
<p>分组是mapreduce当中reduce端的一个功能组件，主要的作用是决定哪些数据作为一组，调用一次reduce的逻辑，默认是每个不同的key，作为多个不同的组，每个组调用一次reduce逻辑，我们可以自定义分组实现不同的key作为同一个组，调用一次reduce逻辑</p>
<h3 id="3-1-需求"><a href="#3-1-需求" class="headerlink" title="3.1 需求"></a><strong>3.1 需求</strong></h3><p>有如下订单数据</p>
<table>
<thead>
<tr>
<th align="left">订单id</th>
<th align="left">商品id</th>
<th align="left">成交金额</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Order_0000001</td>
<td align="left">Pdt_01</td>
<td align="left">222.8</td>
</tr>
<tr>
<td align="left">Order_0000001</td>
<td align="left">Pdt_05</td>
<td align="left">25.8</td>
</tr>
<tr>
<td align="left">Order_0000002</td>
<td align="left">Pdt_03</td>
<td align="left">522.8</td>
</tr>
<tr>
<td align="left">Order_0000002</td>
<td align="left">Pdt_04</td>
<td align="left">122.4</td>
</tr>
<tr>
<td align="left">Order_0000002</td>
<td align="left">Pdt_05</td>
<td align="left">722.4</td>
</tr>
<tr>
<td align="left">Order_0000003</td>
<td align="left">Pdt_01</td>
<td align="left">222.8</td>
</tr>
</tbody></table>
<p>现在需要求出每一个订单中成交金额最大的一笔交易</p>
<h3 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2 分析"></a><strong>3.2 分析</strong></h3><p>1、利用“订单id和成交金额”作为key，可以将map阶段读取到的所有订单数据按照id分区，按照金额排序，发送到reduce</p>
<p>2、在reduce端利用分组将订单id相同的kv聚合成组，然后取第一个即是最大值</p>
<h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a><strong>3.3 实现</strong></h3><h4 id="第一步-定义OrderBean"><a href="#第一步-定义OrderBean" class="headerlink" title="第一步:定义OrderBean"></a><strong>第一步:</strong>定义OrderBean</h4><p>定义一个OrderBean，里面定义两个字段，第一个字段是我们的orderId，第二个字段是我们的金额（注意金额一定要使用Double或者DoubleWritable类型，否则没法按照金额顺序排序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class OrderBean  implements WritableComparable&lt;OrderBean&gt;&#123;</span><br><span class="line">    private  String orderId;</span><br><span class="line">    private  Double price;</span><br><span class="line"></span><br><span class="line">    public String getOrderId() &#123;</span><br><span class="line">        return orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrderId(String orderId) &#123;</span><br><span class="line">        this.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(Double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return  orderId + &quot;\t&quot; + price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //指定排序规则</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(OrderBean orderBean) &#123;</span><br><span class="line">        //先比较订单ID,如果订单ID一致,则排序订单金额(降序)</span><br><span class="line">        int i = this.orderId.compareTo(orderBean.orderId);</span><br><span class="line">        if(i == 0)&#123;</span><br><span class="line">            i = this.price.compareTo(orderBean.price) * -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现对象的序列化</span><br><span class="line">    @Override</span><br><span class="line">    public void write(DataOutput out) throws IOException &#123;</span><br><span class="line">         out.writeUTF(orderId);</span><br><span class="line">         out.writeDouble(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实现对象反序列化</span><br><span class="line">    @Override</span><br><span class="line">    public void readFields(DataInput in) throws IOException &#123;</span><br><span class="line">        this.orderId = in.readUTF();</span><br><span class="line">        this.price  = in.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二步-定义Mapper类"><a href="#第二步-定义Mapper类" class="headerlink" title="第二步: 定义Mapper类"></a>第二步: 定义Mapper类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GroupMapper extends Mapper&lt;LongWritable,Text,OrderBean,Text&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        //1:拆分行文本数据,得到订单的ID,订单的金额</span><br><span class="line">        String[] split = value.toString().split(&quot;\t&quot;);</span><br><span class="line"></span><br><span class="line">        //2:封装OrderBean,得到K2</span><br><span class="line">        OrderBean orderBean = new OrderBean();</span><br><span class="line">        orderBean.setOrderId(split[0]);</span><br><span class="line">        orderBean.setPrice(Double.valueOf(split[2]));</span><br><span class="line"></span><br><span class="line">        //3:将K2和V2写入上下文中</span><br><span class="line">        context.write(orderBean, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步-自定义分区"><a href="#第三步-自定义分区" class="headerlink" title="第三步:自定义分区"></a><strong>第三步:</strong>自定义分区</h4><p>自定义分区，按照订单id进行分区，把所有订单id相同的数据，都发送到同一个reduce中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OrderPartition extends Partitioner&lt;OrderBean,Text&gt; &#123;</span><br><span class="line">    //分区规则: 根据订单的ID实现分区</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param orderBean K2</span><br><span class="line">     * @param text  V2</span><br><span class="line">     * @param i  ReduceTask个数</span><br><span class="line">     * @return 返回分区的编号</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public int getPartition(OrderBean orderBean, Text text, int i) &#123;</span><br><span class="line">        return (orderBean.getOrderId().hashCode() &amp; 2147483647) % i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步-自定义分组"><a href="#第四步-自定义分组" class="headerlink" title="第四步:自定义分组"></a><strong>第四步:</strong>自定义分组</h4><p>按照我们自己的逻辑进行分组，通过比较相同的订单id，将相同的订单id放到一个组里面去，进过分组之后当中的数据，已经全部是排好序的数据，我们只需要取前topN即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1: 继承WriteableComparator</span><br><span class="line">public class OrderGroupComparator extends WritableComparator &#123;</span><br><span class="line">    // 2: 调用父类的有参构造</span><br><span class="line">    public OrderGroupComparator() &#123;</span><br><span class="line">        super(OrderBean.class,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3: 指定分组的规则(重写方法)</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(WritableComparable a, WritableComparable b) &#123;</span><br><span class="line">        //3.1 对形参做强制类型转换</span><br><span class="line">        OrderBean first = (OrderBean)a;</span><br><span class="line">        OrderBean second = (OrderBean)b;</span><br><span class="line"></span><br><span class="line">        //3.2 指定分组规则</span><br><span class="line">        return first.getOrderId().compareTo(second.getOrderId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步-定义Reducer类"><a href="#第五步-定义Reducer类" class="headerlink" title="第五步:定义Reducer类"></a>第五步:定义Reducer类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GroupReducer extends Reducer&lt;OrderBean,Text,Text,NullWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(OrderBean key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        //获取集合中的前N条数据</span><br><span class="line">        for (Text value : values) &#123;</span><br><span class="line">            context.write(value, NullWritable.get());</span><br><span class="line">            i++;</span><br><span class="line">            if(i &gt;= 1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第六步-程序main函数入口"><a href="#第六步-程序main函数入口" class="headerlink" title="第六步:程序main函数入口"></a><strong>第六步:</strong>程序main函数入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class JobMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //1:获取Job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;mygroup_job&quot;);</span><br><span class="line"></span><br><span class="line">        //2:设置job任务</span><br><span class="line">            //第一步:设置输入类和输入路径</span><br><span class="line">            job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">            TextInputFormat.addInputPath(job, new Path(&quot;file:///D:\\input\\mygroup_input&quot;));</span><br><span class="line"></span><br><span class="line">            //第二步:设置Mapper类和数据类型</span><br><span class="line">            job.setMapperClass(GroupMapper.class);</span><br><span class="line">            job.setMapOutputKeyClass(OrderBean.class);</span><br><span class="line">            job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">            //第三,四,五,六</span><br><span class="line">            //设置分区</span><br><span class="line">            job.setPartitionerClass(OrderPartition.class);</span><br><span class="line">            //设置分组</span><br><span class="line">            job.setGroupingComparatorClass(OrderGroupComparator.class);</span><br><span class="line"></span><br><span class="line">            //第七步:设置Reducer类和数据类型</span><br><span class="line">            job.setReducerClass(GroupReducer.class);</span><br><span class="line">            job.setOutputKeyClass(Text.class);</span><br><span class="line">            job.setOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line">            //第八步:设置输出类和输出的路径</span><br><span class="line">            job.setOutputFormatClass(TextOutputFormat.class);</span><br><span class="line">            TextOutputFormat.setOutputPath(job, new Path(&quot;file:///D:\\out\\mygroup_out&quot;));</span><br><span class="line"></span><br><span class="line">        //3:等待job任务结束</span><br><span class="line">        boolean bl = job.waitForCompletion(true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return bl ? 0: 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = new Configuration();</span><br><span class="line"></span><br><span class="line">        //启动job任务</span><br><span class="line">        int run = ToolRunner.run(configuration, new JobMain(), args);</span><br><span class="line"></span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/MapReduce2/" data-id="cjz2496dt0005x0u59hfctvbp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Yarn-资源调度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Yarn-资源调度/" class="article-date">
  <time datetime="2019-08-08T03:20:02.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Yarn-资源调度/">Yarn-资源调度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Yarn资源调度详解"><a href="#Yarn资源调度详解" class="headerlink" title="Yarn资源调度详解"></a>Yarn资源调度详解</h1><h3 id="1-yarn的介绍："><a href="#1-yarn的介绍：" class="headerlink" title="1.yarn的介绍："></a>1.<strong>yarn</strong>的介绍：</h3><p> yarn是hadoop集群当中的资源管理系统模块，从hadoop2.0开始引入yarn模块,yarn可为各类计算框架提供资源的管理和调度,主要用于管理集群当中的资源（主要是服务器的各种硬件资源，包括CPU，内存，磁盘，网络IO等）以及调度运行在yarn上面的各种任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn核心出发点是为了分离资源管理与作业监控，实现分离的做法是拥有一个全局的资源管理（ResourceManager，RM），以及每个应用程序对应一个的应用管理器（ApplicationMaster，AM）</span><br></pre></td></tr></table></figure>

<p> 总结一句话就是说：yarn主要就是为了调度资源，管理任务等</p>
<p>其调度分为两个层级来说：</p>
<ul>
<li><p>一级调度管理：</p>
<p> 计算资源管理(CPU,内存，网络IO，磁盘)</p>
</li>
<li><p>二级调度管理：</p>
<p> 任务内部的计算模型管理 (AppMaster的任务精细化管理)</p>
</li>
</ul>
<p><strong>yarn的官网文档说明：</strong></p>
<p><a href="http://hadoop.apache.org/docs/r2.7.5/hadoop-yarn/hadoop-yarn-site/YARN.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r2.7.5/hadoop-yarn/hadoop-yarn-site/YARN.html</a></p>
<p><strong>yarn集群的监控管理界面：</strong></p>
<p><a href="http://node01:8088/cluster" target="_blank" rel="noopener">http://node01:8088/cluster</a></p>
<p><strong>jobHistoryServer查看界面：</strong></p>
<p><a href="http://node01:19888/jobhistory" target="_blank" rel="noopener">http://node01:19888/jobhistory</a></p>
<h3 id="2-Yarn的主要组件介绍与作用"><a href="#2-Yarn的主要组件介绍与作用" class="headerlink" title="2.Yarn的主要组件介绍与作用"></a>2.<strong>Yarn的</strong>主要组件介绍与作用</h3><p><code>YARN总体上是Master/Slave结构</code>，主要由ResourceManager、NodeManager、 ApplicationMaster和Container等几个组件构成。</p>
<ul>
<li><p>ResourceManager(RM)</p>
<p>负责处理客户端请求,对各NM上的资源进行统一管理和调度。给ApplicationMaster分配空闲的Container 运行并监控其运行状态。主要由两个组件构成：调度器和应用程序管理器：</p>
<ol>
<li><strong>调度器(Scheduler)</strong>：调度器根据容量、队列等限制条件，将系统中的资源分配给各个正在运行的应用程序。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位是Container。Shceduler不负责监控或者跟踪应用程序的状态。总之，调度器根据应用程序的资源要求，以及集群机器的资源情况，为应用程序分配封装在Container中的资源。</li>
<li><strong>应用程序管理器(Applications Manager)</strong>：应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster 、监控ApplicationMaster运行状态并在失败时重新启动等，跟踪分给的Container的进度、状态也是其职责。</li>
</ol>
</li>
<li><p><strong>NodeManager (NM)</strong><br>NodeManager 是每个节点上的资源和任务管理器。它会定时地向ResourceManager汇报本节点上的资源使用情况和各个Container的运行状态；同时会接收并处理来自ApplicationMaster 的Container 启动/停止等请求。</p>
</li>
<li><p><strong>ApplicationMaster (AM)</strong>：<br>用户提交的应用程序均包含一个*<em>ApplicationMaster *</em>，负责应用的监控，跟踪应用执行状态，重启失败任务等。ApplicationMaster是应用框架，它负责向ResourceManager协调资源，并且与NodeManager协同工作完成Task的执行和监控。</p>
</li>
<li><p><strong>Container</strong>：<br>Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当ApplicationMaster向ResourceManager申请资源时，ResourceManager为ApplicationMaster 返回的资源便是用Container 表示的。</p>
</li>
</ul>
<h3 id="3-yarn的架构和工作流程"><a href="#3-yarn的架构和工作流程" class="headerlink" title="3.yarn的架构和工作流程"></a>3.<strong>yarn</strong>的架构和工作流程</h3><p><a href="https://manzhong.github.io/images/yarn/4-yarn%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/yarn/4-yarn%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="img"></a></p>
<h3 id="4-yarn的调度器"><a href="#4-yarn的调度器" class="headerlink" title="4.yarn的调度器"></a>4.yarn的调度器</h3><p>yarn我们都知道主要是用于做资源调度，任务分配等功能的，那么在hadoop当中，究竟使用什么算法来进行任务调度就需要我们关注了，hadoop支持好几种任务的调度方式，不同的场景需要使用不同的任务调度器.</p>
<h5 id="第一种调度器：FIFO-Scheduler（队列调度）"><a href="#第一种调度器：FIFO-Scheduler（队列调度）" class="headerlink" title="第一种调度器：FIFO Scheduler（队列调度）"></a><code>第一种调度器：FIFO Scheduler（队列调度）</code></h5><p>把任务按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的任务进行分配资源，待最头上任务需求满足后再给下一个分配，以此类推。</p>
<p>FIFO Scheduler是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的任务可能会占用所有集群资源，这就导致其它任务被阻塞。</p>
<h5 id="第二种调度器：Capacity-Scheduler（容量调度器，apache版本默认使用的调度器）"><a href="#第二种调度器：Capacity-Scheduler（容量调度器，apache版本默认使用的调度器）" class="headerlink" title="第二种调度器：Capacity Scheduler（容量调度器，apache版本默认使用的调度器）"></a><code>第二种调度器：Capacity Scheduler（容量调度器，apache版本默认使用的调度器）</code></h5><p>Capacity 调度器允许多个组织共享整个集群，每个组织可以获得集群的一部分计算能力。通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源，这样整个集群就可以通过设置多个队列的方式给多个组织提供服务了。除此之外，队列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了，在一个队列内部，资源的调度是采用的是先进先出(FIFO)策略。</p>
<h5 id="第三种调度器：Fair-Scheduler（公平调度器，CDH版本的hadoop默认使用的调度器）"><a href="#第三种调度器：Fair-Scheduler（公平调度器，CDH版本的hadoop默认使用的调度器）" class="headerlink" title="第三种调度器：Fair Scheduler（公平调度器，CDH版本的hadoop默认使用的调度器）"></a><code>第三种调度器：Fair Scheduler（公平调度器，CDH版本的hadoop默认使用的调度器）</code></h5><p>Fair调度器的设计目标是为所有的应用分配公平的资源（对公平的定义可以通过参数来设置）。公平调度在也可以在多个队列间工作。举个例子，假设有两个用户A和B，他们分别拥有一个队列。当A启动一个job而B没有任务时，A会获得全部集群资源；当B启动一个job后，A的job会继续运行，不过一会儿之后两个任务会各自获得一半的集群资源。如果此时B再启动第二个job并且其它job还在运行，则它将会和B的第一个job共享B这个队列的资源，也就是B的两个job会用于四分之一的集群资源，而A的job仍然用于集群一半的资源，结果就是资源最终在两个用户之间平等的共享</p>
<p>使用哪种调度器取决于yarn-site.xml当中的</p>
<p><code>yarn.resourcemanager.scheduler.class</code> 这个属性的配置</p>
<h3 id="5-关于yarn常用参数设置"><a href="#5-关于yarn常用参数设置" class="headerlink" title="5.关于yarn常用参数设置"></a>5.<strong>关于</strong>yarn常用参数设置</h3><h4 id="设置container分配最小内存"><a href="#设置container分配最小内存" class="headerlink" title="设置container分配最小内存"></a>设置container分配<strong>最小内存</strong></h4><p>yarn.scheduler.minimum-allocation-mb 1024 给应用程序container分配的最小内存</p>
<h4 id="设置container分配最大内存"><a href="#设置container分配最大内存" class="headerlink" title="设置container分配最大内存"></a>设置container分配<strong>最大内存</strong></h4><p>yarn.scheduler.maximum-allocation-mb 8192 给应用程序container分配的最大内存</p>
<h4 id="设置每个container的最小虚拟内核个数"><a href="#设置每个container的最小虚拟内核个数" class="headerlink" title="设置每个container的最小虚拟内核个数"></a>设置每个<strong>container的</strong>最小<strong>虚拟内核个数</strong></h4><p>yarn.scheduler.minimum-allocation-vcores 1 每个container默认给分配的最小的虚拟内核个数</p>
<h4 id="设置每个container的最大虚拟内核个数"><a href="#设置每个container的最大虚拟内核个数" class="headerlink" title="设置每个container的最大虚拟内核个数"></a>设置每个container的最大虚拟内核个数</h4><p>yarn.scheduler.maximum-allocation-vcores 32 每个container可以分配的最大的虚拟内核的个数</p>
<h4 id="设置NodeManager可以分配的内存大小"><a href="#设置NodeManager可以分配的内存大小" class="headerlink" title="设置NodeManager可以分配的内存大小"></a>设置NodeManager可以分配的内存大小</h4><p>yarn.nodemanager.resource.memory-mb 8192 nodemanager可以分配的最大内存大小，默认8192Mb</p>
<h4 id="定义每台机器的内存使用大小"><a href="#定义每台机器的内存使用大小" class="headerlink" title="定义每台机器的内存使用大小"></a>定义每台机器的内存使用大小</h4><p>yarn.nodemanager.resource.memory-mb 8192</p>
<h4 id="定义交换区空间可以使用的大小"><a href="#定义交换区空间可以使用的大小" class="headerlink" title="定义交换区空间可以使用的大小"></a>定义交换区空间可以使用的大小</h4><p>交换区空间就是讲一块硬盘拿出来做内存使用,这里指定的是nodemanager的2.1倍</p>
<p>yarn.nodemanager.vmem-pmem-ratio 2.1</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Yarn-资源调度/" data-id="cjz2496cx0001x0u52jmirt9m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-JVM-初探" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Java-JVM-初探/" class="article-date">
  <time datetime="2019-08-08T03:16:51.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Java-JVM-初探/">Java-JVM-初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM</span><br></pre></td></tr></table></figure>

<p>一 Java -version</p>
<p>1 hotspot 热点探测 jvm核心 jdk1.5 之后有 为执行引擎</p>
<p>优化class文件 因为CPU不会直接执行class文件 要转为二进制才可以</p>
<p>2 jdk 有client 和server默认启动为client 可在jre/lib/i386 里吧两者顺序调整 前面的先起</p>
<p>当大型项目时 可改为server</p>
<p>在jdk1.8之后都默认为server 且client 为ignore</p>
<p>二 Jvm结构</p>
<p><a href="https://manzhong.github.io/images/jvm/jvm%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/jvm/jvm%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="img"></a></p>
<p><a href="https://manzhong.github.io/images/jvm/jvm%E7%AE%80%E4%BB%8B.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/jvm/jvm%E7%AE%80%E4%BB%8B.jpg" alt="img"></a></p>
<p><a href="https://manzhong.github.io/images/jvm/jvm%E7%AE%80%E4%BB%8B2.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/jvm/jvm%E7%AE%80%E4%BB%8B2.jpg" alt="img"></a></p>
<p>三 堆结构图及分代</p>
<p>Jvm 根据对象的存活周期不同 把堆内存分为 新生代,老年代,和永久代</p>
<p>目的 提高对象内存分配和垃圾回收效率</p>
<p>经过多次回收荏苒存活的对象放在老年代,静态属性和类信息放在永久代,</p>
<p>新生代中对象存活时间短 在新生代中做垃圾回收 老年代垃圾回收频率少</p>
<p>永久代一般不进行垃圾回收,可根据不同的代用不同的;垃圾回收算法.</p>
<p>堆有五个区(细)</p>
<p>新生代(3个) Eden from to eden 回收最频繁 =幸存的放在from和to的幸存区在此幸存放在 老年去</p>
<p>Old区</p>
<p>永久区</p>
<p>1新生代</p>
<p>新创建的对象放在新生代,这里边存活率很低,一次回收可回收百分之八十到九十五, Eden from to 比例8:1:1</p>
<p>在jdk1.8和之后没有老年代 老年代与方法区作用类似;</p>
<p>三 垃圾回收</p>
<p>1常见垃圾回收算法</p>
<p>1.1</p>
<p>1.2复制算法</p>
<p>1.3标记清除</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Java-JVM-初探/" data-id="cjz2496cq0000x0u57s7i4re9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/数据库/" class="article-date">
  <time datetime="2019-08-08T03:06:05.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/数据库/">数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、数据库介绍篇"><a href="#1、数据库介绍篇" class="headerlink" title="1、数据库介绍篇"></a>1、数据库介绍篇</h1><h2 id="1-1什么是数据库"><a href="#1-1什么是数据库" class="headerlink" title="1.1什么是数据库"></a>1.1什么是数据库</h2><p> 数据库：保存数据的仓库。它体现我们电脑中，就是一个文件系统。然后把数据都保存这些特殊的文件中，并且需要使用固定的语言（<strong>SQL语言</strong>）去操作文件中的数据。</p>
<p>技术定义：</p>
<p> 数据库(Database)是按照<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">数据结构</a>来组织、[<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">存储</a>和管理数据的建立在计算机存储设备上的仓库。</p>
<h2 id="1-2数据库介绍"><a href="#1-2数据库介绍" class="headerlink" title="1.2数据库介绍"></a>1.2数据库介绍</h2><p> 我们开发应用程序的时候，程序中的所有数据，最后都需要保存到专业软件中。这些专业的保存数据的软件我们称为数据库。</p>
<p>我们学习数据库，并不是学习如何去开发一个数据库软件，我们学习的是如何使用数据库以及数据库中的数据记录的操作。而数据库软件是由第三方公司研发。</p>
<h2 id="1-3数据库的分类"><a href="#1-3数据库的分类" class="headerlink" title="1.3数据库的分类"></a>1.3数据库的分类</h2><p> 关系型、非关系型的数据库</p>
<p>常见的数据库软件：</p>
<p>Oracle：它是Oracle公司的大型关系型数据库，它是收费的。</p>
<p>DB2：IBM公司的数据库，它是收费的。</p>
<p>SqlServer：微软数据库。收费</p>
<p>Sybase：Sybase公司的。 工具PowerDesign 数据库建模工具。</p>
<p>MySql：早期瑞典一个公司发明，后期被sun公司收购，后期被Oracle。</p>
<p>Java开发应用程序主要使用的数据库：</p>
<p>MySQL（5.5）、Oracle、DB2。</p>
<h2 id="1-4什么是关系型数据库"><a href="#1-4什么是关系型数据库" class="headerlink" title="1.4什么是关系型数据库"></a>1.4什么是关系型数据库</h2><p> 在开发软件的时候，软件中的数据之间必然会有一定的关系存在，需要把这些数据保存在数据库中，同时也要维护数据之间的关系，这时就可以直接使用上述的那些数据库。而上述的所有数据库都属于关系型数据库。</p>
<p> 描述数据之间的关系，并保存在数据库中，同时学习如果根据这些关系查询数据库中的数据，</p>
<p>关系型数据：设计数据库的时候，需要使用E-R图来描述。实体关系</p>
<p>E-R：实体关系图。</p>
<p> 实体：可以理解成我们Java程序中的一个对象。在E-R图中使用 矩形(长方形) 表示。</p>
<p>针对一个实体中的属性，我们称为这个实体的数据，在E-R图中使用 椭圆表示。</p>
<p>实体和实体之间的关系：在E-R图中使用菱形表示。</p>
<h1 id="2、mysql在linux-安装篇"><a href="#2、mysql在linux-安装篇" class="headerlink" title="2、mysql在linux-安装篇"></a>2、mysql在linux-安装篇</h1><h2 id="2-1、vmware中安装linux注意事项"><a href="#2-1、vmware中安装linux注意事项" class="headerlink" title="2.1、vmware中安装linux注意事项"></a>2.1、vmware中安装linux注意事项</h2><h3 id="2-1-1、记得关闭防火墙"><a href="#2-1-1、记得关闭防火墙" class="headerlink" title="2.1.1、记得关闭防火墙"></a>2.1.1、记得关闭防火墙</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off（关闭开机自启：所谓的永久关闭防火墙）</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2、创建统一的管理目录"><a href="#2-1-2、创建统一的管理目录" class="headerlink" title="2.1.2、创建统一的管理目录"></a>2.1.2、创建统一的管理目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /exprot/software</span><br><span class="line"></span><br><span class="line">mkdir -p /export/servers</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3软件环境"><a href="#2-1-3软件环境" class="headerlink" title="2.1.3软件环境"></a>2.1.3软件环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VMware、crt、centos6.9</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4安装环境"><a href="#2-1-4安装环境" class="headerlink" title="2.1.4安装环境"></a>2.1.4安装环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、VMware软件安装</span><br><span class="line"></span><br><span class="line">	2、构建虚拟机</span><br><span class="line"></span><br><span class="line">	3、需要配置Linux（ip,mac地址，hostname，防火墙），就可以通过crt这个客户端连接进行操作</span><br><span class="line"></span><br><span class="line">	4、在linux操作系统进行安装msyql-5.6</span><br><span class="line">	</span><br><span class="line">	说明：因为在linux操作系统中，安装软件的方式主要有3种：1、源码安装（redis）2、rpm安装 		</span><br><span class="line"></span><br><span class="line">3、yum在线安装（安装MySQL为例）---linux联网（）</span><br></pre></td></tr></table></figure>

<h2 id="2-2、centos6-9安装mysql"><a href="#2-2、centos6-9安装mysql" class="headerlink" title="2.2、centos6.9安装mysql"></a>2.2、centos6.9安装mysql</h2><h3 id="2-2-1、检查是否有自带的mysql"><a href="#2-2-1、检查是否有自带的mysql" class="headerlink" title="2.2.1、检查是否有自带的mysql"></a>2.2.1、检查是否有自带的mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop-01 servers]# rpm -qa |grep mysql </span><br><span class="line">mysql-libs-5.1.73-8.el6_8.x86_64</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2、卸载自带的mysql"><a href="#2-2-2、卸载自带的mysql" class="headerlink" title="2.2.2、卸载自带的mysql"></a>2.2.2、卸载自带的mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop-01 servers]# rpm -e --nodeps mysql-libs-5.1.73-8.el6_8.x86_64</span><br><span class="line">[root@hadoop-01 servers]#</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3、下载mysql安装包"><a href="#2-2-3、下载mysql安装包" class="headerlink" title="2.2.3、下载mysql安装包"></a>2.2.3、下载mysql安装包</h3><h3 id="2-2-4、上传安装包到linux服务器"><a href="#2-2-4、上传安装包到linux服务器" class="headerlink" title="2.2.4、上传安装包到linux服务器"></a>2.2.4、上传安装包到linux服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rz 上传文件到指定的目录（yum install lrzsz）</span><br><span class="line">/export/software/mysql</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5、安装"><a href="#2-2-5、安装" class="headerlink" title="2.2.5、安装"></a>2.2.5、安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh *.rpm</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6、查看初始化密码"><a href="#2-2-6、查看初始化密码" class="headerlink" title="2.2.6、查看初始化密码"></a>2.2.6、查看初始化密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A RANDOM PASSWORD HAS BEEN SET FOR THE MySQL root USER !</span><br><span class="line">You will find that password in &apos;/root/.mysql_secret&apos;.</span><br><span class="line">[root@mysql ~]# cat /root/.mysql_secret</span><br><span class="line"># The random password set for the root user at Wed Aug  8 22:19:00 2018 (local time): xQkcU3kbyuZby1_V</span><br><span class="line"></span><br><span class="line">[root@mysql ~]#</span><br></pre></td></tr></table></figure>

<h3 id="2-2-7、启动mysql并登录"><a href="#2-2-7、启动mysql并登录" class="headerlink" title="2.2.7、启动mysql并登录"></a>2.2.7、启动mysql并登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#启动mysql</span><br><span class="line">service mysql start</span><br><span class="line">#登录mysql</span><br><span class="line">mysql -uroot -p</span><br><span class="line">(粘贴密码：xQkcU3kbyuZby1_V)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-8、修改密码"><a href="#2-2-8、修改密码" class="headerlink" title="2.2.8、修改密码"></a>2.2.8、修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set PASSWORD=PASSWORD(&apos;123456&apos;);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-9、退出mysql客户端"><a href="#2-2-9、退出mysql客户端" class="headerlink" title="2.2.9、退出mysql客户端"></a>2.2.9、退出mysql客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;quit</span><br></pre></td></tr></table></figure>

<h3 id="2-2-10、用新密码进行登录"><a href="#2-2-10、用新密码进行登录" class="headerlink" title="2.2.10、用新密码进行登录"></a>2.2.10、用新密码进行登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">123456（新密码）</span><br></pre></td></tr></table></figure>

<h3 id="2-2-11、远程授权"><a href="#2-2-11、远程授权" class="headerlink" title="2.2.11、远程授权"></a>2.2.11、远程授权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;123456&apos;; </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-12、验证远程授权是否成功"><a href="#2-2-12、验证远程授权是否成功" class="headerlink" title="2.2.12、验证远程授权是否成功"></a>2.2.12、验证远程授权是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过windows的mysql客户端工具连接，是否能连接上，能连接上就授权成功，没有连接上，说明没有授权成功！</span><br></pre></td></tr></table></figure>

<h1 id="3、mysql-基础操作篇"><a href="#3、mysql-基础操作篇" class="headerlink" title="3、mysql-基础操作篇"></a>3、mysql-基础操作篇</h1><h2 id="3-1、登录mysql"><a href="#3-1、登录mysql" class="headerlink" title="3.1、登录mysql"></a>3.1、登录mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>

<h2 id="3-2、退出mysql"><a href="#3-2、退出mysql" class="headerlink" title="3.2、退出mysql"></a>3.2、退出mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;quit</span><br></pre></td></tr></table></figure>

<h2 id="3-3、输入查询"><a href="#3-3、输入查询" class="headerlink" title="3.3、输入查询"></a>3.3、输入查询</h2><ul>
<li><p>查看当前mysql的版本号及当前时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT VERSION(), CURRENT_DATE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT VERSION(), CURRENT_DATE;</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| VERSION() | CURRENT_DATE |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| 5.6.25    | 2018-08-08   |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">1 row in set (0.32 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>mysql中sql语句不区分大小写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT VERSION(), CURRENT_DATE;</span><br><span class="line">mysql&gt; select version(), current_date;</span><br><span class="line">mysql&gt; SeLeCt vErSiOn(), current_DATE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT VERSION(), CURRENT_DATE;</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| VERSION() | CURRENT_DATE |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| 5.6.25    | 2018-08-08   |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select version(), current_date;</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| version() | current_date |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| 5.6.25    | 2018-08-08   |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SeLeCt vErSiOn(), current_DATE;</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| vErSiOn() | current_DATE |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">| 5.6.25    | 2018-08-08   |</span><br><span class="line">+-----------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以进行简单的计算（如下所示）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT SIN(PI()/4), (4+1)*5;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT SIN(PI()/4), (4+1)*5;</span><br><span class="line">+--------------------+---------+</span><br><span class="line">| SIN(PI()/4)        | (4+1)*5 |</span><br><span class="line">+--------------------+---------+</span><br><span class="line">| 0.7071067811865475 |      25 |</span><br><span class="line">+--------------------+---------+</span><br><span class="line">1 row in set (0.34 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多条语句比较短，可以写在一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT VERSION(); SELECT NOW();</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT VERSION(); SELECT NOW();</span><br><span class="line">+-----------+</span><br><span class="line">| VERSION() |</span><br><span class="line">+-----------+</span><br><span class="line">| 5.6.25    |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| NOW()               |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2018-08-08 23:11:11 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个字段之间可以用逗号分隔，多行组成一条语句结束以分号结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">-&gt; USER()</span><br><span class="line">-&gt; ,</span><br><span class="line">-&gt; CURRENT_DATE;</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| USER() | CURRENT_DATE |</span><br><span class="line">+---------------+--------------+</span><br><span class="line">| jon@localhost | 2010-08-06 |</span><br><span class="line">+---------------+--------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>sql语句写了一半，又不想执行可以在语句末尾加上’\c’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">    -&gt; user()</span><br><span class="line">    -&gt; \c</span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-4、创建和使用数据库"><a href="#3-4、创建和使用数据库" class="headerlink" title="3.4、创建和使用数据库"></a>3.4、创建和使用数据库</h2><ul>
<li><p>查看当前有哪些数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show databases;</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE menagerie;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用及切换数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE menagerie</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-5、创建表及使用"><a href="#3-5、创建表及使用" class="headerlink" title="3.5、创建表及使用"></a>3.5、创建表及使用</h2><ul>
<li><p>查看当前数据库有哪些表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),</span><br><span class="line">    -&gt; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验创建表语句是否和执行的一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show create table pet;</span><br><span class="line"></span><br><span class="line">+-------+--------------------------------</span><br><span class="line">| Table | Create Table                   </span><br><span class="line">+-------+--------------------------------</span><br><span class="line">| pet   | CREATE TABLE `pet` (</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  `owner` varchar(20) DEFAULT NULL,</span><br><span class="line">  `species` varchar(20) DEFAULT NULL,</span><br><span class="line">  `sex` char(1) DEFAULT NULL,</span><br><span class="line">  `birth` date DEFAULT NULL,</span><br><span class="line">  `death` date DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1 |</span><br><span class="line">+-------+--------------------------------</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表详情</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc pet;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| name    | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| owner   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| species | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex     | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| birth   | date        | YES  |     | NULL    |       |</span><br><span class="line">| death   | date        | YES  |     | NULL    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备数据</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Fluffy Harold cat f 1993-02-04</span><br><span class="line">Claws Gwen cat m 1994-03-17</span><br><span class="line">Buffy Harold dog f 1989-05-13</span><br><span class="line">Fang Benny dog m 1990-08-27</span><br><span class="line">Bowser Diane dog m 1979-08-31 1995-07-29</span><br><span class="line">Chirpy Gwen bird f 1998-09-11</span><br><span class="line">Whistler Gwen bird 1997-12-09</span><br><span class="line">Slim Benny snake m 1996-04-29</span><br></pre></td></tr></table></figure>

<h2 id="3-6、表中导入数据"><a href="#3-6、表中导入数据" class="headerlink" title="3.6、表中导入数据"></a>3.6、表中导入数据</h2><p> 在表中导入数据的方式有两种</p>
<ul>
<li><p>第一种：将以上数据整理成SQL语句，insert into pet….</p>
</li>
<li><p>第二种：通过加载文件的方式将数据导入到表中</p>
<p>1、创建一个pet.txt的文件（注：每个字段中用tab键隔开，字段没有值得记录用\N代替）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Fluffy  Harold  cat     f       1993-02-04</span><br><span class="line">Claws   Gwen    cat     m       1994-03-17</span><br><span class="line">Buffy   Harold  dog     f       1989-05-13</span><br><span class="line">Fang    Benny   dog     m       1990-08-27</span><br><span class="line">Bowser  Diane   dog     m       1979-08-31      1995-07-29</span><br><span class="line">Chirpy  Gwen    bird    f       1998-09-11</span><br><span class="line">Whistler        Gwen    bird    \N      1997-12-09      \N</span><br><span class="line">Slim    Benny   snake   m       1996-04-29</span><br></pre></td></tr></table></figure>

<p>2、加载数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; load data local infile &apos;/root/data/pet.txt&apos; into table pet;</span><br><span class="line">Query OK, 8 rows affected, 6 warnings (0.06 sec)</span><br><span class="line">Records: 8  Deleted: 0  Skipped: 0  Warnings: 6</span><br></pre></td></tr></table></figure>

<p>3、校验是否加载进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from pet;</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| name     | owner  | species | sex  | birth      | death      |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |</span><br><span class="line">| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |</span><br><span class="line">| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |</span><br><span class="line">| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |</span><br><span class="line">| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |</span><br><span class="line">| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |</span><br><span class="line">| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |</span><br><span class="line">| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-7、数据检索部分"><a href="#3-7、数据检索部分" class="headerlink" title="3.7、数据检索部分"></a>3.7、数据检索部分</h2><h3 id="3-7-1、检索全部数据"><a href="#3-7-1、检索全部数据" class="headerlink" title="3.7.1、检索全部数据"></a>3.7.1、检索全部数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select *from pet;</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| name     | owner  | species | sex  | birth      | death      |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |</span><br><span class="line">| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |</span><br><span class="line">| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |</span><br><span class="line">| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |</span><br><span class="line">| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |</span><br><span class="line">| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |</span><br><span class="line">| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |</span><br><span class="line">| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="3-7-2、删除表中全部数据"><a href="#3-7-2、删除表中全部数据" class="headerlink" title="3.7.2、删除表中全部数据"></a>3.7.2、删除表中全部数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELETE FROM pet;</span><br><span class="line">mysql&gt; LOAD DATA LOCAL INFILE &apos;/path/pet.txt&apos; INTO TABLE pet;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-3、更新表中特定记录的数据"><a href="#3-7-3、更新表中特定记录的数据" class="headerlink" title="3.7.3、更新表中特定记录的数据"></a>3.7.3、更新表中特定记录的数据</h3><ul>
<li>更新表中名字为Bowser的生日</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE pet SET birth = &apos;1989-08-31&apos; WHERE name = &apos;Bowser&apos;;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-4、查询特定的行"><a href="#3-7-4、查询特定的行" class="headerlink" title="3.7.4、查询特定的行"></a>3.7.4、查询特定的行</h3><ul>
<li>查询名字为Bowser的记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE name = &apos;Bowser&apos;;</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| name | owner | species | sex | birth | death |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| Bowser | Diane | dog | m | 1989-08-31 | 1995-07-29 |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br></pre></td></tr></table></figure>

<p>说明：字符串比较不区分大小写！如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE name = &apos;Bowser&apos;;</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| name   | owner | species | sex  | birth      | death      |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| Bowser | Diane | dog     | m    | 1979-08-31 | 1995-07-29 |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name = &apos;BowsEr&apos;;</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| name   | owner | species | sex  | birth      | death      |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| Bowser | Diane | dog     | m    | 1979-08-31 | 1995-07-29 |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE name = &apos;BOWSER&apos;;</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| name   | owner | species | sex  | birth      | death      |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">| Bowser | Diane | dog     | m    | 1979-08-31 | 1995-07-29 |</span><br><span class="line">+--------+-------+---------+------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-7-4-1、查找生日在1998年以后的特定查询"><a href="#3-7-4-1、查找生日在1998年以后的特定查询" class="headerlink" title="3.7.4.1、查找生日在1998年以后的特定查询"></a>3.7.4.1、查找生日在1998年以后的特定查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE birth &gt;= &apos;1998-1-1&apos;;</span><br><span class="line">+----------+-------+---------+------+------------+-------+</span><br><span class="line">| name | owner | species | sex | birth | death |</span><br><span class="line">+----------+-------+---------+------+------------+-------+</span><br><span class="line">| Chirpy | Gwen | bird | f | 1998-09-11 | NULL |</span><br><span class="line">| Puffball | Diane | hamster | f | 1999-03-30 | NULL |</span><br><span class="line">+----------+-------+---------+------+------------+-------+</span><br></pre></td></tr></table></figure>

<h4 id="3-7-4-2、多条件查询（and-or）"><a href="#3-7-4-2、多条件查询（and-or）" class="headerlink" title="3.7.4.2、多条件查询（and | or）"></a>3.7.4.2、多条件查询（and | or）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE species = &apos;dog&apos; AND sex = &apos;f&apos;;</span><br><span class="line">+-------+--------+---------+------+------------+-------+</span><br><span class="line">| name | owner | species | sex | birth | death |</span><br><span class="line">+-------+--------+---------+------+------------+-------+</span><br><span class="line">| Buffy | Harold | dog | f | 1989-05-13 | NULL |</span><br><span class="line">+-------+--------+---------+------+------------+-------+</span><br><span class="line">mysql&gt; SELECT * FROM pet WHERE species = &apos;snake&apos; OR species = &apos;bird&apos;;</span><br><span class="line">+----------+-------+---------+------+------------+-------+</span><br><span class="line">| name | owner | species | sex | birth | death |</span><br><span class="line">+----------+-------+---------+------+------------+-------+</span><br><span class="line">| Chirpy | Gwen | bird | f | 1998-09-11 | NULL |</span><br><span class="line">| Whistler | Gwen | bird | NULL | 1997-12-09 | NULL |</span><br><span class="line">| Slim | Benny | snake | m | 1996-04-29 | NULL |</span><br><span class="line">+----------+-------+---------+------+------------+-------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优先执行括号中的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM pet WHERE (species = &apos;cat&apos; AND sex = &apos;m&apos;)</span><br><span class="line">-&gt; OR (species = &apos;dog&apos; AND sex = &apos;f&apos;);</span><br><span class="line">+-------+--------+---------+------+------------+-------+</span><br><span class="line">| name | owner | species | sex | birth | death |</span><br><span class="line">+-------+--------+---------+------+------------+-------+</span><br><span class="line">| Claws | Gwen | cat | m | 1994-03-17 | NULL |</span><br><span class="line">| Buffy | Harold | dog | f | 1989-05-13 | NULL |</span><br><span class="line">+-------+--------+---------+------+------------+-------+</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-7-5、检索特定的列"><a href="#3-7-5、检索特定的列" class="headerlink" title="3.7.5、检索特定的列"></a>3.7.5、检索特定的列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth FROM pet;</span><br><span class="line">+----------+------------+</span><br><span class="line">| name | birth |</span><br><span class="line">+----------+------------+</span><br><span class="line">| Fluffy | 1993-02-04 |</span><br><span class="line">| Claws | 1994-03-17 |</span><br><span class="line">| Buffy | 1989-05-13 |</span><br><span class="line">| Fang | 1990-08-27 |</span><br><span class="line">| Bowser | 1989-08-31 |</span><br><span class="line">| Chirpy | 1998-09-11 |</span><br><span class="line">| Whistler | 1997-12-09 |</span><br><span class="line">| Slim | 1996-04-29 |</span><br><span class="line">| Puffball | 1999-03-30 |</span><br><span class="line">+----------+------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查询不重复的字段要使用关键词DISTINCT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT owner FROM pet;</span><br><span class="line">+--------+</span><br><span class="line">| owner |</span><br><span class="line">+--------+</span><br><span class="line">| Benny |</span><br><span class="line">| Diane |</span><br><span class="line">| Gwen |</span><br><span class="line">| Harold |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用组合条件查询特定的列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, species, birth FROM pet</span><br><span class="line">-&gt; WHERE species = &apos;dog&apos; OR species = &apos;cat&apos;;</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| name | species | birth |</span><br><span class="line">+--------+---------+------------+</span><br><span class="line">| Fluffy | cat | 1993-02-04 |</span><br><span class="line">| Claws | cat | 1994-03-17 |</span><br><span class="line">| Buffy | dog | 1989-05-13 |</span><br><span class="line">| Fang | dog | 1990-08-27 |</span><br><span class="line">| Bowser | dog | 1989-08-31 |</span><br><span class="line">+--------+---------+------------+</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-7-6、排序"><a href="#3-7-6、排序" class="headerlink" title="3.7.6、排序"></a>3.7.6、排序</h3><ul>
<li>根据某个字段进行排序（关键词：ORDER BY ）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth FROM pet ORDER BY birth;</span><br><span class="line">+----------+------------+</span><br><span class="line">| name | birth |</span><br><span class="line">+----------+------------+</span><br><span class="line">| Buffy | 1989-05-13 |</span><br><span class="line">| Bowser | 1989-08-31 |</span><br><span class="line">| Fang | 1990-08-27 |</span><br><span class="line">| Fluffy | 1993-02-04 |</span><br><span class="line">| Claws | 1994-03-17 |</span><br><span class="line">| Slim | 1996-04-29 |</span><br><span class="line">| Whistler | 1997-12-09 |</span><br><span class="line">| Chirpy | 1998-09-11 |</span><br><span class="line">| Puffball | 1999-03-30 |</span><br><span class="line">+----------+------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>升降序排列（desc：降序；asc：升序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth FROM pet ORDER BY birth desc;//降序排列</span><br><span class="line">mysql&gt; SELECT name, birth FROM pet ORDER BY birth asc ;//升序排列</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列排序</p>
<p>根据species字段升序排列，根据birth字段降序排列</p>
<p><strong>注： ORDER BY species 中无asc，desc，默认为升序排列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, species, birth FROM pet</span><br><span class="line">-&gt; ORDER BY species, birth DESC;</span><br><span class="line">+----------+---------+------------+</span><br><span class="line">| name | species | birth |</span><br><span class="line">+----------+---------+------------+</span><br><span class="line">| Chirpy | bird | 1998-09-11 |</span><br><span class="line">| Whistler | bird | 1997-12-09 |</span><br><span class="line">| Claws | cat | 1994-03-17 |</span><br><span class="line">| Fluffy | cat | 1993-02-04 |</span><br><span class="line">| Fang | dog | 1990-08-27 |</span><br><span class="line">| Bowser | dog | 1989-08-31 |</span><br><span class="line">| Buffy | dog | 1989-05-13 |</span><br><span class="line">| Puffball | hamster | 1999-03-30 |</span><br><span class="line">| Slim | snake | 1996-04-29 |</span><br><span class="line">+----------+---------+------------+</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-7-7、日期计算"><a href="#3-7-7、日期计算" class="headerlink" title="3.7.7、日期计算"></a>3.7.7、日期计算</h3><p>查看宠物多少岁，就可以使用计算日期的函数TIMESTAMPDIFF()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#查询当前的日期</span><br><span class="line">mysql&gt; select curdate() from pet;</span><br><span class="line">+------------+</span><br><span class="line">| curdate()  |</span><br><span class="line">+------------+</span><br><span class="line">| 2018-08-09 |</span><br><span class="line">+------------+</span><br><span class="line"></span><br><span class="line">#获取当年的年</span><br><span class="line">mysql&gt; select YEAR(&apos;2018-02-05&apos;) AS YEARS from pet;</span><br><span class="line">+-------+</span><br><span class="line">| YEARS |</span><br><span class="line">+-------+</span><br><span class="line">|  2018 |</span><br><span class="line">+-------+</span><br><span class="line"></span><br><span class="line">#获取当年的月</span><br><span class="line">mysql&gt; select month(&apos;2018-02-05&apos;) AS YEARS from pet;      </span><br><span class="line">+-------+</span><br><span class="line">| YEARS |</span><br><span class="line">+-------+</span><br><span class="line">|     2 |</span><br><span class="line">+-------+</span><br><span class="line"></span><br><span class="line">#获取当年的日</span><br><span class="line">mysql&gt; select day(&apos;2018-02-05&apos;) AS YEARS from pet;      </span><br><span class="line">+-------+</span><br><span class="line">| YEARS |</span><br><span class="line">+-------+</span><br><span class="line">|     5 |</span><br><span class="line">+-------+</span><br><span class="line">mysql&gt; SELECT name, birth, CURDATE(),</span><br><span class="line">-&gt; TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age</span><br><span class="line">-&gt; FROM pet;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-8、null和not-null值"><a href="#3-7-8、null和not-null值" class="headerlink" title="3.7.8、null和not null值"></a>3.7.8、null和not null值</h3><p>对一些字段类型要进行检查，判断某些字段是否为NULL，或者 non-NULL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, birth, death,</span><br><span class="line">-&gt; TIMESTAMPDIFF(YEAR,birth,death) AS age</span><br><span class="line">-&gt; FROM pet WHERE death IS NOT NULL ORDER BY age;</span><br><span class="line">+--------+------------+------------+------+</span><br><span class="line">| name | birth | death | age |</span><br><span class="line">+--------+------------+------------+------+</span><br><span class="line">| Bowser | 1989-08-31 | 1995-07-29 | 5 |</span><br><span class="line">+--------+------------+------------+------+</span><br></pre></td></tr></table></figure>

<h1 id="4、实例"><a href="#4、实例" class="headerlink" title="4、实例"></a>4、实例</h1><p>以下是如何解决MySQL的一些常见问题的示例。</p>
<h2 id="4-1、首先创建一个表，并且导入数据"><a href="#4-1、首先创建一个表，并且导入数据" class="headerlink" title="4.1、首先创建一个表，并且导入数据"></a>4.1、首先创建一个表，并且导入数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE shop (</span><br><span class="line">article INT(4) UNSIGNED ZEROFILL DEFAULT &apos;0000&apos; NOT NULL,</span><br><span class="line">dealer CHAR(20) DEFAULT &apos;&apos; NOT NULL,</span><br><span class="line">price DOUBLE(16,2) DEFAULT &apos;0.00&apos; NOT NULL,</span><br><span class="line">PRIMARY KEY(article, dealer));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO shop VALUES</span><br><span class="line">(1,&apos;A&apos;,3.45),(1,&apos;B&apos;,3.99),(2,&apos;A&apos;,10.99),(3,&apos;B&apos;,1.45),</span><br><span class="line">(3,&apos;C&apos;,1.69),(3,&apos;D&apos;,1.25),(4,&apos;D&apos;,19.95);</span><br></pre></td></tr></table></figure>

<h2 id="4-2、检索表中的全部数据"><a href="#4-2、检索表中的全部数据" class="headerlink" title="4.2、检索表中的全部数据"></a>4.2、检索表中的全部数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select * from shop;</span><br><span class="line"></span><br><span class="line">+---------+--------+-------+</span><br><span class="line">| article | dealer | price |</span><br><span class="line">+---------+--------+-------+</span><br><span class="line">|    0001 | A      |  3.45 |</span><br><span class="line">|    0001 | B      |  3.99 |</span><br><span class="line">|    0002 | A      | 10.99 |</span><br><span class="line">|    0003 | B      |  1.45 |</span><br><span class="line">|    0003 | C      |  1.69 |</span><br><span class="line">|    0003 | D      |  1.25 |</span><br><span class="line">|    0004 | D      | 19.95 |</span><br><span class="line">+---------+--------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="4-3、求某一列的最大值或者-最小值"><a href="#4-3、求某一列的最大值或者-最小值" class="headerlink" title="4.3、求某一列的最大值或者 最小值"></a>4.3、求某一列的最大值或者 最小值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(article) AS article FROM shop;</span><br><span class="line"></span><br><span class="line">+---------+</span><br><span class="line">| article |</span><br><span class="line">+---------+</span><br><span class="line">|       4 |</span><br><span class="line">+---------+</span><br><span class="line"></span><br><span class="line">//求某一列的最小值</span><br><span class="line"> select min(price) as article from shop; </span><br><span class="line"> </span><br><span class="line"> +---------+</span><br><span class="line">| article |</span><br><span class="line">+---------+</span><br><span class="line">|    1.25 |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<h2 id="4-4、过滤出某个字段值最大的整条记录数据-涉及到子查询"><a href="#4-4、过滤出某个字段值最大的整条记录数据-涉及到子查询" class="headerlink" title="4.4、过滤出某个字段值最大的整条记录数据-涉及到子查询"></a>4.4、过滤出某个字段值最大的整条记录数据-涉及到子查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT article, dealer, price</span><br><span class="line">FROM shop</span><br><span class="line">WHERE price=(SELECT MAX(price) FROM shop);</span><br><span class="line"></span><br><span class="line">+---------+--------+-------+</span><br><span class="line">| article | dealer | price |</span><br><span class="line">+---------+--------+-------+</span><br><span class="line">|    0004 | D      | 19.95 |</span><br><span class="line">+---------+--------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="4-4、也可以通过关联查询来进行检索"><a href="#4-4、也可以通过关联查询来进行检索" class="headerlink" title="4.4、也可以通过关联查询来进行检索"></a>4.4、也可以通过关联查询来进行检索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT s1.article, s1.dealer, s1.price</span><br><span class="line">FROM shop s1</span><br><span class="line">LEFT JOIN shop s2 ON s1.price &lt; s2.price</span><br><span class="line">WHERE s2.article IS NULL;</span><br><span class="line"></span><br><span class="line">SELECT article, dealer, price</span><br><span class="line">FROM shop</span><br><span class="line">ORDER BY price DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure>

<h2 id="4-5、求出每一列的最大值，并且根据某一个字段进行分组–分组topn求法"><a href="#4-5、求出每一列的最大值，并且根据某一个字段进行分组–分组topn求法" class="headerlink" title="4.5、求出每一列的最大值，并且根据某一个字段进行分组–分组topn求法"></a>4.5、求出每一列的最大值，并且根据某一个字段进行分组–分组topn求法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT article, MAX(price) AS price</span><br><span class="line">FROM shop</span><br><span class="line">GROUP BY article;</span><br><span class="line"></span><br><span class="line">+---------+-------+</span><br><span class="line">| article | price |</span><br><span class="line">+---------+-------+</span><br><span class="line">|    0001 |  3.99 |</span><br><span class="line">|    0002 | 10.99 |</span><br><span class="line">|    0003 |  1.69 |</span><br><span class="line">|    0004 | 19.95 |</span><br><span class="line">+---------+-------+</span><br></pre></td></tr></table></figure>

<p>4.5的另一种写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT article, dealer, price</span><br><span class="line">FROM shop s1</span><br><span class="line">WHERE price=(SELECT MAX(s2.price)</span><br><span class="line">FROM shop s2</span><br><span class="line">WHERE s1.article = s2.article);</span><br><span class="line"></span><br><span class="line">+---------+--------+-------+</span><br><span class="line">| article | dealer | price |</span><br><span class="line">+---------+--------+-------+</span><br><span class="line">|    0001 | B      |  3.99 |</span><br><span class="line">|    0002 | A      | 10.99 |</span><br><span class="line">|    0003 | C      |  1.69 |</span><br><span class="line">|    0004 | D      | 19.95 |</span><br><span class="line">+---------+--------+-------+</span><br></pre></td></tr></table></figure>

<h1 id="5、SQL中的聚合函数"><a href="#5、SQL中的聚合函数" class="headerlink" title="5、SQL中的聚合函数"></a>5、SQL中的聚合函数</h1><p> SQL语言中定义了部分的函数，可以帮助我们完成对查询结果的计算操作：</p>
<p>1.count 统计个数（行数）</p>
<p>2.sum函数：求和</p>
<p>3.avg函数：求平均值</p>
<p>4.max、min 求最大值和最小值</p>
<h2 id="5-1、count函数"><a href="#5-1、count函数" class="headerlink" title="5.1、count函数"></a>5.1、count函数</h2><p><strong>语法：select count(*)|count(</strong>列名) from<strong>表名</strong></p>
<p>注意： count在根据指定的列统计的时候，如果这一列中有null 不会被统计在其中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from pet;</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| name     | owner  | species | sex  | birth      | death      |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |</span><br><span class="line">| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |</span><br><span class="line">| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |</span><br><span class="line">| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |</span><br><span class="line">| Bowser   | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |</span><br><span class="line">| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |</span><br><span class="line">| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |</span><br><span class="line">| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(sex) from pet; </span><br><span class="line">+------------+</span><br><span class="line">| count(sex) |</span><br><span class="line">+------------+</span><br><span class="line">|          7 |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(owner) from pet;   </span><br><span class="line">+--------------+</span><br><span class="line">| count(owner) |</span><br><span class="line">+--------------+</span><br><span class="line">|            8 |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(death) from pet;     </span><br><span class="line">+--------------+</span><br><span class="line">| count(death) |</span><br><span class="line">+--------------+</span><br><span class="line">|            1 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<h2 id="5-2、sum函数"><a href="#5-2、sum函数" class="headerlink" title="5.2、sum函数"></a>5.2、sum函数</h2><p><strong>语法：select sum(</strong>列名) from 表名;</p>
<p>注意事项：</p>
<p>1、如果使用sum 多列进行求和的时候，如果某一列中的有null，这一列所在的行中的其他数据不会被加到总和。</p>
<p>2、可以使用mysql 数据库提供的函数 ifnull(列名,值)</p>
<p>3、在数据库中定义double类型数据，是一个近似值，需要确定准确的位数，这时可以把这一列设计成numeric类型。numeric(数据的总列数,小数位数)</p>
<p>numericdouble float</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sum(price) from shop;  </span><br><span class="line">+------------+</span><br><span class="line">| sum(price) |</span><br><span class="line">+------------+</span><br><span class="line">|      42.77 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<h2 id="5-3、avg函数"><a href="#5-3、avg函数" class="headerlink" title="5.3、avg函数"></a>5.3、avg函数</h2><p>语法：select avg(列名) from 表名;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select avg(price) from shop;   </span><br><span class="line">+------------+</span><br><span class="line">| avg(price) |</span><br><span class="line">+------------+</span><br><span class="line">|   6.110000 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<h2 id="5-4、max函数"><a href="#5-4、max函数" class="headerlink" title="5.4、max函数"></a>5.4、max函数</h2><p>语法：select max(列名) from 表名;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(price) from shop;   </span><br><span class="line">+------------+</span><br><span class="line">| max(price) |</span><br><span class="line">+------------+</span><br><span class="line">|      19.95 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<h2 id="5-5、min函数"><a href="#5-5、min函数" class="headerlink" title="5.5、min函数"></a>5.5、min函数</h2><p>语法：select min(列名) from 表名;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select min(price) from shop;   </span><br><span class="line">+------------+</span><br><span class="line">| min(price) |</span><br><span class="line">+------------+</span><br><span class="line">|       1.25 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure>

<h1 id="6、SQL分类"><a href="#6、SQL分类" class="headerlink" title="6、SQL分类"></a>6、SQL分类</h1><h2 id="6-1、DDL-（数据定义问题）"><a href="#6-1、DDL-（数据定义问题）" class="headerlink" title="6.1、DDL （数据定义问题）"></a>6.1、DDL （数据定义问题）</h2><p>数据定义语言 - Data Definition Language</p>
<p>用来定义数据库的对象，如数据表、视图、索引等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建数据库：create database test;</span><br><span class="line">创建视图：create  view  test;</span><br><span class="line">创建索引：create index test;</span><br><span class="line">创建表：create table test1;</span><br></pre></td></tr></table></figure>

<h2 id="6-2、DML-（数据操纵问题）"><a href="#6-2、DML-（数据操纵问题）" class="headerlink" title="6.2、DML （数据操纵问题）"></a>6.2、DML （数据操纵问题）</h2><p>数据处理语言 - Data Manipulation Language</p>
<p>在数据库表中更新，增加和删除记录</p>
<p>如 update， insert， delete</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update tableName set age=&apos;18&apos; where name=&apos;lisi&apos;</span><br><span class="line"></span><br><span class="line">insert into tableName value(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;);</span><br><span class="line"></span><br><span class="line">drop table tableName //删除表操作</span><br></pre></td></tr></table></figure>

<h2 id="6-3、DCL-（数据控制问题）"><a href="#6-3、DCL-（数据控制问题）" class="headerlink" title="6.3、DCL （数据控制问题）"></a>6.3、DCL （数据控制问题）</h2><p>数据控制语言 – Data Control Language</p>
<p>指用于设置用户权限和控制事务语句</p>
<p>如grant，revoke，if…else，while，begintransaction</p>
<h2 id="6-4、DQL-（数据查询问题）"><a href="#6-4、DQL-（数据查询问题）" class="headerlink" title="6.4、DQL （数据查询问题）"></a>6.4、DQL （数据查询问题）</h2><p>数据查询语言 – Data Query Language</p>
<p>select</p>
<h2 id="6-5、小结"><a href="#6-5、小结" class="headerlink" title="6.5、小结"></a>6.5、小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、创建数据库：create database  itcast;</span><br><span class="line">2、使用数据库：use itcast;</span><br><span class="line">3、查看当前数据库中的所有表：show tables ;</span><br><span class="line">4、查看所有的数据库：show databases;</span><br><span class="line"></span><br><span class="line">5、删除数据库：drop database itcast;</span><br><span class="line">6、删除数据库中的表：drop table t1;</span><br></pre></td></tr></table></figure>

<h1 id="7、数据库的备份与恢复"><a href="#7、数据库的备份与恢复" class="headerlink" title="7、数据库的备份与恢复"></a>7、数据库的备份与恢复</h1><h2 id="7-1、备份命令"><a href="#7-1、备份命令" class="headerlink" title="7.1、备份命令"></a>7.1、备份命令</h2><p> 在mysql的安装目录的bin目录下有mysqldump命令，可以完成对数据库的备份。</p>
<p>语法：mysqldump -u 用户名 -p 数据库名&gt; 磁盘SQL文件路径</p>
<p>由于mysqldump命令不是sql命令，需要在dos窗口下使用。</p>
<p> 注意：在备份数据的时候，数据库不会被删除。可以手动删除数据库。同时在恢复数据的时候，不会</p>
<p>自动的给我们创建数据库，仅仅只会恢复数据库中的表和表中的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 menagerie &gt;/root/data/menagerie.sql</span><br><span class="line"></span><br><span class="line">//备份的文件</span><br><span class="line">-rw-r--r--. 1 root root 3118 Oct 20 04:04 menagerie.sql</span><br></pre></td></tr></table></figure>

<h2 id="7-2、恢复命令"><a href="#7-2、恢复命令" class="headerlink" title="7.2、恢复命令"></a>7.2、恢复命令</h2><p>恢复数据库，需要手动的先创建数据库：</p>
<p>create database heima2;</p>
<p>语法：mysql -u 用户名-p 导入库名&lt; 硬盘SQL文件绝对路径</p>
<p>需求：</p>
<p> 1、创建heima8数据库。</p>
<p> 2、重新开启一个新的dos窗口。</p>
<p> 3、将mydb2备份的数据表和表数据 恢复到mydb6中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//恢复命令</span><br><span class="line">mysql -uroot -p123456 itcast&lt;/root/data/menagerie.sql</span><br><span class="line"></span><br><span class="line">//恢复校验</span><br></pre></td></tr></table></figure>

<h1 id="8、多表查询"><a href="#8、多表查询" class="headerlink" title="8、多表查询"></a>8、多表查询</h1><h2 id="8-1、笛卡尔积介绍"><a href="#8-1、笛卡尔积介绍" class="headerlink" title="8.1、笛卡尔积介绍"></a>8.1、笛卡尔积介绍</h2><p> 笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员</p>
<p>准备数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create table A(</span><br><span class="line">  A_ID int primary key auto_increment,</span><br><span class="line">  A_NAME varchar(20) not null</span><br><span class="line">);</span><br><span class="line">insert into A values(1,&apos;apple&apos;);</span><br><span class="line">insert into A values(2,&apos;orange&apos;);</span><br><span class="line">insert into A values(3,&apos;banana&apos;);</span><br><span class="line"></span><br><span class="line">create table B( </span><br><span class="line">   A_ID int primary key auto_increment,</span><br><span class="line">   B_PRICE double</span><br><span class="line">);</span><br><span class="line">insert into B values(1,2.30);</span><br><span class="line">insert into B values(2,3.50);</span><br><span class="line">insert into B values(4,null);</span><br></pre></td></tr></table></figure>

<p>展示效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A,B;</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">| A_ID | A_NAME | A_ID | B_PRICE |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">|    1 | apple  |    1 |     2.3 |</span><br><span class="line">|    2 | orange |    1 |     2.3 |</span><br><span class="line">|    3 | banana |    1 |     2.3 |</span><br><span class="line">|    1 | apple  |    2 |     3.5 |</span><br><span class="line">|    2 | orange |    2 |     3.5 |</span><br><span class="line">|    3 | banana |    2 |     3.5 |</span><br><span class="line">|    1 | apple  |    4 |    NULL |</span><br><span class="line">|    2 | orange |    4 |    NULL |</span><br><span class="line">|    3 | banana |    4 |    NULL |</span><br><span class="line">+------+--------+------+---------+</span><br></pre></td></tr></table></figure>

<p>作用：笛卡尔积的数据，对程序是没有意义的，我们需要对笛卡尔积中的数据再次进行过滤。</p>
<p>对于多表查询操作，需要过滤出满足条件的数据，需要把多个表进行连接，连接之后需要加上过滤的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A,B where B.A_ID=1;</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">| A_ID | A_NAME | A_ID | B_PRICE |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">|    1 | apple  |    1 |     2.3 |</span><br><span class="line">|    2 | orange |    1 |     2.3 |</span><br><span class="line">|    3 | banana |    1 |     2.3 |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from A,B where B.A_ID=1 and A.A_ID=1;</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">| A_ID | A_NAME | A_ID | B_PRICE |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">|    1 | apple  |    1 |     2.3 |</span><br><span class="line">+------+--------+------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="8-2、内连接"><a href="#8-2、内连接" class="headerlink" title="8.2、内连接"></a>8.2、内连接</h2><p>内连接：<br>语法一：<br>select 列名 , 列名 …. from 表名1,表名2 where 表名1.列名 = 表名2.列名;</p>
<p>语法二：</p>
<p>select * from 表名1 inner join 表名2 on 条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A inner join B on A.A_ID=B.A_ID;</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">| A_ID | A_NAME | A_ID | B_PRICE |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">|    1 | apple  |    1 |     2.3 |</span><br><span class="line">|    2 | orange |    2 |     3.5 |</span><br><span class="line">+------+--------+------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="8-3、左外连接"><a href="#8-3、左外连接" class="headerlink" title="8.3、左外连接"></a>8.3、左外连接</h2><p>外链接：左外连接、右外连接、全连接、自连接。</p>
<p>左外连接：用左边表去右边表中查询对应记录，不管是否找到，都将显示左边表中全部记录。</p>
<p>即：虽然右表没有香蕉对应的价格，也要把他查询出来。</p>
<p>语法：select * from 表1 left outer join 表2 on 条件;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A left join B on A.A_ID=B.A_ID;</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">| A_ID | A_NAME | A_ID | B_PRICE |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">|    1 | apple  |    1 |     2.3 |</span><br><span class="line">|    2 | orange |    2 |     3.5 |</span><br><span class="line">|    3 | banana | NULL |    NULL |</span><br><span class="line">+------+--------+------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="8-4、右外连接"><a href="#8-4、右外连接" class="headerlink" title="8.4、右外连接"></a>8.4、右外连接</h2><p>用右边表去左边表查询对应记录，不管是否找到，右边表全部记录都将显示。</p>
<p>即：不管左方能够找到右方价格对应的水果，都要把左方的价格显示出来。</p>
<p>语法：select * from 表1 right outer join 表2 on 条件;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A right join B on A.A_ID=B.A_ID;     </span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">| A_ID | A_NAME | A_ID | B_PRICE |</span><br><span class="line">+------+--------+------+---------+</span><br><span class="line">|    1 | apple  |    1 |     2.3 |</span><br><span class="line">|    2 | orange |    2 |     3.5 |</span><br><span class="line">| NULL | NULL   |    4 |    NULL |</span><br><span class="line">+------+--------+------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="8-5、全外连接"><a href="#8-5、全外连接" class="headerlink" title="8.5、全外连接"></a>8.5、全外连接</h2><p>全外连接：左外连接和右外连接的结果合并，单会去掉重复的记录。<br>select * from 表1 full outer join 表2 on 条件<br>select * from a full outer join b on a.A_ID = b.A_ID; 但是mysql数据库不支持此语法。</p>
<h2 id="8-6、关联子查询"><a href="#8-6、关联子查询" class="headerlink" title="8.6、关联子查询"></a>8.6、关联子查询</h2><p>子查询：把一个sql的查询结果作为另外一个查询的参数存在。</p>
<h3 id="8-6-1、in和exist关键词的用法"><a href="#8-6-1、in和exist关键词的用法" class="headerlink" title="8.6.1、in和exist关键词的用法"></a>8.6.1、in和exist关键词的用法</h3><p>关联子查询其他的关键字使用：</p>
<p>回忆：age=23 or age=24 等价于 age in (23,24)</p>
<p>in 表示条件应该是在多个列值中。</p>
<p>in：使用在where后面，经常表示是一个列表中的数据，只要被查询的数据在这个列表中存在即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A where A_ID in(1,2,3);</span><br><span class="line">+------+--------+</span><br><span class="line">| A_ID | A_NAME |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | apple  |</span><br><span class="line">|    2 | orange |</span><br><span class="line">|    3 | banana |</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from A where A_ID =1 or A_ID =2 or A_ID =3;</span><br><span class="line">+------+--------+</span><br><span class="line">| A_ID | A_NAME |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | apple  |</span><br><span class="line">|    2 | orange |</span><br><span class="line">|    3 | banana |</span><br><span class="line">+------+--------+</span><br><span class="line">//not in</span><br><span class="line">mysql&gt; select * from A where A_ID not in (1,2,3,4);</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from A where A_ID not in (3,4);    </span><br><span class="line">+------+--------+</span><br><span class="line">| A_ID | A_NAME |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | apple  |</span><br><span class="line">|    2 | orange |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>exists：</p>
<p>exists：表示存在，当子查询的结果存在，就会显示主查询中的所有数据。</p>
<p>使用exists完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A where exists(select A_ID from B);</span><br><span class="line">+------+--------+</span><br><span class="line">| A_ID | A_NAME |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | apple  |</span><br><span class="line">|    2 | orange |</span><br><span class="line">|    3 | banana |</span><br><span class="line">+------+--------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from A where not exists(select A_ID from B);</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="8-6-2、union-和union-all使用法"><a href="#8-6-2、union-和union-all使用法" class="headerlink" title="8.6.2、union 和union all使用法"></a>8.6.2、union 和union all使用法</h3><p><strong>UNION 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）</p>
<p><strong>UNION ALL 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A  union   select * from B;   </span><br><span class="line">+------+--------+</span><br><span class="line">| A_ID | A_NAME |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | apple  |</span><br><span class="line">|    2 | orange |</span><br><span class="line">|    3 | banana |</span><br><span class="line">|    1 | 2.3    |</span><br><span class="line">|    2 | 3.5    |</span><br><span class="line">|    4 | NULL   |</span><br><span class="line">+------+--------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from A  union all  select * from B;</span><br><span class="line">+------+--------+</span><br><span class="line">| A_ID | A_NAME |</span><br><span class="line">+------+--------+</span><br><span class="line">|    1 | apple  |</span><br><span class="line">|    2 | orange |</span><br><span class="line">|    3 | banana |</span><br><span class="line">|    1 | 2.3    |</span><br><span class="line">|    2 | 3.5    |</span><br><span class="line">|    4 | NULL   |</span><br><span class="line">+------+--------+</span><br></pre></td></tr></table></figure>

<h3 id="8-6-3、case-when-语句"><a href="#8-6-3、case-when-语句" class="headerlink" title="8.6.3、case when 语句"></a>8.6.3、case when 语句</h3><p>case when 语句语法结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE sex  </span><br><span class="line">WHEN &apos;1&apos; THEN &apos;男&apos;  </span><br><span class="line">WHEN &apos;2&apos; THEN &apos;女&apos;  </span><br><span class="line">ELSE &apos;其他&apos; END</span><br></pre></td></tr></table></figure>

<p>准备数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//创建表</span><br><span class="line">create table employee(</span><br><span class="line">empid                   int  ,                                       </span><br><span class="line">deptid                  int   ,                                      </span><br><span class="line">sex                     varchar(20)  ,                                    </span><br><span class="line">salary                  double </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//加载数据</span><br><span class="line">1	10	female	5500.0</span><br><span class="line">2	10	male	4500.0</span><br><span class="line">3	20	female	1900.0</span><br><span class="line">4	20	male	4800.0</span><br><span class="line">5	40	female	6500.0</span><br><span class="line">6	40	female	14500.0</span><br><span class="line">7	40	male	44500.0</span><br><span class="line">8	50	male	6500.0</span><br><span class="line">9	50	male	7500.0</span><br><span class="line"></span><br><span class="line">load data local infile &apos;/root/data/emp.txt&apos; into table employee ;</span><br><span class="line">select *,</span><br><span class="line">case </span><br><span class="line">when salary &lt; 5000 then &quot;低等收入&quot; </span><br><span class="line">when salary&gt;= 5000 and salary &lt; 10000 then &quot;中等收入&quot;</span><br><span class="line">when salary &gt; 10000 then &quot;高等收入&quot;  </span><br><span class="line">end  as level,</span><br><span class="line">case sex</span><br><span class="line">when &quot;female&quot; then 1 </span><br><span class="line">when &quot;male&quot; then 0</span><br><span class="line">end as flag </span><br><span class="line">from employee;</span><br></pre></td></tr></table></figure>

<h1 id="9、MySQL-数据类型"><a href="#9、MySQL-数据类型" class="headerlink" title="9、MySQL 数据类型"></a>9、MySQL 数据类型</h1><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</p>
<p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h2 id="9-1、数值类型"><a href="#9-1、数值类型" class="headerlink" title="9.1、数值类型"></a>9.1、数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">范围（有符号）</th>
<th align="left">范围（无符号）</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 字节</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 字节</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 字节</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">4 字节</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 字节</td>
<td align="left">(-9 233 372 036 854 775 808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4 字节</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度浮点数值</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">8 字节</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度浮点数值</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-2、日期和时间类型"><a href="#9-2、日期和时间类型" class="headerlink" title="9.2、日期和时间类型"></a>9.2、日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小(字节)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left">YYYY-MM-DD HH:MM:SS</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong>秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<hr>
<h2 id="9-3、字符串类型"><a href="#9-3、字符串类型" class="headerlink" title="9.3、字符串类型"></a>9.3、字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 字节</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255字节</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255字节</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535字节</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>
<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>
<p>MySQL 5.0 以上的版本：</p>
<p>1、一个汉字占多少长度与编码有关：</p>
<p><strong>UTF－8</strong>：一个汉字＝3个字节</p>
<p><strong>GBK</strong>：一个汉字＝2个字节</p>
<p>2、varchar(n) 表示 n 个字符，无论汉字和英文，Mysql 都能存入 n 个字符，仅是实际字节长度有所区别</p>
<p>3、MySQL 检查长度，可用 SQL 语言来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select LENGTH(fieldname) from tablename</span><br></pre></td></tr></table></figure>

<p><strong>1、整型</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL数据类型</strong></th>
<th align="left"><strong>含义（有符号）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">tinyint(m)</td>
<td align="left">1个字节 范围(-128~127)</td>
</tr>
<tr>
<td align="left">smallint(m)</td>
<td align="left">2个字节 范围(-32768~32767)</td>
</tr>
<tr>
<td align="left">mediumint(m)</td>
<td align="left">3个字节 范围(-8388608~8388607)</td>
</tr>
<tr>
<td align="left">int(m)</td>
<td align="left">4个字节 范围(-2147483648~2147483647)</td>
</tr>
<tr>
<td align="left">bigint(m)</td>
<td align="left">8个字节 范围(+-9.22*10的18次方)</td>
</tr>
</tbody></table>
<p>取值范围如果加了 unsigned，则最大值翻倍，如 tinyint unsigned 的取值范围为(0~256)。</p>
<p>int(m) 里的 m 是表示 SELECT 查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个 m 有什么用。</p>
<p><strong>2、浮点型(float 和 double)</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL数据类型</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">float(m,d)</td>
<td align="left">单精度浮点型 8位精度(4字节) m总个数，d小数位</td>
</tr>
<tr>
<td align="left">double(m,d)</td>
<td align="left">双精度浮点型 16位精度(8字节) m总个数，d小数位</td>
</tr>
</tbody></table>
<p>设一个字段定义为 float(5,3)，如果插入一个数 123.45678,实际数据库里存的是 123.457，但总个数还以实际为准，即 6 位。</p>
<p><strong>3、定点数</strong></p>
<p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。</p>
<p>decimal(m,d) 参数 m&lt;65 是总个数，d&lt;30 且 d&lt;m 是小数位。</p>
<p><strong>4、字符串(char,varchar,_text)</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL数据类型</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">char(n)</td>
<td align="left">固定长度，最多255个字符</td>
</tr>
<tr>
<td align="left">varchar(n)</td>
<td align="left">固定长度，最多65535个字符</td>
</tr>
<tr>
<td align="left">tinytext</td>
<td align="left">可变长度，最多255个字符</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">可变长度，最多65535个字符</td>
</tr>
<tr>
<td align="left">mediumtext</td>
<td align="left">可变长度，最多2的24次方-1个字符</td>
</tr>
<tr>
<td align="left">longtext</td>
<td align="left">可变长度，最多2的32次方-1个字符</td>
</tr>
</tbody></table>
<p>char 和 varchar：</p>
<ul>
<li>** 1.char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。</li>
<li>** 2.char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，所以 varchar(4),存入 3 个字符将占用 4 个字节。</li>
<li>** 3.char 类型的字符串检索速度要比 varchar 类型的快。</li>
</ul>
<p>varchar 和 text：</p>
<ul>
<li>** 1.varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。</li>
<li>** 2.text 类型不能有默认值。</li>
<li>** 3.varchar 可直接创建索引，text 创建索引要指定前多少个字符。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。</li>
</ul>
<p><strong>5.二进制数据(_Blob)</strong></p>
<ul>
<li>** 1._BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。</li>
<li>** 2._BLOB存储的数据只能整体读出。</li>
<li>** 3._TEXT可以指定字符集，_BLOB不用指定字符集。</li>
</ul>
<p><strong>6.日期时间类型</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL数据类型</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">date</td>
<td align="left">日期 ‘2008-12-2’</td>
</tr>
<tr>
<td align="left">time</td>
<td align="left">时间 ‘12:25:36’</td>
</tr>
<tr>
<td align="left">datetime</td>
<td align="left">日期时间 ‘2008-12-2 22:06:44’</td>
</tr>
<tr>
<td align="left">timestamp</td>
<td align="left">自动存储记录修改时间</td>
</tr>
</tbody></table>
<p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p>
<p><strong>数据类型的属性</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>MySQL关键字</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">NULL</td>
<td align="left">数据列可包含NULL值</td>
</tr>
<tr>
<td align="left">NOT NULL</td>
<td align="left">数据列不允许包含NULL值</td>
</tr>
<tr>
<td align="left">DEFAULT</td>
<td align="left">默认值</td>
</tr>
<tr>
<td align="left">PRIMARY KEY</td>
<td align="left">主键</td>
</tr>
<tr>
<td align="left">AUTO_INCREMENT</td>
<td align="left">自动递增，适用于整数类型</td>
</tr>
<tr>
<td align="left">UNSIGNED</td>
<td align="left">无符号</td>
</tr>
<tr>
<td align="left">CHARACTER SET name</td>
<td align="left">指定一个字符集</td>
</tr>
</tbody></table>
<h1 id="10、MySQL-GROUP-BY-语句"><a href="#10、MySQL-GROUP-BY-语句" class="headerlink" title="10、MySQL GROUP BY 语句"></a>10、MySQL GROUP BY 语句</h1><p>GROUP BY 语句根据一个或多个列对结果集进行分组。</p>
<p>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p>
<p>语法结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure>

<p>准备数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employee_tbl` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` char(10) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `date` datetime NOT NULL,</span><br><span class="line">  `singin` tinyint(4) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;登录次数&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line"></span><br><span class="line">INSERT INTO `employee_tbl` VALUES (&apos;1&apos;, &apos;小明&apos;, &apos;2016-04-22 15:25:33&apos;, &apos;1&apos;), (&apos;2&apos;, &apos;小王&apos;, &apos;2016-04-20 15:25:47&apos;, &apos;3&apos;), (&apos;3&apos;, &apos;小丽&apos;, &apos;2016-04-19 15:26:02&apos;, &apos;2&apos;), (&apos;4&apos;, &apos;小王&apos;, &apos;2016-04-07 15:26:14&apos;, &apos;4&apos;), (&apos;5&apos;, &apos;小明&apos;, &apos;2016-04-11 15:26:40&apos;, &apos;4&apos;), (&apos;6&apos;, &apos;小明&apos;, &apos;2016-04-04 15:26:54&apos;, &apos;2&apos;);</span><br><span class="line">mysql&gt; SELECT name, COUNT(*) FROM   employee_tbl GROUP BY name;</span><br><span class="line">+--------+----------+</span><br><span class="line">| name   | COUNT(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 小丽 |        1 |</span><br><span class="line">| 小明 |        3 |</span><br><span class="line">| 小王 |        2 |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from employee_tbl;</span><br><span class="line">+----+------+---------------------+--------+</span><br><span class="line">| id | name | date                | singin |</span><br><span class="line">+----+------+---------------------+--------+</span><br><span class="line">|  1 | ??   | 2016-04-22 15:25:33 |      1 |</span><br><span class="line">|  2 | ??   | 2016-04-20 15:25:47 |      3 |</span><br><span class="line">|  3 | ??   | 2016-04-19 15:26:02 |      2 |</span><br><span class="line">|  4 | ??   | 2016-04-07 15:26:14 |      4 |</span><br><span class="line">|  5 | ??   | 2016-04-11 15:26:40 |      4 |</span><br><span class="line">|  6 | ??   | 2016-04-04 15:26:54 |      2 |</span><br><span class="line">+----+------+---------------------+--------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from employee_tbl group by singin;</span><br><span class="line">+----+------+---------------------+--------+</span><br><span class="line">| id | name | date                | singin |</span><br><span class="line">+----+------+---------------------+--------+</span><br><span class="line">|  1 | ??   | 2016-04-22 15:25:33 |      1 |</span><br><span class="line">|  3 | ??   | 2016-04-19 15:26:02 |      2 |</span><br><span class="line">|  2 | ??   | 2016-04-20 15:25:47 |      3 |</span><br><span class="line">|  4 | ??   | 2016-04-07 15:26:14 |      4 |</span><br><span class="line">+----+------+---------------------+--------+</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、group by 可以实现一个最简单的去重查询，假设想看下有哪些员工，除了用 distinct,还可以用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM employee_tbl GROUP BY name;</span><br></pre></td></tr></table></figure>

<p>返回的结果集就是所有员工的名字。</p>
<p>2、分组后的条件使用 HAVING 来限定，WHERE 是对原始数据进行条件限制。几个关键字的使用顺序为 where 、group by 、having、order by ，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name ,sum(*)  FROM employee_tbl WHERE id&lt;&gt;1 GROUP BY name  HAVING sum(*)&gt;5 ORDER BY sum(*) DESC;</span><br></pre></td></tr></table></figure>

<h1 id="11、MySQL-LIKE-子句"><a href="#11、MySQL-LIKE-子句" class="headerlink" title="11、MySQL LIKE 子句"></a>11、MySQL LIKE 子句</h1><p>我们知道在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。</p>
<p>WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “company = ‘itcast”。</p>
<p>但是有时候我们需要获取 company 字段含有 “it” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。</p>
<p>SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。</p>
<p>如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。</p>
<p>语法：</p>
<p>以下是 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li>你可以在 WHERE 子句中指定任何条件。</li>
<li>你可以在 WHERE 子句中使用LIKE子句。</li>
<li>你可以使用LIKE子句代替等号 =。</li>
<li>LIKE 通常与 % 一同使用，类似于一个元字符的搜索。</li>
<li>你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>你可以在 DELETE 或 UPDATE 命令中使用 WHERE…LIKE 子句来指定条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from pet where species like &apos;%d%&apos;;</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| name     | owner  | species | sex  | birth      | death      |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br><span class="line">| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |</span><br><span class="line">| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |</span><br><span class="line">| Bowser   | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |</span><br><span class="line">| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |</span><br><span class="line">| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |</span><br><span class="line">+----------+--------+---------+------+------------+------------+</span><br></pre></td></tr></table></figure>

<h1 id="12、MySQL-NULL-值处理"><a href="#12、MySQL-NULL-值处理" class="headerlink" title="12、MySQL NULL 值处理"></a>12、MySQL NULL 值处理</h1><p>我们已经知道 MySQL 使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。</p>
<p>为了处理这种情况，MySQL提供了三大运算符:</p>
<ul>
<li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li>
<li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</li>
<li><strong>&lt;=&gt;:</strong> 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</li>
</ul>
<p>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p>
<p>在 MySQL 中，NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false 。</p>
<p>MySQL 中处理 NULL 使用 IS NULL 和 IS NOT NULL 运算符。</p>
<h1 id="13、MySQL-元数据"><a href="#13、MySQL-元数据" class="headerlink" title="13、MySQL 元数据"></a>13、MySQL 元数据</h1><p>你可能想知道MySQL以下三种信息：</p>
<ul>
<li><strong>查询结果信息：</strong> SELECT, UPDATE 或 DELETE语句影响的记录数。</li>
<li><strong>数据库和数据表的信息：</strong> 包含了数据库及数据表的结构信息。</li>
<li><strong>MySQL服务器信息：</strong> 包含了数据库服务器的当前状态，版本号等。</li>
</ul>
<p>在MySQL的命令提示符中，我们可以很容易的获取以上服务器信息。</p>
<h2 id="获取服务器元数据"><a href="#获取服务器元数据" class="headerlink" title="获取服务器元数据"></a>获取服务器元数据</h2><p>以下命令语句可以在 MySQL 的命令提示符使用，也可以在脚本中 使用，如PHP脚本。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT VERSION( )</td>
<td align="left">服务器版本信息</td>
</tr>
<tr>
<td align="left">SELECT DATABASE( )</td>
<td align="left">当前数据库名 (或者返回空)</td>
</tr>
<tr>
<td align="left">SELECT USER( )</td>
<td align="left">当前用户名</td>
</tr>
<tr>
<td align="left">SHOW STATUS</td>
<td align="left">服务器状态</td>
</tr>
<tr>
<td align="left">SHOW VARIABLES</td>
<td align="left">服务器配置变量</td>
</tr>
</tbody></table>
<h1 id="14、MySQL-ALTER命令"><a href="#14、MySQL-ALTER命令" class="headerlink" title="14、MySQL ALTER命令"></a>14、MySQL ALTER命令</h1><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p>
<h2 id="14-1、删除、添加或修改表字段"><a href="#14-1、删除、添加或修改表字段" class="headerlink" title="14.1、删除、添加或修改表字段"></a>14.1、删除、添加或修改表字段</h2><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl  DROP i;</span><br></pre></td></tr></table></figure>

<p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p>
<p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD i INT;</span><br></pre></td></tr></table></figure>

<p>执行以上命令后，i 字段会自动添加到数据表字段的末尾</p>
<h2 id="14-2、修改字段类型及名称"><a href="#14-2、修改字段类型及名称" class="headerlink" title="14.2、修改字段类型及名称"></a>14.2、修改字段类型及名称</h2><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p>
<p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);</span><br></pre></td></tr></table></figure>

<h2 id="14-3、修改表名"><a href="#14-3、修改表名" class="headerlink" title="14.3、修改表名"></a>14.3、修改表名</h2><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p>
<p>尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl;</span><br></pre></td></tr></table></figure>

<h1 id="15、MySQL-函数"><a href="#15、MySQL-函数" class="headerlink" title="15、MySQL 函数"></a>15、MySQL 函数</h1><p>MySQL 有很多内置的函数，以下列出了这些函数的说明。</p>
<h2 id="15-1、MySQL-字符串函数"><a href="#15-1、MySQL-字符串函数" class="headerlink" title="15.1、MySQL 字符串函数"></a>15.1、MySQL 字符串函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ASCII(s)</td>
<td align="left">返回字符串 s 的第一个字符的 ASCII 码。</td>
<td align="left">返回 CustomerName 字段第一个字母的 ASCII 码：<code>SELECT ASCII(CustomerName) AS NumCodeOfFirstCharFROM Customers;</code></td>
</tr>
<tr>
<td align="left">CHAR_LENGTH(s)</td>
<td align="left">返回字符串 s 的字符数</td>
<td align="left">返回字符串 itcast 的字符数<code>SELECT CHAR_LENGTH(&quot;itcast&quot;) AS LengthOfString;</code></td>
</tr>
<tr>
<td align="left">CHARACTER_LENGTH(s)</td>
<td align="left">返回字符串 s 的字符数</td>
<td align="left">返回字符串 itcast 的字符数<code>SELECT CHARACTER_LENGTH(&quot;itcast&quot;) AS LengthOfString;</code></td>
</tr>
<tr>
<td align="left">CONCAT(s1,s2…sn)</td>
<td align="left">字符串 s1,s2 等多个字符串合并为一个字符串</td>
<td align="left">合并多个字符串<code>SELECT CONCAT(&quot;SQL &quot;, &quot;itcast &quot;, &quot;Gooogle &quot;, &quot;Facebook&quot;) AS ConcatenatedString;</code></td>
</tr>
<tr>
<td align="left">CONCAT_WS(x, s1,s2…sn)</td>
<td align="left">同 CONCAT(s1,s2,…) 函数，但是每个字符串直接要加上 x，x 可以是分隔符</td>
<td align="left">合并多个字符串，并添加分隔符：<code>SELECT CONCAT_WS(&quot;-&quot;, &quot;SQL&quot;, &quot;Tutorial&quot;, &quot;is&quot;, &quot;fun!&quot;)AS ConcatenatedString;</code></td>
</tr>
<tr>
<td align="left">FIELD(s,s1,s2…)</td>
<td align="left">返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</td>
<td align="left">返回字符串 c 在列表值中的位置：<code>SELECT FIELD(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);</code></td>
</tr>
<tr>
<td align="left">FIND_IN_SET(s1,s2)</td>
<td align="left">返回在字符串s2中与s1匹配的字符串的位置</td>
<td align="left">返回字符串 c 在指定字符串中的位置：<code>SELECT FIND_IN_SET(&quot;c&quot;, &quot;a,b,c,d,e&quot;);</code></td>
</tr>
<tr>
<td align="left">FORMAT(x,n)</td>
<td align="left">函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。</td>
<td align="left">格式化数字 “#,###.##” 形式：<code>SELECT FORMAT(250500.5634, 2); -- 输出 250,500.56</code></td>
</tr>
<tr>
<td align="left">INSERT(s1,x,len,s2)</td>
<td align="left">字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串</td>
<td align="left">从字符串第一个位置开始的 6 个字符替换为 itcast：<code>SELECT INSERT(&quot;google.com&quot;, 1, 6, &quot;runnob&quot;); -- 输出：itcast.com</code></td>
</tr>
<tr>
<td align="left">LOCATE(s1,s)</td>
<td align="left">从字符串 s 中获取 s1 的开始位置</td>
<td align="left">获取 b 在字符串 abc 中的位置：<code>SELECT INSTR(&#39;abc&#39;,&#39;b&#39;) -- 2</code></td>
</tr>
<tr>
<td align="left">LCASE(s)</td>
<td align="left">将字符串 s 的所有字母变成小写字母</td>
<td align="left">字符串 itcast 转换为小写：<code>SELECT LOWER(&#39;itcast&#39;) -- itcast</code></td>
</tr>
<tr>
<td align="left">LEFT(s,n)</td>
<td align="left">返回字符串 s 的前 n 个字符</td>
<td align="left">返回字符串 itcast 中的前两个字符：<code>SELECT LEFT(&#39;itcast&#39;,2) -- it</code></td>
</tr>
<tr>
<td align="left">LEFT(s,n)</td>
<td align="left">返回字符串 s 的前 n 个字符</td>
<td align="left">返回字符串 abcde 的前两个字符：<code>SELECT LEFT(&#39;abcde&#39;,2) -- ab</code></td>
</tr>
<tr>
<td align="left">LOCATE(s1,s)</td>
<td align="left">从字符串 s 中获取 s1 的开始位置</td>
<td align="left">返回字符串 abc 中 b 的位置：<code>SELECT LOCATE(&#39;b&#39;, &#39;abc&#39;) -- 2</code></td>
</tr>
<tr>
<td align="left">LOWER(s)</td>
<td align="left">将字符串 s 的所有字母变成小写字母</td>
<td align="left">字符串 itcast 转换为小写：<code>SELECT LOWER(&#39;itcast&#39;) -- itcast</code></td>
</tr>
<tr>
<td align="left">LPAD(s1,len,s2)</td>
<td align="left">在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len</td>
<td align="left">将字符串 xx 填充到 abc 字符串的开始处：<code>SELECT LPAD(&#39;abc&#39;,5,&#39;xx&#39;) -- xxabc</code></td>
</tr>
<tr>
<td align="left">LTRIM(s)</td>
<td align="left">去掉字符串 s 开始处的空格</td>
<td align="left">去掉字符串 itcast开始处的空格：<code>SELECT LTRIM(&quot; itcast&quot;) AS LeftTrimmedString;-- itcast</code></td>
</tr>
<tr>
<td align="left">MID(s,n,len)</td>
<td align="left">从字符串 s 的 start 位置截取长度为 length 的子字符串，同 SUBSTRING(s,n,len)</td>
<td align="left">从字符串 itcast 中的第 2 个位置截取 3个 字符：<code>SELECT MID(&quot;itcast&quot;, 2, 3) AS ExtractString; -- UNO</code></td>
</tr>
<tr>
<td align="left">POSITION(s1 IN s)</td>
<td align="left">从字符串 s 中获取 s1 的开始位置</td>
<td align="left">返回字符串 abc 中 b 的位置：<code>SELECT POSITION(&#39;b&#39; in &#39;abc&#39;) -- 2</code></td>
</tr>
<tr>
<td align="left">REPEAT(s,n)</td>
<td align="left">将字符串 s 重复 n 次</td>
<td align="left">将字符串 itcast 重复三次：<code>SELECT REPEAT(&#39;itcast&#39;,3) -- itcastitcastitcast</code></td>
</tr>
<tr>
<td align="left">REPLACE(s,s1,s2)</td>
<td align="left">将字符串 s2 替代字符串 s 中的字符串 s1</td>
<td align="left">将字符串 abc 中的字符 a 替换为字符 x：<code>SELECT REPLACE(&#39;abc&#39;,&#39;a&#39;,&#39;x&#39;) --xbc</code></td>
</tr>
<tr>
<td align="left">REVERSE(s)</td>
<td align="left">将字符串s的顺序反过来</td>
<td align="left">将字符串 abc 的顺序反过来：<code>SELECT REVERSE(&#39;abc&#39;) -- cba</code></td>
</tr>
<tr>
<td align="left">RIGHT(s,n)</td>
<td align="left">返回字符串 s 的后 n 个字符</td>
<td align="left">返回字符串 itcast 的后两个字符：<code>SELECT RIGHT(&#39;itcast&#39;,2) -- ob</code></td>
</tr>
<tr>
<td align="left">RPAD(s1,len,s2)</td>
<td align="left">在字符串 s1 的结尾处添加字符串 s1，使字符串的长度达到 len</td>
<td align="left">将字符串 xx 填充到 abc 字符串的结尾处：<code>SELECT RPAD(&#39;abc&#39;,5,&#39;xx&#39;) -- abcxx</code></td>
</tr>
<tr>
<td align="left">RTRIM(s)</td>
<td align="left">去掉字符串 s 结尾处的空格</td>
<td align="left">去掉字符串 itcast 的末尾空格：<code>SELECT RTRIM(&quot;itcast &quot;) AS RightTrimmedString; -- itcast</code></td>
</tr>
<tr>
<td align="left">SPACE(n)</td>
<td align="left">返回 n 个空格</td>
<td align="left">返回 10 个空格：<code>SELECT SPACE(10);</code></td>
</tr>
<tr>
<td align="left">STRCMP(s1,s2)</td>
<td align="left">比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1</td>
<td align="left">比较字符串：<code>SELECT STRCMP(&quot;itcast&quot;, &quot;itcast&quot;); -- 0</code></td>
</tr>
<tr>
<td align="left">SUBSTR(s, start, length)</td>
<td align="left">从字符串 s 的 start 位置截取长度为 length 的子字符串</td>
<td align="left">从字符串 itcast 中的第 2 个位置截取 3个 字符：<code>SELECT SUBSTR(&quot;itcast&quot;, 2, 3) AS ExtractString; -- UNO</code></td>
</tr>
<tr>
<td align="left">SUBSTRING(s, start, length)</td>
<td align="left">从字符串 s 的 start 位置截取长度为 length 的子字符串</td>
<td align="left">从字符串 itcast 中的第 2 个位置截取 3个 字符：<code>SELECT SUBSTRING(&quot;itcast&quot;, 2, 3) AS ExtractString; -- UNO</code></td>
</tr>
<tr>
<td align="left">SUBSTRING_INDEX(s, delimiter, number)</td>
<td align="left">返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。如果 number 是正数，返回第 number 个字符左边的字符串。如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。</td>
<td align="left"><code>SELECT SUBSTRING_INDEX(&#39;a*b&#39;,&#39;*&#39;,1) -- aSELECT SUBSTRING_INDEX(&#39;a*b&#39;,&#39;*&#39;,-1) -- bSELECT SUBSTRING_INDEX(SUBSTRING_INDEX(&#39;a*b*c*d*e&#39;,&#39;*&#39;,3),&#39;*&#39;,-1) -- c</code></td>
</tr>
<tr>
<td align="left">TRIM(s)</td>
<td align="left">去掉字符串 s 开始和结尾处的空格</td>
<td align="left">去掉字符串 itcast 的首尾空格：<code>SELECT TRIM(&#39; itcast &#39;) AS TrimmedString;</code></td>
</tr>
<tr>
<td align="left">UCASE(s)</td>
<td align="left">将字符串转换为大写</td>
<td align="left">将字符串 itcast 转换为大写：<code>SELECT UCASE(&quot;itcast&quot;); -- itcast</code></td>
</tr>
<tr>
<td align="left">UPPER(s)</td>
<td align="left">将字符串转换为大写</td>
<td align="left">将字符串 itcast 转换为大写：<code>SELECT UPPER(&quot;itcast&quot;); -- itcast</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="15-2、MySQL-数字函数"><a href="#15-2、MySQL-数字函数" class="headerlink" title="15.2、MySQL 数字函数"></a>15.2、MySQL 数字函数</h2><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ABS(x)</td>
<td align="left">返回 x 的绝对值</td>
<td align="left">返回 -1 的绝对值：<code>SELECT ABS(-1) -- 返回1</code></td>
</tr>
<tr>
<td align="left">ACOS(x)</td>
<td align="left">求 x 的反余弦值(参数是弧度)</td>
<td align="left"><code>SELECT ACOS(0.25);</code></td>
</tr>
<tr>
<td align="left">ASIN(x)</td>
<td align="left">求反正弦值(参数是弧度)</td>
<td align="left"><code>SELECT ASIN(0.25);</code></td>
</tr>
<tr>
<td align="left">ATAN(x)</td>
<td align="left">求反正切值(参数是弧度)</td>
<td align="left"><code>SELECT ATAN(2.5);</code></td>
</tr>
<tr>
<td align="left">ATAN2(n, m)</td>
<td align="left">求反正切值(参数是弧度)</td>
<td align="left"><code>SELECT ATAN2(-0.8, 2);</code></td>
</tr>
<tr>
<td align="left">AVG(expression)</td>
<td align="left">返回一个表达式的平均值，expression 是一个字段</td>
<td align="left">返回 Products 表中Price 字段的平均值：<code>SELECT AVG(Price) AS AveragePrice FROM Products;</code></td>
</tr>
<tr>
<td align="left">CEIL(x)</td>
<td align="left">返回大于或等于 x 的最小整数</td>
<td align="left"><code>SELECT CEIL(1.5) -- 返回2</code></td>
</tr>
<tr>
<td align="left">CEILING(x)</td>
<td align="left">返回大于或等于 x 的最小整数</td>
<td align="left"><code>SELECT CEIL(1.5) -- 返回2</code></td>
</tr>
<tr>
<td align="left">COS(x)</td>
<td align="left">求余弦值(参数是弧度)</td>
<td align="left"><code>SELECT COS(2);</code></td>
</tr>
<tr>
<td align="left">COT(x)</td>
<td align="left">求余切值(参数是弧度)</td>
<td align="left"><code>SELECT COT(6);</code></td>
</tr>
<tr>
<td align="left">COUNT(expression)</td>
<td align="left">返回查询的记录总数，expression 参数是一个字段或者 * 号</td>
<td align="left">返回 Products 表中 products 字段总共有多少条记录：<code>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</code></td>
</tr>
<tr>
<td align="left">DEGREES(x)</td>
<td align="left">将弧度转换为角度</td>
<td align="left"><code>SELECT DEGREES(3.1415926535898) -- 180</code></td>
</tr>
<tr>
<td align="left">n DIV m</td>
<td align="left">整除，n 为被除数，m 为除数</td>
<td align="left">计算 10 除于 5：<code>SELECT 10 DIV 5; -- 2</code></td>
</tr>
<tr>
<td align="left">EXP(x)</td>
<td align="left">返回 e 的 x 次方</td>
<td align="left">计算 e 的三次方：<code>SELECT EXP(3) -- 20.085536923188</code></td>
</tr>
<tr>
<td align="left">FLOOR(x)</td>
<td align="left">返回小于或等于 x 的最大整数</td>
<td align="left">小于或等于 1.5 的整数：<code>SELECT FLOOR(1.5) -- 返回1</code></td>
</tr>
<tr>
<td align="left">GREATEST(expr1, expr2, expr3, …)</td>
<td align="left">返回列表中的最大值</td>
<td align="left">返回以下数字列表中的最大值：<code>SELECT GREATEST(3, 12, 34, 8, 25); -- 34</code>返回以下字符串列表中的最大值：<code>SELECT GREATEST(&quot;Google&quot;, &quot;itcast&quot;, &quot;Apple&quot;); -- itcast</code></td>
</tr>
<tr>
<td align="left">LEAST(expr1, expr2, expr3, …)</td>
<td align="left">返回列表中的最小值</td>
<td align="left">返回以下数字列表中的最小值：<code>SELECT LEAST(3, 12, 34, 8, 25); -- 3</code>返回以下字符串列表中的最小值：<code>SELECT LEAST(&quot;Google&quot;, &quot;itcast&quot;, &quot;Apple&quot;); -- Apple</code></td>
</tr>
<tr>
<td align="left"><a href="http://www.itcast.com/mysql/func_mysql_ln.asp" target="_blank" rel="noopener">LN</a></td>
<td align="left">返回数字的自然对数</td>
<td align="left">返回 2 的自然对数：<code>SELECT LN(2); -- 0.6931471805599453</code></td>
</tr>
<tr>
<td align="left">LOG(x)</td>
<td align="left">返回自然对数(以 e 为底的对数)</td>
<td align="left"><code>SELECT LOG(20.085536923188) -- 3</code></td>
</tr>
<tr>
<td align="left">LOG10(x)</td>
<td align="left">返回以 10 为底的对数</td>
<td align="left"><code>SELECT LOG10(100) -- 2</code></td>
</tr>
<tr>
<td align="left">LOG2(x)</td>
<td align="left">返回以 2 为底的对数</td>
<td align="left">返回以 2 为底 6 的对数：<code>SELECT LOG2(6); -- 2.584962500721156</code></td>
</tr>
<tr>
<td align="left">MAX(expression)</td>
<td align="left">返回字段 expression 中的最大值</td>
<td align="left">返回数据表 Products 中字段 Price 的最大值：<code>SELECT MAX(Price) AS LargestPrice FROM Products;</code></td>
</tr>
<tr>
<td align="left">MIN(expression)</td>
<td align="left">返回字段 expression 中的最小值</td>
<td align="left">返回数据表 Products 中字段 Price 的最小值：<code>SELECT MIN(Price) AS LargestPrice FROM Products;</code></td>
</tr>
<tr>
<td align="left">MOD(x,y)</td>
<td align="left">返回 x 除以 y 以后的余数</td>
<td align="left">5 除于 2 的余数：<code>SELECT MOD(5,2) -- 1</code></td>
</tr>
<tr>
<td align="left">PI()</td>
<td align="left">返回圆周率(3.141593）</td>
<td align="left"><code>SELECT PI() --3.141593</code></td>
</tr>
<tr>
<td align="left">POW(x,y)</td>
<td align="left">返回 x 的 y 次方</td>
<td align="left">2 的 3 次方：<code>SELECT POW(2,3) -- 8</code></td>
</tr>
<tr>
<td align="left">POWER(x,y)</td>
<td align="left">返回 x 的 y 次方</td>
<td align="left">2 的 3 次方：<code>SELECT POWER(2,3) -- 8</code></td>
</tr>
<tr>
<td align="left">RADIANS(x)</td>
<td align="left">将角度转换为弧度</td>
<td align="left">180 度转换为弧度：<code>SELECT RADIANS(180) -- 3.1415926535898</code></td>
</tr>
<tr>
<td align="left">RAND()</td>
<td align="left">返回 0 到 1 的随机数</td>
<td align="left"><code>SELECT RAND() --0.93099315644334</code></td>
</tr>
<tr>
<td align="left">ROUND(x)</td>
<td align="left">返回离 x 最近的整数</td>
<td align="left"><code>SELECT ROUND(1.23456) --1</code></td>
</tr>
<tr>
<td align="left">SIGN(x)</td>
<td align="left">返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1</td>
<td align="left"><code>SELECT SIGN(-10) -- (-1)</code></td>
</tr>
<tr>
<td align="left">SIN(x)</td>
<td align="left">求正弦值(参数是弧度)</td>
<td align="left"><code>SELECT SIN(RADIANS(30)) -- 0.5</code></td>
</tr>
<tr>
<td align="left">SQRT(x)</td>
<td align="left">返回x的平方根</td>
<td align="left">25 的平方根：<code>SELECT SQRT(25) -- 5</code></td>
</tr>
<tr>
<td align="left">SUM(expression)</td>
<td align="left">返回指定字段的总和</td>
<td align="left">计算 OrderDetails 表中字段 Quantity 的总和：<code>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</code></td>
</tr>
<tr>
<td align="left">TAN(x)</td>
<td align="left">求正切值(参数是弧度)</td>
<td align="left"><code>SELECT TAN(1.75); -- -5.52037992250933</code></td>
</tr>
<tr>
<td align="left">TRUNCATE(x,y)</td>
<td align="left">返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）</td>
<td align="left"><code>SELECT TRUNCATE(1.23456,3) -- 1.234</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="15-3、MySQL-日期函数"><a href="#15-3、MySQL-日期函数" class="headerlink" title="15.3、MySQL 日期函数"></a>15.3、MySQL 日期函数</h2><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ADDDATE(d,n)</td>
<td align="left">计算其实日期 d 加上 n 天的日期</td>
<td align="left"><code>SELECT ADDDATE(&quot;2017-06-15&quot;, INTERVAL 10 DAY);-&gt;2017-06-25</code></td>
</tr>
<tr>
<td align="left">ADDTIME(t,n)</td>
<td align="left">时间 t 加上 n 秒的时间</td>
<td align="left"><code>SELECT ADDTIME(&#39;2011-11-11 11:11:11&#39;, 5)-&gt;2011-11-11 11:11:16 (秒)</code></td>
</tr>
<tr>
<td align="left">CURDATE()</td>
<td align="left">返回当前日期</td>
<td align="left"><code>SELECT CURDATE();-&gt; 2018-09-19</code></td>
</tr>
<tr>
<td align="left">CURRENT_DATE()</td>
<td align="left">返回当前日期</td>
<td align="left"><code>SELECT CURRENT_DATE();-&gt; 2018-09-19</code></td>
</tr>
<tr>
<td align="left">CURRENT_TIME</td>
<td align="left">返回当前时间</td>
<td align="left"><code>SELECT CURRENT_TIME();-&gt; 19:59:02</code></td>
</tr>
<tr>
<td align="left">CURRENT_TIMESTAMP()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT CURRENT_TIMESTAMP()-&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">CURTIME()</td>
<td align="left">返回当前时间</td>
<td align="left"><code>SELECT CURTIME();-&gt; 19:59:02</code></td>
</tr>
<tr>
<td align="left">DATE()</td>
<td align="left">从日期或日期时间表达式中提取日期值</td>
<td align="left"><code>SELECT DATE(&quot;2017-06-15&quot;); -&gt; 2017-06-15</code></td>
</tr>
<tr>
<td align="left">DATEDIFF(d1,d2)</td>
<td align="left">计算日期 d1-&gt;d2 之间相隔的天数</td>
<td align="left"><code>SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;)-&gt; -32</code></td>
</tr>
<tr>
<td align="left">DATE_ADD(d，INTERVAL expr type)</td>
<td align="left">计算起始日期 d 加上一个时间段后的日期</td>
<td align="left"><code>SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;,1)-&gt; 2011-11-12 11:11:11 (默认是天)SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;, INTERVAL 5 MINUTE)-&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似)</code></td>
</tr>
<tr>
<td align="left">DATE_FORMAT(d,f)</td>
<td align="left">按表达式 f的要求显示日期 d</td>
<td align="left"><code>SELECT DATE_FORMAT(&#39;2011-11-11 11:11:11&#39;,&#39;%Y-%m-%d %r&#39;)-&gt; 2011-11-11 11:11:11 AM</code></td>
</tr>
<tr>
<td align="left">DATE_SUB(date,INTERVAL expr type)</td>
<td align="left">函数从日期减去指定的时间间隔。</td>
<td align="left">Orders 表中 OrderDate 字段减去 2 天：<code>SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDateFROM Orders</code></td>
</tr>
<tr>
<td align="left">DAY(d)</td>
<td align="left">返回日期值 d 的日期部分</td>
<td align="left"><code>SELECT DAY(&quot;2017-06-15&quot;); -&gt; 15</code></td>
</tr>
<tr>
<td align="left">DAYNAME(d)</td>
<td align="left">返回日期 d 是星期几，如 Monday,Tuesday</td>
<td align="left"><code>SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;)-&gt;Friday</code></td>
</tr>
<tr>
<td align="left">DAYOFMONTH(d)</td>
<td align="left">计算日期 d 是本月的第几天</td>
<td align="left"><code>SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;)-&gt;11</code></td>
</tr>
<tr>
<td align="left">DAYOFWEEK(d)</td>
<td align="left">日期 d 今天是星期几，1 星期日，2 星期一，以此类推</td>
<td align="left"><code>SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;)-&gt;6</code></td>
</tr>
<tr>
<td align="left">DAYOFYEAR(d)</td>
<td align="left">计算日期 d 是本年的第几天</td>
<td align="left"><code>SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;)-&gt;315</code></td>
</tr>
<tr>
<td align="left">EXTRACT(type FROM d)</td>
<td align="left">从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARSECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH</td>
<td align="left"><code>SELECT EXTRACT(MINUTE FROM &#39;2011-11-11 11:11:11&#39;) -&gt; 11</code></td>
</tr>
<tr>
<td align="left">ROM_DAYS(n)</td>
<td align="left">计算从 0000 年 1 月 1 日开始 n 天后的日期</td>
<td align="left"><code>SELECT FROM_DAYS(1111)-&gt; 0003-01-16</code></td>
</tr>
<tr>
<td align="left">HOUR(t)</td>
<td align="left">返回 t 中的小时值</td>
<td align="left"><code>SELECT HOUR(&#39;1:2:3&#39;)-&gt; 1</code></td>
</tr>
<tr>
<td align="left">LAST_DAY(d)</td>
<td align="left">返回给给定日期的那一月份的最后一天</td>
<td align="left"><code>SELECT LAST_DAY(&quot;2017-06-20&quot;);-&gt; 2017-06-30</code></td>
</tr>
<tr>
<td align="left">LOCALTIME()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT LOCALTIME()-&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">LOCALTIMESTAMP()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT LOCALTIMESTAMP()-&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">MAKEDATE(year, day-of-year)</td>
<td align="left">基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期</td>
<td align="left"><code>SELECT MAKEDATE(2017, 3);-&gt; 2017-01-03</code></td>
</tr>
<tr>
<td align="left">MAKETIME(hour, minute, second)</td>
<td align="left">组合时间，参数分别为小时、分钟、秒</td>
<td align="left"><code>SELECT MAKETIME(11, 35, 4);-&gt; 11:35:04</code></td>
</tr>
<tr>
<td align="left">MICROSECOND(date)</td>
<td align="left">返回日期参数所对应的毫秒数</td>
<td align="left"><code>SELECT MICROSECOND(&quot;2017-06-20 09:34:00.000023&quot;);-&gt; 23</code></td>
</tr>
<tr>
<td align="left">MINUTE(t)</td>
<td align="left">返回 t 中的分钟值</td>
<td align="left"><code>SELECT MINUTE(&#39;1:2:3&#39;)-&gt; 2</code></td>
</tr>
<tr>
<td align="left">MONTHNAME(d)</td>
<td align="left">返回日期当中的月份名称，如 Janyary</td>
<td align="left"><code>SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;)-&gt; November</code></td>
</tr>
<tr>
<td align="left">MONTH(d)</td>
<td align="left">返回日期d中的月份值，1 到 12</td>
<td align="left"><code>SELECT MONTH(&#39;2011-11-11 11:11:11&#39;)-&gt;11</code></td>
</tr>
<tr>
<td align="left">NOW()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT NOW()-&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">PERIOD_ADD(period, number)</td>
<td align="left">为 年-月 组合日期添加一个时段</td>
<td align="left"><code>SELECT PERIOD_ADD(201703, 5); -&gt; 201708</code></td>
</tr>
<tr>
<td align="left">PERIOD_DIFF(period1, period2)</td>
<td align="left">返回两个时段之间的月份差值</td>
<td align="left"><code>SELECT PERIOD_DIFF(201710, 201703);-&gt; 7</code></td>
</tr>
<tr>
<td align="left">QUARTER(d)</td>
<td align="left">返回日期d是第几季节，返回 1 到 4</td>
<td align="left"><code>SELECT QUARTER(&#39;2011-11-11 11:11:11&#39;)-&gt; 4</code></td>
</tr>
<tr>
<td align="left">SECOND(t)</td>
<td align="left">返回 t 中的秒钟值</td>
<td align="left"><code>SELECT SECOND(&#39;1:2:3&#39;)-&gt; 3</code></td>
</tr>
<tr>
<td align="left">SEC_TO_TIME(s)</td>
<td align="left">将以秒为单位的时间 s 转换为时分秒的格式</td>
<td align="left"><code>SELECT SEC_TO_TIME(4320)-&gt; 01:12:00</code></td>
</tr>
<tr>
<td align="left">STR_TO_DATE(string, format_mask)</td>
<td align="left">将字符串转变为日期</td>
<td align="left"><code>SELECT STR_TO_DATE(&quot;August 10 2017&quot;, &quot;%M %d %Y&quot;);-&gt; 2017-08-10</code></td>
</tr>
<tr>
<td align="left">SUBDATE(d,n)</td>
<td align="left">日期 d 减去 n 天后的日期</td>
<td align="left"><code>SELECT SUBDATE(&#39;2011-11-11 11:11:11&#39;, 1)-&gt;2011-11-10 11:11:11 (默认是天)</code></td>
</tr>
<tr>
<td align="left">SUBTIME(t,n)</td>
<td align="left">时间 t 减去 n 秒的时间</td>
<td align="left"><code>SELECT SUBTIME(&#39;2011-11-11 11:11:11&#39;, 5)-&gt;2011-11-11 11:11:06 (秒)</code></td>
</tr>
<tr>
<td align="left">SYSDATE()</td>
<td align="left">返回当前日期和时间</td>
<td align="left"><code>SELECT SYSDATE()-&gt; 2018-09-19 20:57:43</code></td>
</tr>
<tr>
<td align="left">TIME(expression)</td>
<td align="left">提取传入表达式的时间部分</td>
<td align="left"><code>SELECT TIME(&quot;19:30:10&quot;);-&gt; 19:30:10</code></td>
</tr>
<tr>
<td align="left">TIME_FORMAT(t,f)</td>
<td align="left">按表达式 f 的要求显示时间 t</td>
<td align="left"><code>SELECT TIME_FORMAT(&#39;11:11:11&#39;,&#39;%r&#39;)11:11:11 AM</code></td>
</tr>
<tr>
<td align="left">TIME_TO_SEC(t)</td>
<td align="left">将时间 t 转换为秒</td>
<td align="left"><code>SELECT TIME_TO_SEC(&#39;1:12:00&#39;)-&gt; 4320</code></td>
</tr>
<tr>
<td align="left">TIMEDIFF(time1, time2)</td>
<td align="left">计算时间差值</td>
<td align="left"><code>SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;);-&gt; 00:00:01</code></td>
</tr>
<tr>
<td align="left">TIMESTAMP(expression, interval)</td>
<td align="left">单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和</td>
<td align="left"><code>SELECT TIMESTAMP(&quot;2017-07-23&quot;, &quot;13:10:11&quot;);-&gt; 2017-07-23 13:10:11</code></td>
</tr>
<tr>
<td align="left">TO_DAYS(d)</td>
<td align="left">计算日期 d 距离 0000 年 1 月 1 日的天数</td>
<td align="left"><code>SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;)-&gt; 366</code></td>
</tr>
<tr>
<td align="left">WEEK(d)</td>
<td align="left">计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
<td align="left"><code>SELECT WEEK(&#39;2011-11-11 11:11:11&#39;)-&gt; 45</code></td>
</tr>
<tr>
<td align="left">WEEKDAY(d)</td>
<td align="left">日期 d 是星期几，0 表示星期一，1 表示星期二</td>
<td align="left"><code>SELECT WEEKDAY(&quot;2017-06-15&quot;);-&gt; 3</code></td>
</tr>
<tr>
<td align="left">WEEKOFYEAR(d)</td>
<td align="left">计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
<td align="left"><code>SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;)-&gt; 45</code></td>
</tr>
<tr>
<td align="left">YEAR(d)</td>
<td align="left">返回年份</td>
<td align="left"><code>SELECT YEAR(&quot;2017-06-15&quot;);-&gt; 2017</code></td>
</tr>
<tr>
<td align="left">YEARWEEK(date, mode)</td>
<td align="left">返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推</td>
<td align="left"><code>SELECT YEARWEEK(&quot;2017-06-15&quot;);-&gt; 201724</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="15-4、MySQL-高级函数"><a href="#15-4、MySQL-高级函数" class="headerlink" title="15.4、MySQL 高级函数"></a>15.4、MySQL 高级函数</h2><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BIN(x)</td>
<td align="left">返回 x 的二进制编码</td>
<td align="left">15 的 2 进制编码:<code>SELECT BIN(15); -- 1111</code></td>
</tr>
<tr>
<td align="left">BINARY(s)</td>
<td align="left">将字符串 s 转换为二进制字符串</td>
<td align="left"><code>SELECT BINARY &quot;itcast&quot;;-&gt; itcast</code></td>
</tr>
<tr>
<td align="left"><code>CASE expression WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... WHEN conditionN THEN resultN ELSE resultEND</code></td>
<td align="left">CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。</td>
<td align="left"><code>SELECT CASE 　　WHEN 1 &gt; 0　　THEN &#39;1 &gt; 0&#39;　　WHEN 2 &gt; 0　　THEN &#39;2 &gt; 0&#39;　　ELSE &#39;3 &gt; 0&#39;　　END-&gt;1 &gt; 0</code></td>
</tr>
<tr>
<td align="left">CAST(x AS type)</td>
<td align="left">转换数据类型</td>
<td align="left">字符串日期转换为日期：<code>SELECT CAST(&quot;2017-08-29&quot; AS DATE);-&gt; 2017-08-29</code></td>
</tr>
<tr>
<td align="left">COALESCE(expr1, expr2, …., expr_n)</td>
<td align="left">返回参数中的第一个非空表达式（从左向右）</td>
<td align="left"><code>SELECT COALESCE(NULL, NULL, NULL, &#39;itcast.com&#39;, NULL, &#39;google.com&#39;);-&gt; itcast.com</code></td>
</tr>
<tr>
<td align="left">CONNECTION_ID()</td>
<td align="left">返回服务器的连接数</td>
<td align="left"><code>SELECT CONNECTION_ID();-&gt; 4292835</code></td>
</tr>
<tr>
<td align="left">CONV(x,f1,f2)</td>
<td align="left">返回 f1 进制数变成 f2 进制数</td>
<td align="left"><code>SELECT CONV(15, 10, 2);-&gt; 1111</code></td>
</tr>
<tr>
<td align="left">CONVERT(s USING cs)</td>
<td align="left">函数将字符串 s 的字符集变成 cs</td>
<td align="left"><code>SELECT CHARSET(&#39;ABC&#39;)-&gt;utf-8 SELECT CHARSET(CONVERT(&#39;ABC&#39; USING gbk))-&gt;gbk</code></td>
</tr>
<tr>
<td align="left">CURRENT_USER()</td>
<td align="left">返回当前用户</td>
<td align="left"><code>SELECT CURRENT_USER();-&gt; guest@%</code></td>
</tr>
<tr>
<td align="left">DATABASE()</td>
<td align="left">返回当前数据库名</td>
<td align="left"><code>SELECT DATABASE(); -&gt; itcast</code></td>
</tr>
<tr>
<td align="left">IF(expr,v1,v2)</td>
<td align="left">如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</td>
<td align="left"><code>SELECT IF(1 &gt; 0,&#39;正确&#39;,&#39;错误&#39;) -&gt;正确</code></td>
</tr>
<tr>
<td align="left"><a href="http://www.itcast.com/mysql/mysql-func-ifnull.html" target="_blank" rel="noopener">IFNULL(v1,v2)</a></td>
<td align="left">如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。</td>
<td align="left"><code>SELECT IFNULL(null,&#39;Hello Word&#39;)-&gt;Hello Word</code></td>
</tr>
<tr>
<td align="left">ISNULL(expression)</td>
<td align="left">判断表达式是否为空</td>
<td align="left"><code>SELECT ISNULL(NULL);-&gt;1</code></td>
</tr>
<tr>
<td align="left">LAST_INSERT_ID()</td>
<td align="left">返回最近生成的 AUTO_INCREMENT 值</td>
<td align="left"><code>SELECT LAST_INSERT_ID();-&gt;6</code></td>
</tr>
<tr>
<td align="left">NULLIF(expr1, expr2)</td>
<td align="left">比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</td>
<td align="left"><code>SELECT NULLIF(25, 25);-&gt;</code></td>
</tr>
<tr>
<td align="left">SESSION_USER()</td>
<td align="left">返回当前用户</td>
<td align="left"><code>SELECT SESSION_USER();-&gt; guest@%</code></td>
</tr>
<tr>
<td align="left">SYSTEM_USER()</td>
<td align="left">返回当前用户</td>
<td align="left"><code>SELECT SYSTEM_USER();-&gt; guest@%</code></td>
</tr>
<tr>
<td align="left">USER()</td>
<td align="left">返回当前用户</td>
<td align="left"><code>SELECT USER();-&gt; guest@%</code></td>
</tr>
<tr>
<td align="left">VERSION()</td>
<td align="left">返回数据库的版本号</td>
<td align="left"><code>SELECT VERSION()-&gt; 5.6.34</code></td>
</tr>
</tbody></table>
<h1 id="16、MySQL-索引"><a href="#16、MySQL-索引" class="headerlink" title="16、MySQL 索引"></a>16、MySQL 索引</h1><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>
<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<p>建立索引会占用磁盘空间的索引文件。</p>
<h2 id="16-1、普通索引"><a href="#16-1、普通索引" class="headerlink" title="16.1、普通索引"></a>16.1、普通索引</h2><h3 id="16-1-1、创建索引"><a href="#16-1-1、创建索引" class="headerlink" title="16.1.1、创建索引"></a>16.1.1、创建索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length)); </span><br><span class="line"></span><br><span class="line">//创建索引</span><br><span class="line"> create index id on B(A_ID);</span><br></pre></td></tr></table></figure>

<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<h3 id="16-1-2、修改表结构-添加索引"><a href="#16-1-2、修改表结构-添加索引" class="headerlink" title="16.1.2、修改表结构(添加索引)"></a>16.1.2、修改表结构(添加索引)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure>

<h3 id="16-1-3、创建表的时候直接指定"><a href="#16-1-3、创建表的时候直接指定" class="headerlink" title="16.1.3、创建表的时候直接指定"></a>16.1.3、创建表的时候直接指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">INDEX [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="16-1-4、删除索引的语法"><a href="#16-1-4、删除索引的语法" class="headerlink" title="16.1.4、删除索引的语法"></a>16.1.4、删除索引的语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure>

<h2 id="16-2、唯一索引"><a href="#16-2、唯一索引" class="headerlink" title="16.2、唯一索引"></a>16.2、唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h3 id="16-2-1、创建索引"><a href="#16-2-1、创建索引" class="headerlink" title="16.2.1、创建索引"></a>16.2.1、创建索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length))</span><br></pre></td></tr></table></figure>

<h3 id="16-2-2、修改表结构"><a href="#16-2-2、修改表结构" class="headerlink" title="16.2.2、修改表结构"></a>16.2.2、修改表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure>

<h3 id="16-2-3、创建表的时候直接指定"><a href="#16-2-3、创建表的时候直接指定" class="headerlink" title="16.2.3、创建表的时候直接指定"></a>16.2.3、创建表的时候直接指定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line"> </span><br><span class="line">ID INT NOT NULL,   </span><br><span class="line"> </span><br><span class="line">username VARCHAR(16) NOT NULL,  </span><br><span class="line"> </span><br><span class="line">UNIQUE [indexName] (username(length))  </span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="16-3、使用ALTER-命令添加和删除索引"><a href="#16-3、使用ALTER-命令添加和删除索引" class="headerlink" title="16.3、使用ALTER 命令添加和删除索引"></a>16.3、使用ALTER 命令添加和删除索引</h2><p>有四种方式来添加数据表的索引：</p>
<ul>
<li><strong>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</strong> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</li>
<li><strong>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):</strong>该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<p>以下实例为在表中添加索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure>

<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure>

<h2 id="16-4、使用-ALTER-命令添加和删除主键"><a href="#16-4、使用-ALTER-命令添加和删除主键" class="headerlink" title="16.4、使用 ALTER 命令添加和删除主键"></a>16.4、使用 ALTER 命令添加和删除主键</h2><p>主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY itcast INT NOT NULL;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (itcast);</span><br></pre></td></tr></table></figure>

<p>你也可以使用 ALTER 命令删除主键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h2 id="16-5、显示索引信息"><a href="#16-5、显示索引信息" class="headerlink" title="16.5、显示索引信息"></a>16.5、显示索引信息</h2><p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G</span><br></pre></td></tr></table></figure>

<p>mysql&gt; show index from B;<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+<br>| B | 0 | PRIMARY | 1 | A_ID | A | 3 | NULL | NULL | | BTREE | | |<br>+——-+————+———-+————–+————-+———–+————-+———-+——–+——+————+———+—————+</p>
<h1 id="17、MySQL-事务"><a href="#17、MySQL-事务" class="headerlink" title="17、MySQL 事务"></a>17、MySQL 事务</h1><p> MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>
<ul>
<li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，在中间某个环节不会结束。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h3 id="17-1、事务控制语句："><a href="#17-1、事务控制语句：" class="headerlink" title="17.1、事务控制语句："></a>17.1、事务控制语句：</h3><ul>
<li>BEGIN或START TRANSACTION；显式地开启一个事务；</li>
<li>COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier；把事务回滚到标记点；</li>
<li>SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</li>
</ul>
<h3 id="17-2、MYSQL-事务处理主要有两种方法："><a href="#17-2、MYSQL-事务处理主要有两种方法：" class="headerlink" title="17.2、MYSQL 事务处理主要有两种方法："></a>17.2、MYSQL 事务处理主要有两种方法：</h3><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ul>
<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/数据库/" data-id="cjz2496e00006x0u51e9l7te5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Stream与Lambda" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Stream与Lambda/" class="article-date">
  <time datetime="2019-08-08T02:59:06.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Stream与Lambda/">Stream与Lambda</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>stream 流<br>jdk1.8 操作集合和数组</p>
<p>集合<br>list.stream()<br>数组<br>Stream.of(数组)<br>特点<br>只能使用一次 后流关闭</p>
<p>方法有两种 延迟方法 终结方法(count() forEach())除了终结 都是延迟</p>
<p>方法(全支持 lambda表达式)<br>forEach()遍历<br>filter() 过滤<br>map() 映射 如string数组 映射为integer数组 也可映射对象<br>count() 获取个数<br>limit() 获取前几个 传入 long<br>skip() 跳过 几个参数 传入 long<br>concat() 合并流 传入 两个流</p>
<p>常用的函数式接口<br>Supplier<br>Consumer<br>Predicate<br>Function</p>
<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><h2 id="一函数式编程思想"><a href="#一函数式编程思想" class="headerlink" title="一函数式编程思想"></a>一函数式编程思想</h2><p>面向对象的思想:<br>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.<br>函数式编程思想:<br>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="二-Lambda-转换线程写法"><a href="#二-Lambda-转换线程写法" class="headerlink" title="二 Lambda 转换线程写法"></a>二 Lambda 转换线程写法</h2><p>java原始写法匿名内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01Runnable &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 匿名内部类</span><br><span class="line">		Runnable task = new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123; // 覆盖重写抽象方法</span><br><span class="line">				System.out.println(&quot;多线程任务执行！&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		new Thread(task).start(); // 启动线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析:</p>
<p>对于Runnable 的匿名内部类用法，可以分析出几点内容：<br>Thread 类需要Runnable 接口作为参数，其中的抽象run 方法是用来指定线程任务内容的核心；</p>
<p> 为了指定run 的方法体，不得不需要Runnable 接口的实现类；</p>
<p> 为了省去定义一个RunnableImpl 实现类的麻烦，不得不使用匿名内部类；<br>​ 必须覆盖重写抽象run 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；<br>​ 而实际上，似乎只有方法体才是关键所在。</p>
<h3 id="思想转换"><a href="#思想转换" class="headerlink" title="思想转换"></a>思想转换</h3><p>用lambda</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo02LambdaRunnable &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() ‐&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类分析"><a href="#匿名内部类分析" class="headerlink" title="匿名内部类分析"></a>匿名内部类分析</h2><p>匿名内部类的好处与弊端<br>一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！<br>语义分析<br>仔细分析该代码中的语义， Runnable 接口只有一个run 方法的定义：<br>public abstract void run();<br>即制定了一种做事情的方案（其实就是一个函数）：<br>无参数：不需要任何条件即可执行该方案。<br>无返回值：该方案不产生任何结果。<br>代码块（方法体）：该方案的具体执行步骤。<br>同样的语义体现在Lambda 语法中，要更加简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() ‐&gt; System.out.println(&quot;多线程任务执行！&quot;)</span><br></pre></td></tr></table></figure>

<p> 前面的一对小括号即run 方法的参数（无），代表不需要任何条件；<br>​ 中间的一个箭头代表将前面的参数传递给后面的代码；<br>​ 后面的输出语句即业务逻辑代码。</p>
<h2 id="lambda-格式"><a href="#lambda-格式" class="headerlink" title="lambda 格式"></a>lambda 格式</h2><p>Lambda省去面向对象的条条框框，格式由3个部分组成：<br>一些参数<br>一个箭头<br>一段代码<br>Lambda表达式的标准格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：<br>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。<br>-&gt; 是新引入的语法格式，代表指向动作。<br>大括号内的语法与传统方法体要求基本一致。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Stream与Lambda/" data-id="cjz2496d00002x0u5a4qqrh1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Kudo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Kudo/" class="article-date">
  <time datetime="2019-08-08T02:48:51.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Kudo/">Kudo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="KuDu"><a href="#KuDu" class="headerlink" title="KuDu"></a>KuDu</h1><h2 id="一概述"><a href="#一概述" class="headerlink" title="一概述"></a>一概述</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在KUDU之前，大数据主要以两种方式存储；</p>
<p>（1）静态数据：</p>
<p>以 HDFS 引擎作为存储引擎，适用于高吞吐量的离线大数据分析场景。</p>
<p>这类存储的局限性是数据无法进行随机的读写。</p>
<p>（2）动态数据：</p>
<p>以 HBase、Cassandra 作为存储引擎，适用于大数据随机读写场景。</p>
<p>局限性是批量读取吞吐量远不如 HDFS，不适用于批量数据分析的场景。</p>
<p>从上面分析可知，这两种数据在存储方式上完全不同，进而导致使用场景完全不同，但在真实的场景中，边界可能没有那么清晰，面对既需要随机读写，又需要批量分析的大数据场景，该如何选择呢？</p>
<p>这个场景中，单种存储引擎无法满足业务需求，我们需要通过多种大数据工具组合来满足这一需求</p>
<p><a href="https://manzhong.github.io/images/kudu/t.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/t.png" alt="img"></a></p>
<p>如上图所示，数据实时写入 HBase，实时的数据更新也在 HBase 完成，为了应对 OLAP 需求，我们定时将 HBase 数据写成静态的文件（如：Parquet）导入到 OLAP 引擎（如：Impala、hive）。这一架构能满足既需要随机读写，又可以支持 OLAP 分析的场景，但他有如下缺点：</p>
<p>(1)<strong>架构复杂</strong>。从架构上看，数据在HBase、消息队列、HDFS 间流转，涉及环节太多，运维成本很高。并且每个环节需要保证高可用，都需要维护多个副本，存储空间也有一定的浪费。最后数据在多个系统上，对数据安全策略、监控等都提出了挑战。</p>
<p>(2)<strong>时效性低</strong>。数据从HBase导出成静态文件是周期性的，一般这个周期是一天（或一小时），在时效性上不是很高。</p>
<p>(3)<strong>难以应对后续的更新</strong>。真实场景中，总会有数据是延迟到达的。如果这些数据之前已经从HBase导出到HDFS，新到的变更数据就难以处理了，一个方案是把原有数据应用上新的变更后重写一遍，但这代价又很高。</p>
<p>为了解决上述架构的这些问题，KUDU应运而生。<strong>KUDU</strong>的定位是Fast Analytics on Fast Data，<strong>是一个既支持随机读写、又支持 OLAP 分析的大数据存储引擎</strong>。</p>
<p>KUDU 是一个折中的产品，在 HDFS 和 HBase 这两个偏科生中平衡了随机读写和批量分析的性能。从 KUDU 的诞生可以说明一个观点：底层的技术发展很多时候都是上层的业务推动的，脱离业务的技术很可能是空中楼阁。</p>
<p>kudu是什么</p>
<ul>
<li>是一个大数据存储引擎 用于大数据的存储，结合其他软件开展数据分析。</li>
<li>汲取了hdfs中高吞吐数据的能力和hbase中高随机读写数据的能力</li>
<li>既满足有传统OLAP分析 又满足于随机读写访问数据</li>
<li>kudu来自于cloudera 后来贡献给了apache</li>
</ul>
<p>kudu应用场景</p>
<p>适用于那些既有随机访问，也有批量数据扫描的复合场景</p>
<p>高计算量的场景</p>
<p>使用了高性能的存储设备，包括使用更多的内存</p>
<p>支持数据更新，避免数据反复迁移</p>
<p>支持跨地域的实时数据备份和查询</p>
<h2 id="二架构"><a href="#二架构" class="headerlink" title="二架构"></a>二架构</h2><ul>
<li>kudu集群是主从架构<ul>
<li>主角色 master ：管理集群 管理元数据</li>
<li>从角色 tablet server：负责最终数据的存储 对外提供数据读写能力 里面存储的都是一个个tablet</li>
</ul>
</li>
<li>kudu tablet<ul>
<li>是kudu表中的数据水平分区 一个表可以划分成为多个tablet(类似于hbase region)</li>
<li>tablet中主键是不重复连续的 所有tablet加起来就是一个table的所有数据</li>
<li>tablet在存储的时候 会进行冗余存放 设置多个副本</li>
<li>在一个tablet所有冗余中 任意时刻 一个是leader 其他的冗余都是follower</li>
</ul>
</li>
</ul>
<p>与HDFS和HBase相似，Kudu使用单个的Master节点，用来管理集群的元数据，并且使用任意数量的Tablet Server（类似HBase中的RegionServer角色）节点用来存储实际数据。可以部署多个Master节点来提高容错性。</p>
<p><a href="https://manzhong.github.io/images/kudu/t2.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/t2.png" alt="img"></a></p>
<h2 id="1．-Table"><a href="#1．-Table" class="headerlink" title="1． Table"></a>1． Table</h2><p>表（Table）是数据库中用来存储数据的对象，是有结构的数据集合。kudu中的表具有schema（纲要）和全局有序的primary key（主键）。kudu中一个table会被水平分成多个被称之为tablet的片段。</p>
<h2 id="2．-Tablet"><a href="#2．-Tablet" class="headerlink" title="2． Tablet"></a>2． Tablet</h2><p>一个 tablet 是一张 table连续的片段，tablet是kudu表的水平分区，类似于HBase的region。每个tablet存储着一定连续range的数据（key），且tablet两两间的range不会重叠。一张表的所有tablet包含了这张表的所有key空间。</p>
<p>tablet 会冗余存储。放置到多个 tablet server上，并且在任何给定的时间点，其中一个副本被认为是leader tablet,其余的被认之为follower tablet。每个tablet都可以进行数据的读请求，但只有Leader tablet负责写数据请求。</p>
<h2 id="3．-Tablet-Server"><a href="#3．-Tablet-Server" class="headerlink" title="3． Tablet Server"></a>3． Tablet Server</h2><p>tablet server集群中的小弟，负责数据存储，并提供数据读写服务</p>
<p>一个 tablet server 存储了table表的tablet，向kudu client 提供读取数据服务。对于给定的 tablet，一个tablet server 充当 leader，其他 tablet server 充当该 tablet 的 follower 副本。</p>
<p>只有 leader服务写请求，然而 leader 或 followers 为每个服务提供读请求 。一个 tablet server 可以服务多个 tablets ，并且一个 tablet 可以被多个 tablet servers 服务着。</p>
<h2 id="4．-Master-Server"><a href="#4．-Master-Server" class="headerlink" title="4． Master Server"></a>4． Master Server</h2><p>集群中的老大，负责集群管理、元数据管理等功能。</p>
<h2 id="三-kudu安装"><a href="#三-kudu安装" class="headerlink" title="三 kudu安装"></a>三 kudu安装</h2><p>1节点规划</p>
<table>
<thead>
<tr>
<th align="left"><strong>节点</strong></th>
<th align="left"><strong>kudu-master</strong></th>
<th align="left"><strong>kudu-tserver</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">node01</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">node02</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">node03</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>本次配置node01 和node02 不配置 kudu-master</p>
<p>2本地yum源配置</p>
<p>配过了在 node03上</p>
<p>3 安装KUDU</p>
<table>
<thead>
<tr>
<th align="left"><strong>服务器</strong></th>
<th align="left"><strong>安装命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">node01</td>
<td align="left">yum install -y kudu kudu-tserver kudu-client0 kudu-client-devel</td>
</tr>
<tr>
<td align="left">node02</td>
<td align="left">yum install -y kudu kudu-tserver kudu-client0 kudu-client-devel</td>
</tr>
<tr>
<td align="left">node03</td>
<td align="left">yum install -y kudu kudu-master kudu-tserver kudu-client0 kudu-client-devel</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install kudu # Kudu的基本包</span><br><span class="line">yum install kudu-master # KuduMaster </span><br><span class="line">yum install kudu-tserver # KuduTserver </span><br><span class="line">yum install kudu-client0 #Kudu C ++客户端共享库</span><br><span class="line">yum install kudu-client-devel # Kudu C ++客户端共享库 SDK</span><br></pre></td></tr></table></figure>

<p>4 kudu节点配置</p>
<p>安装完成之后。 需要在所有节点的/etc/kudu/conf目录下有两个文件：master.gflagfile和tserver.gflagfile。</p>
<h3 id="1-1．-修改master-gflagfile"><a href="#1-1．-修改master-gflagfile" class="headerlink" title="1.1． 修改master.gflagfile"></a>1.1． 修改master.gflagfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/kudu/conf/master.gflagfile</span><br><span class="line"># Do not modify these two lines. If you wish to change these variables,</span><br><span class="line"># modify them in /etc/default/kudu-master.</span><br><span class="line">--fromenv=rpc_bind_addresses</span><br><span class="line">--fromenv=log_dir</span><br><span class="line">--fs_wal_dir=/export/servers/kudu/master</span><br><span class="line">--fs_data_dirs=/export/servers/kudu/master</span><br><span class="line">--master_addresses=node03:7051     若为集node01:7051,node02:7051,node03:7051 若为单节点 则这句注释掉</span><br><span class="line">若为单节点 且没注释掉 则启动报错</span><br></pre></td></tr></table></figure>

<h3 id="1-2-修改tserver-gflagfile"><a href="#1-2-修改tserver-gflagfile" class="headerlink" title="1.2 修改tserver.gflagfile"></a>1.2 修改tserver.gflagfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Do not modify these two lines. If you wish to change these variables,</span><br><span class="line"># modify them in /etc/default/kudu-tserver.</span><br><span class="line">--fromenv=rpc_bind_addresses</span><br><span class="line">--fromenv=log_dir</span><br><span class="line">--fs_wal_dir=/export/servers/kudu/tserver</span><br><span class="line">--fs_data_dirs=/export/servers/kudu/tserver</span><br><span class="line">--tserver_master_addrs=node03:7051  若为集node01:7051,node02:7051,node03:7051</span><br></pre></td></tr></table></figure>

<h3 id="1-3修改-etc-default-kudu-master"><a href="#1-3修改-etc-default-kudu-master" class="headerlink" title="1.3修改 /etc/default/kudu-master"></a>1.3修改 /etc/default/kudu-master</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FLAGS_log_dir=/var/log/kudu</span><br><span class="line">#每台机器的master地址要与主机名一致,这里是在node03上</span><br><span class="line">export FLAGS_rpc_bind_addresses=node03:7051</span><br></pre></td></tr></table></figure>

<h3 id="1-4修改-etc-default-kudu-tserver"><a href="#1-4修改-etc-default-kudu-tserver" class="headerlink" title="1.4修改 /etc/default/kudu-tserver"></a>1.4修改 /etc/default/kudu-tserver</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export FLAGS_log_dir=/var/log/kudu</span><br><span class="line">#每台机器的tserver地址要与主机名一致，这里是在node03上</span><br><span class="line">export FLAGS_rpc_bind_addresses=node03:7050</span><br></pre></td></tr></table></figure>

<p>kudu默认用户就是KUDU，所以需要将/export/servers/kudu权限修改成kudu：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /export/servers/kudu</span><br><span class="line">chown -R kudu:kudu /export/servers/kudu</span><br></pre></td></tr></table></figure>

<p>(如果使用的是普通的用户，那么最好配置sudo权限)/etc/sudoers文件中添加：</p>
<p><strong>kudu集群的启动与关闭</strong></p>
<p>1 ntp服务的安装</p>
<p>启动的时候要注意时间同步</p>
<p>安装ntp服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service ntpd start </span><br><span class="line">chkconfig ntpd on</span><br></pre></td></tr></table></figure>

<p>可以在每台服务器执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ntpd restart</span><br><span class="line">启动</span><br><span class="line">service kudu-master start</span><br><span class="line">service kudu-tserver start</span><br><span class="line">关闭</span><br><span class="line">service kudu-master stop</span><br><span class="line">service kudu-tserver stop</span><br><span class="line">kudu的web管理界面。http://master主机名:8051</span><br><span class="line"></span><br><span class="line">可以查看每个机器上master相关信息。http://node03:8051/masters    一定为8051 不为7051</span><br><span class="line"></span><br><span class="line">tserver 的web地址  http://node03:8051/tablet-servers</span><br></pre></td></tr></table></figure>

<p>安装属于事项</p>
<h3 id="1-1给普通用户授予sudo出错"><a href="#1-1给普通用户授予sudo出错" class="headerlink" title="1.1给普通用户授予sudo出错"></a>1.1给普通用户授予sudo出错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo: /etc/sudoers is world writable</span><br><span class="line">解决方式：``pkexec chmod 555 /etc/sudoers</span><br></pre></td></tr></table></figure>

<h3 id="1-2-启动kudu的时候报错"><a href="#1-2-启动kudu的时候报错" class="headerlink" title="1.2 启动kudu的时候报错"></a>1.2 启动kudu的时候报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Failed to start Kudu Master Server. Return value: 1 [FAILED]</span><br><span class="line">去日志文件中查看：</span><br><span class="line">Service unavailable: Cannot initialize clock: Errorreading clock. Clock considered</span><br><span class="line">unsynchronized</span><br><span class="line">解决：</span><br><span class="line">第一步：首先检查是否有安装ntp：如果没有安装则使用以下命令安装：</span><br><span class="line">yum -y install ntp</span><br><span class="line">第二步：设置随机启动：</span><br><span class="line">service ntpd start</span><br><span class="line">chkconfig ntpd on</span><br></pre></td></tr></table></figure>

<h3 id="1-3-启动过程中报错"><a href="#1-3-启动过程中报错" class="headerlink" title="1.3 启动过程中报错"></a>1.3 启动过程中报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Invalid argument: Unable to initialize catalog manager: Failed to initialize sys</span><br><span class="line">tables</span><br><span class="line">async: on-disk master list</span><br><span class="line">解决：</span><br><span class="line">（1）：停掉master和tserver</span><br><span class="line">（2）：删除掉之前所有的/export/servers/kudu/master/*和/export/servers/kudu/tserver/*</span><br></pre></td></tr></table></figure>

<h3 id="1-4-启动过程中报错"><a href="#1-4-启动过程中报错" class="headerlink" title="1.4 启动过程中报错"></a>1.4 启动过程中报错</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: Could not create new FS layout: unable to create file system roots: unable to</span><br><span class="line">write instance metadata: Call to mkstemp() failed on name template</span><br><span class="line">/export/servers/kudu/master/instance.kudutmp.XXXXXX: Permission denied (error 13)</span><br><span class="line">这是因为kudu默认使用kudu权限进行执行，可能遇到文件夹的权限不一致情况，更改文件夹权限即可</span><br></pre></td></tr></table></figure>

<h2 id="四-Java操作kudu"><a href="#四-Java操作kudu" class="headerlink" title="四 Java操作kudu"></a>四 Java操作kudu</h2><p>###1 创建maven工程 导入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;  </span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.kudu&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;kudu-client&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.6.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2 初始化方法"></a>2 初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestKudu &#123;</span><br><span class="line"></span><br><span class="line">    //声明全局变量 KuduClient后期通过它来操作kudu表</span><br><span class="line">    private KuduClient kuduClient;</span><br><span class="line">    //指定kuduMaster地址</span><br><span class="line">    private String kuduMaster;</span><br><span class="line">    //指定表名</span><br><span class="line">    private String tableName;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        //初始化操作</span><br><span class="line">        kuduMaster=&quot;node03:7051&quot;;</span><br><span class="line">        //指定表名</span><br><span class="line">        tableName=&quot;student&quot;;</span><br><span class="line">        KuduClient.KuduClientBuilder kuduClientBuilder = new KuduClient.KuduClientBuilder(kuduMaster);</span><br><span class="line">		//设置客户端与kudu集群socket超时时间</span><br><span class="line">        kuduClientBuilder.defaultSocketReadTimeoutMs(10000);</span><br><span class="line">        kuduClient=kuduClientBuilder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3 创建表"></a>3 创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建表</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void createTable() throws KuduException &#123;</span><br><span class="line">    //判断表是否存在，不存在就构建</span><br><span class="line">    if(!kuduClient.tableExists(tableName))&#123;</span><br><span class="line"></span><br><span class="line">        //构建创建表的schema信息-----就是表的字段和类型</span><br><span class="line">        ArrayList&lt;ColumnSchema&gt; columnSchemas = new ArrayList&lt;ColumnSchema&gt;();</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;id&quot;, Type.INT32).key(true).build());</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;name&quot;, Type.STRING).build());</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;age&quot;, Type.INT32).build());</span><br><span class="line">        columnSchemas.add(new ColumnSchema.ColumnSchemaBuilder(&quot;sex&quot;, Type.INT32).build());</span><br><span class="line">        Schema schema = new Schema(columnSchemas);</span><br><span class="line"></span><br><span class="line">        //指定创建表的相关属性</span><br><span class="line">        CreateTableOptions options = new CreateTableOptions();</span><br><span class="line">        ArrayList&lt;String&gt; partitionList = new ArrayList&lt;String&gt;();</span><br><span class="line">        //指定kudu表的分区字段是什么</span><br><span class="line">        partitionList.add(&quot;id&quot;);    //  按照 id.hashcode % 分区数 = 分区号</span><br><span class="line">        options.addHashPartitions(partitionList,6);</span><br><span class="line"></span><br><span class="line">        kuduClient.createTable(tableName,schema,options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-插入数据"><a href="#4-插入数据" class="headerlink" title="4 插入数据"></a>4 插入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 向表加载数据</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void insertTable() throws KuduException &#123;</span><br><span class="line">      //向表加载数据需要一个kuduSession对象</span><br><span class="line">      KuduSession kuduSession = kuduClient.newSession();</span><br><span class="line">      //设置提交数据为自动flush</span><br><span class="line">      kuduSession.setFlushMode(SessionConfiguration.FlushMode.AUTO_FLUSH_SYNC);</span><br><span class="line"></span><br><span class="line">      //需要使用kuduTable来构建Operation的子类实例对象  就是打开本次操作的表名</span><br><span class="line">      KuduTable kuduTable = kuduClient.openTable(tableName);</span><br><span class="line">//此处需要kudutable 来构建operation的子类实例对象  此处 为insert</span><br><span class="line">      for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">          Insert insert = kuduTable.newInsert();</span><br><span class="line">          PartialRow row = insert.getRow();</span><br><span class="line">          row.addInt(&quot;id&quot;,i);</span><br><span class="line">          row.addString(&quot;name&quot;,&quot;zhangsan-&quot;+i);</span><br><span class="line">          row.addInt(&quot;age&quot;,20+i);</span><br><span class="line">          row.addInt(&quot;sex&quot;,i%2);</span><br><span class="line"></span><br><span class="line">          kuduSession.apply(insert);//最后实现执行数据的加载操作</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-查询数据"><a href="#5-查询数据" class="headerlink" title="5 查询数据"></a>5 查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 查询表的数据结果</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void queryData() throws KuduException &#123;</span><br><span class="line"></span><br><span class="line">        //构建一个查询的扫描器 在扫描器中指定 表名</span><br><span class="line">        KuduScanner.KuduScannerBuilder kuduScannerBuilder = kuduClient.newScannerBuilder(kuduClient.openTable(tableName));</span><br><span class="line">        //创建集合 用于存储扫描的字段信息</span><br><span class="line">        ArrayList&lt;String&gt; columnsList = new ArrayList&lt;String&gt;();</span><br><span class="line">        columnsList.add(&quot;id&quot;);</span><br><span class="line">        columnsList.add(&quot;name&quot;);</span><br><span class="line">        columnsList.add(&quot;age&quot;);</span><br><span class="line">        columnsList.add(&quot;sex&quot;);</span><br><span class="line">        kuduScannerBuilder.setProjectedColumnNames(columnsList);</span><br><span class="line">        // 调用build方法执行扫描,返回结果集</span><br><span class="line">        KuduScanner kuduScanner = kuduScannerBuilder.build();</span><br><span class="line">        //遍历</span><br><span class="line">        while (kuduScanner.hasMoreRows())&#123;</span><br><span class="line">            RowResultIterator rowResults = kuduScanner.nextRows();</span><br><span class="line"></span><br><span class="line">             while (rowResults.hasNext())&#123;</span><br><span class="line">                 RowResult row = rowResults.next(); //拿到的是一行数据</span><br><span class="line">                 int id = row.getInt(&quot;id&quot;);</span><br><span class="line">                 String name = row.getString(&quot;name&quot;);</span><br><span class="line">                 int age = row.getInt(&quot;age&quot;);</span><br><span class="line">                 int sex = row.getInt(&quot;sex&quot;);</span><br><span class="line"></span><br><span class="line">                 System.out.println(&quot;id=&quot;+id+&quot;  name=&quot;+name+&quot;  age=&quot;+age+&quot;  sex=&quot;+sex);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-修改数据"><a href="#6-修改数据" class="headerlink" title="6 修改数据"></a>6 修改数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 修改表的数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void updateData() throws KuduException &#123;</span><br><span class="line">        //修改表的数据需要一个kuduSession对象</span><br><span class="line">        KuduSession kuduSession = kuduClient.newSession();</span><br><span class="line">        //设置提交数据为自动flush</span><br><span class="line">        kuduSession.setFlushMode(SessionConfiguration.FlushMode.AUTO_FLUSH_SYNC);</span><br><span class="line"></span><br><span class="line">        //需要使用kuduTable来构建Operation的子类实例对象</span><br><span class="line">        KuduTable kuduTable = kuduClient.openTable(tableName);</span><br><span class="line"></span><br><span class="line">        //Update update = kuduTable.newUpdate(); //如果id不存在 ,就什么也不操作</span><br><span class="line">        Upsert upsert = kuduTable.newUpsert(); //如果id存在就表示修改，不存在就新增</span><br><span class="line">        PartialRow row = upsert.getRow();</span><br><span class="line">        row.addInt(&quot;id&quot;,100);</span><br><span class="line">        row.addString(&quot;name&quot;,&quot;zhangsan-100&quot;);</span><br><span class="line">        row.addInt(&quot;age&quot;,100);</span><br><span class="line">        row.addInt(&quot;sex&quot;,0);</span><br><span class="line"></span><br><span class="line">        kuduSession.apply(upsert);//最后实现执行数据的修改操作</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7删除数据"><a href="#7删除数据" class="headerlink" title="7删除数据"></a>7删除数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 删除数据</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void deleteData() throws KuduException &#123;</span><br><span class="line">        //删除表的数据需要一个kuduSession对象</span><br><span class="line">        KuduSession kuduSession = kuduClient.newSession();</span><br><span class="line">        kuduSession.setFlushMode(SessionConfiguration.FlushMode.AUTO_FLUSH_SYNC);</span><br><span class="line"></span><br><span class="line">        //需要使用kuduTable来构建Operation的子类实例对象</span><br><span class="line">        KuduTable kuduTable = kuduClient.openTable(tableName);</span><br><span class="line"></span><br><span class="line">        Delete delete = kuduTable.newDelete();</span><br><span class="line">        PartialRow row = delete.getRow();</span><br><span class="line">        row.addInt(&quot;id&quot;,100);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        kuduSession.apply(delete);//最后实现执行数据的删除操作</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-删除表"><a href="#8-删除表" class="headerlink" title="8 删除表"></a>8 删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void dropTable() throws KuduException &#123;</span><br><span class="line"></span><br><span class="line">    if(kuduClient.tableExists(tableName))&#123;</span><br><span class="line">        kuduClient.deleteTable(tableName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-kudu的分区方式"><a href="#9-kudu的分区方式" class="headerlink" title="9 kudu的分区方式"></a>9 kudu的分区方式</h3><p>为了提供可扩展性，Kudu 表被划分为称为 tablet 的单元，并分布在许多 tablet servers 上。行总是属于单个tablet 。将行分配给 tablet 的方法由在表创建期间设置的表的分区决定。 kudu提供了3种分区方式。</p>
<h4 id="1-范围分区Range-Partitioning"><a href="#1-范围分区Range-Partitioning" class="headerlink" title="1 范围分区Range Partitioning"></a>1 范围分区Range Partitioning</h4><p>范围分区可以根据存入数据的数据量，均衡的存储到各个机器上，防止机器出现负载不均衡现象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 测试分区：</span><br><span class="line">  * RangePartition</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void testRangePartition() throws KuduException &#123;</span><br><span class="line">     //设置表的schema</span><br><span class="line">     LinkedList&lt;ColumnSchema&gt; columnSchemas = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">     columnSchemas.add(new Column(&quot;id&quot;, Type.INT32,true));</span><br><span class="line">     columnSchemas.add(new Column(&quot;WorkId&quot;, Type.INT32,false));</span><br><span class="line">     columnSchemas.add(new Column(&quot;Name&quot;, Type.STRING,false));</span><br><span class="line">     columnSchemas.add(new Column(&quot;Gender&quot;, Type.STRING,false));</span><br><span class="line">     columnSchemas.add(new Column(&quot;Photo&quot;, Type.STRING,false));</span><br><span class="line"></span><br><span class="line">     //创建schema</span><br><span class="line">     Schema schema = new Schema(columnSchemas);</span><br><span class="line"></span><br><span class="line">     //创建表时提供的所有选项</span><br><span class="line">     CreateTableOptions tableOptions = new CreateTableOptions();</span><br><span class="line">     //设置副本数</span><br><span class="line">     //tableOptions.setNumReplicas(1);</span><br><span class="line">     //设置范围分区的规则</span><br><span class="line">     LinkedList&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">     parcols.add(&quot;id&quot;);</span><br><span class="line">     //设置按照那个字段进行range分区</span><br><span class="line">     tableOptions.setRangePartitionColumns(parcols);</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      * range</span><br><span class="line">      *  0 &lt; value &lt; 10</span><br><span class="line">      * 10 &lt;= value &lt; 20</span><br><span class="line">      * 20 &lt;= value &lt; 30</span><br><span class="line">      * ........</span><br><span class="line">      * 80 &lt;= value &lt; 90</span><br><span class="line">      * */</span><br><span class="line">     int count=0;</span><br><span class="line">     for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">         //范围开始</span><br><span class="line">         PartialRow lower = schema.newPartialRow();</span><br><span class="line">         lower.addInt(&quot;id&quot;,count);</span><br><span class="line"></span><br><span class="line">         //范围结束</span><br><span class="line">         PartialRow upper = schema.newPartialRow();</span><br><span class="line">         count +=10;</span><br><span class="line">         upper.addInt(&quot;id&quot;,count);</span><br><span class="line"></span><br><span class="line">         //设置每一个分区的范围</span><br><span class="line">         tableOptions.addRangePartition(lower,upper);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         kuduClient.createTable(&quot;t-range-partition&quot;,schema,tableOptions);</span><br><span class="line">     &#125; catch (KuduException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">      kuduClient.close();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-哈希分区Hash-Partitioning-为kudu的默认分区"><a href="#2-哈希分区Hash-Partitioning-为kudu的默认分区" class="headerlink" title="2 哈希分区Hash Partitioning 为kudu的默认分区"></a>2 哈希分区Hash Partitioning 为kudu的默认分区</h4><p>哈希分区通过哈希值将行分配到许多 buckets (存储桶 )之一； 哈希分区是一种有效的策略，当不需要对表进行有序访问时。哈希分区对于在 tablet 之间随机散布这些功能是有效的，这有助于减轻热点和 tablet 大小不均匀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 测试分区：</span><br><span class="line">     * hash分区</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testHashPartition() throws KuduException &#123;</span><br><span class="line">        //设置表的schema</span><br><span class="line">        LinkedList&lt;ColumnSchema&gt; columnSchemas = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">        columnSchemas.add(new Column(&quot;id&quot;, Type.INT32,true));</span><br><span class="line">        columnSchemas.add(new Column(&quot;WorkId&quot;, Type.INT32,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Name&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Gender&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Photo&quot;, Type.STRING,false));</span><br><span class="line"></span><br><span class="line">        //创建schema</span><br><span class="line">        Schema schema = new Schema(columnSchemas);</span><br><span class="line"></span><br><span class="line">        //创建表时提供的所有选项</span><br><span class="line">        CreateTableOptions tableOptions = new CreateTableOptions();</span><br><span class="line">        //设置副本数</span><br><span class="line">        tableOptions.setNumReplicas(1);</span><br><span class="line">        //设置范围分区的规则</span><br><span class="line">        LinkedList&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">        parcols.add(&quot;id&quot;);</span><br><span class="line">        //设置按照那个字段进行range分区</span><br><span class="line">        tableOptions.addHashPartitions(parcols,6);</span><br><span class="line">        try &#123;</span><br><span class="line">            kuduClient.createTable(&quot;t-hash-partition&quot;,schema,tableOptions);</span><br><span class="line">        &#125; catch (KuduException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kuduClient.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-多级分区Multilevel-Partitioning"><a href="#3-多级分区Multilevel-Partitioning" class="headerlink" title="3 多级分区Multilevel Partitioning"></a>3 多级分区Multilevel Partitioning</h4><p>Kudu 允许一个表在单个表上组合多级分区。 当正确使用时，多级分区可以保留各个分区类型的优点，同时减少每个分区的缺点</p>
<p>如 范围分区 为5个 hash分区为3个 则多级分区为15个 (即在范围分区里面有进行了hash分区)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 测试分区：</span><br><span class="line">     * 多级分区</span><br><span class="line">     * Multilevel Partition</span><br><span class="line">     * 混合使用hash分区和range分区</span><br><span class="line">     *</span><br><span class="line">     * 哈希分区有利于提高写入数据的吞吐量，而范围分区可以避免tablet无限增长问题，</span><br><span class="line">     * hash分区和range分区结合，可以极大的提升kudu的性能</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMultilevelPartition() throws KuduException &#123;</span><br><span class="line">        //设置表的schema</span><br><span class="line">        LinkedList&lt;ColumnSchema&gt; columnSchemas = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">        columnSchemas.add(new Column(&quot;id&quot;, Type.INT32,true));</span><br><span class="line">        columnSchemas.add(new Column(&quot;WorkId&quot;, Type.INT32,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Name&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Gender&quot;, Type.STRING,false));</span><br><span class="line">        columnSchemas.add(new Column(&quot;Photo&quot;, Type.STRING,false));</span><br><span class="line"></span><br><span class="line">        //创建schema</span><br><span class="line">        Schema schema = new Schema(columnSchemas);</span><br><span class="line">        </span><br><span class="line">        //创建表时提供的所有选项</span><br><span class="line">        CreateTableOptions tableOptions = new CreateTableOptions();</span><br><span class="line">        //设置副本数</span><br><span class="line">        //tableOptions.setNumReplicas(1);</span><br><span class="line">        //设置范围分区的规则</span><br><span class="line">        LinkedList&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">        parcols.add(&quot;id&quot;);</span><br><span class="line"></span><br><span class="line">        //hash分区</span><br><span class="line">        tableOptions.addHashPartitions(parcols,5);</span><br><span class="line"></span><br><span class="line">        //range分区</span><br><span class="line">        int count=0;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        //指定上界</span><br><span class="line">            PartialRow lower = schema.newPartialRow();</span><br><span class="line">            lower.addInt(&quot;id&quot;,count);</span><br><span class="line">            count+=10;</span><br><span class="line">			//指定下界</span><br><span class="line">            PartialRow upper = schema.newPartialRow();</span><br><span class="line">            upper.addInt(&quot;id&quot;,count);</span><br><span class="line">            tableOptions.addRangePartition(lower,upper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            kuduClient.createTable(&quot;t-multilevel-partition&quot;,schema,tableOptions);</span><br><span class="line">        &#125; catch (KuduException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        kuduClient.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-kudu集成impala"><a href="#五-kudu集成impala" class="headerlink" title="五 kudu集成impala"></a>五 kudu集成impala</h2><h3 id="1-impala的配置修改"><a href="#1-impala的配置修改" class="headerlink" title="1 impala的配置修改"></a>1 impala的配置修改</h3><p>可选项 若配置以后写的时候指定 master地址即可</p>
<p>在每一个服务器的impala的配置文件中添加如下配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/impala</span><br></pre></td></tr></table></figure>

<p><code>在</code>IMPALA_SERVER_ARGS`下添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-kudu_master_hosts=node-1:7051,node-2:7051,node-3:7051</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">### 2 创建kudu表</span><br><span class="line"></span><br><span class="line">需要先启动hdfs、hive、kudu、impala。使用impala的shell控制台。</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">impala-shell</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">内部表:impala中删除,kudu里也会删除  </span><br><span class="line"></span><br><span class="line">外部表: impala中删除,kudu中不会删除.</span><br><span class="line"></span><br><span class="line">2.1 内部表</span><br><span class="line"></span><br><span class="line">内部表由Impala管理，当您从Impala中删除时，数据和表确实被删除。当您使用Impala创建新表时，它通常是内部表。</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line">CREATE TABLE my_first_table</span><br><span class="line">(</span><br><span class="line">id BIGINT,</span><br><span class="line">name STRING,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH PARTITIONS 16 </span><br><span class="line">STORED AS KUDU</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">&apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;,  //这种就是没有配置以上的 指定地址</span><br><span class="line">&apos;kudu.table_name&apos; = &apos;my_first_table&apos;</span><br><span class="line">);</span><br><span class="line">    </span><br><span class="line">在 CREATE TABLE 语句中，必须首先列出构成主键的列。</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">2.2 外部表</span><br><span class="line"></span><br><span class="line">外部表（创建者CREATE EXTERNAL TABLE）不受Impala管理，并且删除此表不会将表从其源位置（此处为Kudu）丢弃。相反，它只会去除Impala和Kudu之间的映射。这是Kudu提供的用于将现有表映射到Impala的语法。</span><br><span class="line"></span><br><span class="line">首先使用java创建kudu表：</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">public class CreateTable &#123;</span><br><span class="line">        private static ColumnSchema newColumn(String name, Type type, boolean iskey) &#123;</span><br><span class="line">                ColumnSchema.ColumnSchemaBuilder column = new</span><br><span class="line">                    ColumnSchema.ColumnSchemaBuilder(name, type);</span><br><span class="line">                column.key(iskey);</span><br><span class="line">                return column.build();</span><br><span class="line">        &#125;</span><br><span class="line">    public static void main(String[] args) throws KuduException &#123;</span><br><span class="line">        // master地址</span><br><span class="line">        final String masteraddr = &quot;node1,node2,node3&quot;;</span><br><span class="line">        // 创建kudu的数据库链接</span><br><span class="line">        KuduClient client = new</span><br><span class="line">     KuduClient.KuduClientBuilder(masteraddr).defaultSocketReadTimeoutMs(6000).build();</span><br><span class="line">        </span><br><span class="line">        // 设置表的schema</span><br><span class="line">        List&lt;ColumnSchema&gt; columns = new LinkedList&lt;ColumnSchema&gt;();</span><br><span class="line">        columns.add(newColumn(&quot;CompanyId&quot;, Type.INT32, true));</span><br><span class="line">        columns.add(newColumn(&quot;WorkId&quot;, Type.INT32, false));</span><br><span class="line">        columns.add(newColumn(&quot;Name&quot;, Type.STRING, false));</span><br><span class="line">        columns.add(newColumn(&quot;Gender&quot;, Type.STRING, false));</span><br><span class="line">        columns.add(newColumn(&quot;Photo&quot;, Type.STRING, false));</span><br><span class="line">        Schema schema = new Schema(columns);</span><br><span class="line">    //创建表时提供的所有选项</span><br><span class="line">    CreateTableOptions options = new CreateTableOptions();</span><br><span class="line">        </span><br><span class="line">    // 设置表的replica备份和分区规则</span><br><span class="line">    List&lt;String&gt; parcols = new LinkedList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">    parcols.add(&quot;CompanyId&quot;);</span><br><span class="line">    //设置表的备份数</span><br><span class="line">        options.setNumReplicas(1);</span><br><span class="line">    //设置range分区</span><br><span class="line">    options.setRangePartitionColumns(parcols);</span><br><span class="line">        </span><br><span class="line">    //设置hash分区和数量</span><br><span class="line">    options.addHashPartitions(parcols, 3);</span><br><span class="line">    try &#123;</span><br><span class="line">    client.createTable(&quot;person&quot;, schema, options);</span><br><span class="line">    &#125; catch (KuduException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">使用impala创建外部表 ， 将kudu的表映射到impala上。</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">在impala-shell中执行</span><br><span class="line"></span><br><span class="line">CREATE EXTERNAL TABLE `person` STORED AS KUDU</span><br><span class="line">TBLPROPERTIES(</span><br><span class="line">    &apos;kudu.table_name&apos; = &apos;person&apos;,</span><br><span class="line">    &apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;)</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">### 3 使用impala对kudu进行DML</span><br><span class="line"></span><br><span class="line">1 插入数据</span><br><span class="line"></span><br><span class="line">impala 允许使用标准 SQL 语句将数据插入 Kudu 。</span><br><span class="line"></span><br><span class="line">首先建表：</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line">在impala-shell中</span><br><span class="line">CREATE TABLE my_first_table1</span><br><span class="line">(</span><br><span class="line">id BIGINT,</span><br><span class="line">name STRING,</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH PARTITIONS 16</span><br><span class="line">STORED AS KUDU </span><br><span class="line">TBLPROPERTIES(</span><br><span class="line">    &apos;kudu.table_name&apos; = &apos;person1&apos;,</span><br><span class="line">    &apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;);</span><br><span class="line"></span><br><span class="line">~~~~</span><br><span class="line"></span><br><span class="line">此示例插入单个行：</span><br></pre></td></tr></table></figure>

<p>INSERT INTO my_first_table VALUES (50, “zhangsan”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">此示例插入3行：</span><br></pre></td></tr></table></figure>

<p>INSERT INTO my_first_table VALUES (1, “john”), (2, “jane”), (3, “jim”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">批量导入数据：</span><br><span class="line"></span><br><span class="line">从 Impala 和 Kudu 的角度来看，通常表现最好的方法通常是使用 Impala 中的 SELECT FROM 语句导入数据。</span><br></pre></td></tr></table></figure>

<p>INSERT INTO my_first_table SELECT * FROM temp1;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 更新数据</span><br></pre></td></tr></table></figure>

<p>UPDATE my_first_table SET name=”xiaowang” where id =1 ;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 删除数据</span><br></pre></td></tr></table></figure>

<p>delete from my_first_table where id =2;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 更改表属性</span><br><span class="line"></span><br><span class="line">4.1重命名impala表</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE PERSON RENAME TO person_temp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 4.2重新命名内部表的基础kudu表</span><br><span class="line"></span><br><span class="line">  				4.1.1创建内部表</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">CREATE TABLE kudu_student</span><br><span class="line">(</span><br><span class="line">CompanyId INT,</span><br><span class="line">WorkId INT,</span><br><span class="line">Name STRING,</span><br><span class="line">Gender STRING,</span><br><span class="line">Photo STRING,</span><br><span class="line">PRIMARY KEY(CompanyId)</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH PARTITIONS 16</span><br><span class="line">STORED AS KUDU</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">&apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;,</span><br><span class="line">&apos;kudu.table_name&apos; = &apos;student&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">				4.1.2如果表是内部表，则可以通过更改 kudu.table_name 属性重命名底层的 Kudu 表。</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE kudu_student SET TBLPROPERTIES(‘kudu.table_name’ = ‘new_student’);<br>&lt;!–￼33–&gt;</p>
<p>CREATE EXTERNAL TABLE external_table<br>    STORED AS KUDU<br>    TBLPROPERTIES (<br>    ‘kudu.master_addresses’ = ‘node1:7051,node2:7051,node3:7051’,<br>    ‘kudu.table_name’ = ‘person’<br>);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">重新映射外部表，指向不同的kudu表：</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE external_table<br>SET TBLPROPERTIES(‘kudu.table_name’ = ‘hashTable’)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的操作是：将external_table映射的PERSON表重新指向hashTable表。</span><br><span class="line"></span><br><span class="line">4.4 更改kudu master地址</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE my_table<br>SET TBLPROPERTIES(‘kudu.master_addresses’ = ‘kudu-new-master.example.com:7051’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.5 将内部表改为外部表</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE my_table SET TBLPROPERTIES(‘EXTERNAL’ = ‘TRUE’);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\##4 impala使用Java操作kudu</span><br><span class="line"></span><br><span class="line">对于impala而言，开发人员是可以通过JDBC连接impala的，有了JDBC，开发人员可以通过impala来间接操作 kudu。</span><br><span class="line"></span><br><span class="line">### 1 引入依赖</span><br></pre></td></tr></table></figure>

   <!--impala的jdbc操作--> 
<dependency>
        <groupid>com.cloudera</groupid>
        <artifactid>ImpalaJDBC41</artifactid>
        <version>2.5.42</version>
    </dependency>

<pre><code>&lt;!--Caused by : ClassNotFound : thrift.protocol.TPro--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;
    &lt;artifactId&gt;libfb303&lt;/artifactId&gt;
    &lt;version&gt;0.9.3&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;

&lt;!--Caused by : ClassNotFound : thrift.protocol.TPro--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;
    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;
    &lt;version&gt;0.9.3&lt;/version&gt;
    &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
    &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
            &lt;artifactId&gt;hive-service-rpc&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
            &lt;artifactId&gt;hive-service&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--导入hive--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;
    &lt;artifactId&gt;hive-service&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2 jdbc连接impala操作kudu</span><br><span class="line"></span><br><span class="line">使用JDBC连接impala操作kudu，与JDBC连接mysql做更重增删改查基本一样。</span><br><span class="line"></span><br><span class="line">创建实体类</span><br></pre></td></tr></table></figure>

<p>package cn.itcast.impala.impala;</p>
<p>public class Person {<br>    private int companyId;<br>    private int workId;<br>    private  String name;<br>    private  String gender;<br>    private  String photo;</p>
<pre><code>public Person(int companyId, int workId, String name, String gender, String photo) {
    this.companyId = companyId;
    this.workId = workId;
    this.name = name;
    this.gender = gender;
    this.photo = photo;
}

public int getCompanyId() {
    return companyId;
}

public void setCompanyId(int companyId) {
    this.companyId = companyId;
}

public int getWorkId() {
    return workId;
}

public void setWorkId(int workId) {
    this.workId = workId;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public String getGender() {
    return gender;
}

public void setGender(String gender) {
    this.gender = gender;
}

public String getPhoto() {
    return photo;
}

public void setPhoto(String photo) {
    this.photo = photo;
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### JDBC连接impala对kudu进行增删改查</span><br></pre></td></tr></table></figure>

<p>package cn.itcast.impala.impala;</p>
<p>import java.sql.*;</p>
<p>public class Contants {<br>    private static String JDBC_DRIVER=”com.cloudera.impala.jdbc41.Driver”;<br>    private static  String CONNECTION_URL=”jdbc:impala://node1:21050/default;auth=noSasl”;<br>     //定义数据库连接<br>    static Connection conn=null;<br>    //定义PreparedStatement对象<br>    static PreparedStatement ps=null;<br>    //定义查询的结果集<br>    static ResultSet rs= null;</p>
<pre><code>//数据库连接
public static Connection getConn(){
    try {
        Class.forName(JDBC_DRIVER);
        conn=DriverManager.getConnection(CONNECTION_URL);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return  conn;

}

//创建一个表
public static void createTable(){
    conn=getConn();
    String sql=&quot;CREATE TABLE impala_kudu_test&quot; +
            &quot;(&quot; +
            &quot;companyId BIGINT,&quot; +
            &quot;workId BIGINT,&quot; +
            &quot;name STRING,&quot; +
            &quot;gender STRING,&quot; +
            &quot;photo STRING,&quot; +
            &quot;PRIMARY KEY(companyId)&quot; +
            &quot;)&quot; +
            &quot;PARTITION BY HASH PARTITIONS 16 &quot; +
            &quot;STORED AS KUDU &quot; +
            &quot;TBLPROPERTIES (&quot; +
            &quot;&apos;kudu.master_addresses&apos; = &apos;node1:7051,node2:7051,node3:7051&apos;,&quot; +
            &quot;&apos;kudu.table_name&apos; = &apos;impala_kudu_test&apos;&quot; +
            &quot;);&quot;;

    try {
        ps = conn.prepareStatement(sql);
        ps.execute();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}


//查询数据
public static ResultSet queryRows(){
    try {
        //定义执行的sql语句
        String sql=&quot;select * from impala_kudu_test&quot;;
        ps = getConn().prepareStatement(sql);
        rs= ps.executeQuery();
    } catch (SQLException e) {
        e.printStackTrace();
    }

    return  rs;
}

//打印结果
public  static void printRows(ResultSet rs){
    /**
     private int companyId;
     private int workId;
     private  String name;
     private  String gender;
     private  String photo;
     */

    try {
        while (rs.next()){
            //获取表的每一行字段信息
            int companyId = rs.getInt(&quot;companyId&quot;);
            int workId = rs.getInt(&quot;workId&quot;);
            String name = rs.getString(&quot;name&quot;);
            String gender = rs.getString(&quot;gender&quot;);
            String photo = rs.getString(&quot;photo&quot;);
            System.out.print(&quot;companyId:&quot;+companyId+&quot; &quot;);
            System.out.print(&quot;workId:&quot;+workId+&quot; &quot;);
            System.out.print(&quot;name:&quot;+name+&quot; &quot;);
            System.out.print(&quot;gender:&quot;+gender+&quot; &quot;);
            System.out.println(&quot;photo:&quot;+photo);

        }
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        if(ps!=null){
            try {
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn !=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}


//插入数据
public static void insertRows(Person person){
    conn=getConn();
    String sql=&quot;insert into table impala_kudu_test(companyId,workId,name,gender,photo) values(?,?,?,?,?)&quot;;

    try {
        ps=conn.prepareStatement(sql);
        //给占位符？赋值
        ps.setInt(1,person.getCompanyId());
        ps.setInt(2,person.getWorkId());
        ps.setString(3,person.getName());
        ps.setString(4,person.getGender());
        ps.setString(5,person.getPhoto());
        ps.execute();

    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        if(ps !=null){
            try {
                //关闭
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn !=null){
            try {
                  //关闭
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}

//更新数据
public static void updateRows(Person person){
   //定义执行的sql语句
    String sql=&quot;update impala_kudu_test set workId=&quot;+person.getWorkId()+
            &quot;,name=&apos;&quot;+person.getName()+&quot;&apos; ,&quot;+&quot;gender=&apos;&quot;+person.getGender()+&quot;&apos; ,&quot;+
            &quot;photo=&apos;&quot;+person.getPhoto()+&quot;&apos; where companyId=&quot;+person.getCompanyId();

    try {
        ps= getConn().prepareStatement(sql);
        ps.execute();
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        if(ps !=null){
            try {
                  //关闭
                ps.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        if(conn !=null){
            try {
                  //关闭
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}

//删除数据
public   static void deleteRows(int companyId){

    //定义sql语句
    String sql=&quot;delete from impala_kudu_test where companyId=&quot;+companyId;
    try {
        ps =getConn().prepareStatement(sql);
        ps.execute();
    } catch (SQLException e) {
        e.printStackTrace();

    }
}</code></pre><p>   //删除表<br>    public static void dropTable() {<br>        String sql=”drop table if exists impala_kudu_test”;<br>        try {<br>            ps =getConn().prepareStatement(sql);<br>            ps.execute();<br>        } catch (SQLException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 代码测试运行</span><br></pre></td></tr></table></figure>

<p>package cn.itcast.impala.impala;</p>
<p>import java.sql.Connection;</p>
<p>public class ImpalaJdbcClient {<br>    public static void main(String[] args) {<br>        Connection conn = Contants.getConn();</p>
<pre><code>    //创建一个表
   Contants.createTable();

    //插入数据
   Contants.insertRows(new Person(1,100,&quot;lisi&quot;,&quot;male&quot;,&quot;lisi-photo&quot;));

    //查询表的数据
    ResultSet rs = Contants.queryRows();
    Contants.printRows(rs);

    //更新数据
    Contants.updateRows(new Person(1,200,&quot;zhangsan&quot;,&quot;male&quot;,&quot;zhangsan-photo&quot;));

    //删除数据
    Contants.deleteRows(1);

    //删除表
    Contants.dropTable();

}</code></pre><p>}<br>```</p>
<h1 id="六-Apache-KUDU的原理"><a href="#六-Apache-KUDU的原理" class="headerlink" title="六 Apache KUDU的原理"></a>六 Apache KUDU的原理</h1><h2 id="1．-table与schema"><a href="#1．-table与schema" class="headerlink" title="1． table与schema"></a>1． table与schema</h2><p>Kudu设计是面向结构化存储的，因此，Kudu的表需要用户在建表时定义它的Schema信息，这些Schema信息包含：列定义（含类型），Primary Key定义（用户指定的若干个列的有序组合）。数据的唯一性，依赖于用户所提供的Primary Key中的Column组合的值的唯一性。Kudu提供了Alter命令来增删列，但位于Primary Key中的列是不允许删除的。</p>
<p>从用户角度来看，Kudu是一种存储结构化数据表的存储系统。在一个Kudu集群中可以定义任意数量的table，每个table都需要预先定义好schema。每个table的列数是确定的，每一列都需要有名字和类型，每个表中可以把其中一列或多列定义为主键。这么看来，Kudu更像关系型数据库，而不是像HBase、Cassandra和MongoDB这些NoSQL数据库。不过Kudu目前还不能像关系型数据一样支持二级索引。</p>
<p>Kudu使用确定的列类型，而不是类似于NoSQL的“everything is byte”。带来好处：确定的列类型使Kudu可以进行类型特有的编码,可以提供元数据给其他上层查询工具。</p>
<h2 id="2-kudu底层数据模型"><a href="#2-kudu底层数据模型" class="headerlink" title="2 kudu底层数据模型"></a>2 kudu底层数据模型</h2><p>Kudu的底层数据文件的存储，未采用HDFS这样的较高抽象层次的分布式文件系统，而是自行开发了一套可基于Table/Tablet/Replica视图级别的底层存储系统。</p>
<p>这套实现基于如下的几个设计目标：</p>
<p>• 可提供快速的列式查询</p>
<p>• 可支持快速的随机更新</p>
<p>• 可提供更为稳定的查询性能保障</p>
<p><a href="https://manzhong.github.io/images/kudu/dcs.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/dcs.png" alt="img"></a></p>
<p>一张table会分成若干个tablet，每个tablet包括MetaData元信息及若干个RowSet。</p>
<p>RowSet包含一个MemRowSet及若干个DiskRowSet，DiskRowSet中包含一个BloomFile、Ad_hoc Index、BaseData、DeltaMem及若干个RedoFile和UndoFile。</p>
<p>MemRowSet：用于新数据insert及已在MemRowSet中的数据的更新，一个MemRowSet写满后会将数据刷到磁盘形成若干个DiskRowSet。默认是1G或者或者120S。</p>
<p>DiskRowSet：用于老数据的变更，后台定期对DiskRowSet做compaction，以删除没用的数据及合并历史数据，减少查询过程中的IO开销。</p>
<p>BloomFile：根据一个DiskRowSet中的key生成一个bloom filter，用于快速模糊定位某个key是否在DiskRowSet中。</p>
<p>Ad_hocIndex：是主键的索引，用于定位key在DiskRowSet中的具体哪个偏移位置。</p>
<p>BaseData是MemRowSet flush下来的数据，按列存储，按主键有序。</p>
<p>UndoFile是基于BaseData之前时间的历史数据，通过在BaseData上apply UndoFile中的记录，可以获得历史数据。</p>
<p>RedoFile是基于BaseData之后时间的变更记录，通过在BaseData上apply RedoFile中的记录，可获得较新的数据。</p>
<p>DeltaMem用于DiskRowSet中数据的变更，先写到内存中，写满后flush到磁盘形成RedoFile。</p>
<p>REDO与UNDO与关系型数据库中的REDO与UNDO日志类似（在关系型数据库中，REDO日志记录了更新后的数据，可以用来恢复尚未写入Data File的已成功事务更新的数据。而UNDO日志用来记录事务更新之前的数据，可以用来在事务失败时进行回滚）</p>
<p><a href="https://manzhong.github.io/images/kudu/dcs2.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/dcs2.png" alt="img"></a></p>
<p>MemRowSets可以对比理解成HBase中的MemStore, 而DiskRowSets可理解成HBase中的HFile。</p>
<p>MemRowSets中的数据被Flush到磁盘之后，形成DiskRowSets。 DisRowSets中的数据，按照32MB大小为单位，按序划分为一个个的DiskRowSet。 DiskRowSet中的数据按照Column进行组织，与Parquet类似。</p>
<p>这是Kudu可支持一些分析性查询的基础。每一个Column的数据被存储在一个相邻的数据区域，而这个数据区域进一步被细分成一个个的小的Page单元，与HBase File中的Block类似，对每一个Column Page可采用一些Encoding算法，以及一些通用的Compression算法。 既然可对Column Page可采用Encoding以及Compression算法，那么，对单条记录的更改就会比较困难了。</p>
<p>前面提到了Kudu可支持单条记录级别的更新/删除，是如何做到的？</p>
<p>与HBase类似，也是通过增加一条新的记录来描述这次更新/删除操作的。DiskRowSet是不可修改了，那么 KUDU 要如何应对数据的更新呢？在KUDU中，把DiskRowSet分为了两部分：base data、delta stores。base data 负责存储基础数据，delta stores负责存储 base data 中的变更数据.</p>
<p><a href="https://manzhong.github.io/images/kudu/dcs3.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/dcs3.png" alt="img"></a></p>
<p>如上图所示，数据从MemRowSet 刷到磁盘后就形成了一份 DiskRowSet（只包含 base data），每份 DiskRowSet 在内存中都会有一个对应的 DeltaMemStore，负责记录此 DiskRowSet 后续的数据变更（更新、删除）。DeltaMemStore 内部维护一个 B-树索引，映射到每个 row_offset 对应的数据变更。DeltaMemStore 数据增长到一定程度后转化成二进制文件存储到磁盘，形成一个 DeltaFile，随着 base data 对应数据的不断变更，DeltaFile 逐渐增长。</p>
<h2 id="3-tablet发现过程"><a href="#3-tablet发现过程" class="headerlink" title="3 tablet发现过程"></a>3 tablet发现过程</h2><p>当创建Kudu客户端时，其会从主服务器上获取tablet位置信息，然后直接与服务于该tablet的服务器进行交谈。</p>
<p>为了优化读取和写入路径，客户端将保留该信息的本地缓存，以防止他们在每个请求时需要查询主机的tablet位置信息。随着时间的推移，客户端的缓存可能会变得过时，并且当写入被发送到不再是tablet领导者的tablet服务器时，则将被拒绝。然后客户端将通过查询主服务器发现新领导者的位置来更新其缓存。</p>
<p><a href="https://manzhong.github.io/images/kudu/f.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/f.png" alt="img"></a></p>
<h2 id="4-kudu写流程"><a href="#4-kudu写流程" class="headerlink" title="4 kudu写流程"></a>4 kudu写流程</h2><p>当 Client 请求写数据时，先根据主键从Master Server中获取要访问的目标 Tablets，然后到依次对应的Tablet获取数据。</p>
<p>因为KUDU表存在主键约束，所以需要进行主键是否已经存在的判断，这里就涉及到之前说的索引结构对读写的优化了。一个Tablet中存在很多个RowSets，为了提升性能，我们要尽可能地减少要扫描的RowSets数量。</p>
<p>首先，我们先通过每个 RowSet 中记录的主键的（最大最小）范围，过滤掉一批不存在目标主键的RowSets，然后在根据RowSet中的布隆过滤器，过滤掉确定不存在目标主键的 RowSets，最后再通过RowSets中的 B-树索引，精确定位目标主键是否存在。</p>
<p>如果主键已经存在，则报错（主键重复），否则就进行写数据（写 MemRowSet）。</p>
<p><a href="https://manzhong.github.io/images/kudu/w.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/w.png" alt="img"></a></p>
<h2 id="5kudu读流程"><a href="#5kudu读流程" class="headerlink" title="5kudu读流程"></a>5kudu读流程</h2><p>数据读取过程大致如下：先根据要扫描数据的主键范围，定位到目标的Tablets，然后读取Tablets 中的RowSets。</p>
<p>在读取每个RowSet时，先根据主键过滤要scan范围，然后加载范围内的base data，再找到对应的delta stores，应用所有变更，最后union上MemRowSet中的内容，返回数据给Client。</p>
<p><a href="https://manzhong.github.io/images/kudu/r.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/r.png" alt="img"></a></p>
<h2 id="6kudu更新流程"><a href="#6kudu更新流程" class="headerlink" title="6kudu更新流程"></a>6kudu更新流程</h2><p>数据更新的核心是定位到待更新数据的位置，这块与写入的时候类似，就不展开了，等定位到具体位置后，然后将变更写到对应的delta store 中。</p>
<p><a href="https://manzhong.github.io/images/kudu/updata.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/kudu/updata.png" alt="img"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Kudo/" data-id="cjz2496dr0004x0u52zf81k1r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/08/MapReduce/">MapReduce</a>
          </li>
        
          <li>
            <a href="/2019/08/08/MapReduce2/">MapReduce2</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Yarn-资源调度/">Yarn-资源调度</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Java-JVM-初探/">Java-JVM-初探</a>
          </li>
        
          <li>
            <a href="/2019/08/08/数据库/">数据库</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>