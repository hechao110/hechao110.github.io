<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Hbase" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Hbase/" class="article-date">
  <time datetime="2019-08-08T03:56:57.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Hbase/">Hbase</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h1><h2 id="一概述"><a href="#一概述" class="headerlink" title="一概述"></a>一概述</h2><p>hbase是bigtable的开源java版本。是建立在hdfs之上，提供高可靠性、高性能、列存储、可伸缩、实时读写nosql的数据库系统。</p>
<p>它介于nosql和RDBMS之间，仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务(可通过hive支持来实现多表join等复杂操作)。</p>
<p>主要用来存储结构化和半结构化的松散数据。</p>
<p>Hbase查询数据功能很简单，不支持join等复杂操作，不支持复杂的事务（行级的事务）</p>
<p>Hbase中只支持的数据类型为：byte[]</p>
<p>与hadoop一样，Hbase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。</p>
<p>HBase中的表一般有这样的特点：</p>
<p>² 大：一个表可以有上十亿行，上百万列</p>
<p>² 面向列:面向列(族)的存储和权限控制，列(族)独立检索。</p>
<p>² 稀疏:对于为空(null)的列，并不占用存储空间，因此，表可以设计的非常稀疏。</p>
<p>HBase的发展历程</p>
<p>HBase的原型是Google的BigTable论文，受到了该论文思想的启发，目前作为Hadoop的子项目来开发维护，用于支持结构化的数据存储。</p>
<p>官方网站：<a href="http://hbase.apache.org/" target="_blank" rel="noopener">http://hbase.apache.org</a></p>
<p>* 2006年Google发表BigTable白皮书</p>
<p>* 2006年开始开发HBase</p>
<p>* 2008 HBase成为了 Hadoop的子项目</p>
<p>* 2010年HBase成为Apache顶级项目</p>
<h2 id="二HBASE与Hadoop的关系"><a href="#二HBASE与Hadoop的关系" class="headerlink" title="二HBASE与Hadoop的关系"></a>二HBASE与Hadoop的关系</h2><h2 id="1、HDFS"><a href="#1、HDFS" class="headerlink" title="1、HDFS"></a>1、HDFS</h2><p>* 为分布式存储提供文件系统</p>
<p>* 针对存储大尺寸的文件进行优化，不需要对HDFS上的文件进行随机读写</p>
<p>* 直接使用文件</p>
<p>* 数据模型不灵活</p>
<p>* 使用文件系统和处理框架</p>
<p>* 优化一次写入，多次读取的方式</p>
<h2 id="2、HBase"><a href="#2、HBase" class="headerlink" title="2、HBase"></a>2、HBase</h2><p>* 提供表状的面向列的数据存储</p>
<p>* 针对表状数据的随机读写进行优化</p>
<p>* 使用key-value操作数据</p>
<p>* 提供灵活的数据模型</p>
<p>* 使用表状存储，支持MapReduce，依赖HDFS</p>
<p>* 优化了多次读，以及多次写</p>
<p>hbase是基于hdfs的，hbase的数据都是存储在hdfs上面的。hbase支持随机读写，hbase的数据存储在hdfs上面的，hbase是如何基于hdfs的数据做到随机读写的？？</p>
<h2 id="三rdbms与HBASE的关系"><a href="#三rdbms与HBASE的关系" class="headerlink" title="三rdbms与HBASE的关系"></a>三rdbms与HBASE的关系</h2><h2 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、关系型数据库</h2><p><strong>结构：</strong></p>
<p>* 数据库以表的形式存在</p>
<p>* 支持FAT、NTFS、EXT、文件系统</p>
<p>* 使用Commit log存储日志</p>
<p>* 参考系统是坐标系统</p>
<p>* 使用主键（PK）</p>
<p>* 支持分区</p>
<p>* 使用行、列、单元格</p>
<p><strong>功能：</strong></p>
<p>* 支持向上扩展</p>
<p>* 使用SQL查询</p>
<p>* 面向行，即每一行都是一个连续单元</p>
<p>* 数据总量依赖于服务器配置</p>
<p>* 具有ACID支持</p>
<p>* 适合结构化数据</p>
<p>* 传统关系型数据库一般都是中心化的</p>
<p>* 支持事务</p>
<p>* 支持Join</p>
<h2 id="2、HBase-1"><a href="#2、HBase-1" class="headerlink" title="2、HBase"></a>2、HBase</h2><p><strong>结构：</strong></p>
<p>* 数据库以region的形式存在</p>
<p>* 支持HDFS文件系统</p>
<p>* 使用WAL（Write-Ahead Logs）存储日志</p>
<p>* 参考系统是Zookeeper</p>
<p>* 使用行键（row key）</p>
<p>* 支持分片</p>
<p>* 使用行、列、列族和单元格</p>
<p><strong>功能：</strong></p>
<p>* 支持向外扩展</p>
<p>* 使用API和MapReduce来访问HBase表数据</p>
<p>* 面向列，即每一列都是一个连续的单元</p>
<p>* 数据总量不依赖具体某台机器，而取决于机器数量</p>
<p>* HBase不支持ACID（Atomicity、Consistency、Isolation、Durability）</p>
<p>* 适合结构化数据和非结构化数据</p>
<p>* 一般都是分布式的</p>
<p>* HBase不支持事务，支持的是单行数据的事务操作</p>
<p>* 不支持Join</p>
<h2 id="四-hbase-特点"><a href="#四-hbase-特点" class="headerlink" title="四 hbase 特点"></a>四 hbase 特点</h2><p><strong>1**</strong>）海量存储**</p>
<p>Hbase适合存储PB级别的海量数据，在PB级别的数据以及采用廉价PC存储的情况下，能在几十到百毫秒内返回数据。这与Hbase的极易扩展性息息相关。正式因为Hbase良好的扩展性，才为海量数据的存储提供了便利。</p>
<p><strong>2**</strong>）列式存储**</p>
<p>这里的列式存储其实说的是列族存储，Hbase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。</p>
<p><strong>3**</strong>）极易扩展**</p>
<p>Hbase的扩展性主要体现在两个方面，一个是基于上层处理能力（RegionServer）的扩展，一个是基于存储的扩展（HDFS）。<br>通过横向添加RegionSever的机器，进行水平扩展，提升Hbase上层的处理能力，提升Hbsae服务更多Region的能力。</p>
<p>备注：RegionServer的作用是管理region、承接业务的访问，这个后面会详细的介绍通过横向添加Datanode的机器，进行存储层扩容，提升Hbase的数据存储能力和提升后端存储的读写能力。</p>
<p><strong>4**</strong>）高并发**</p>
<p>由于目前大部分使用Hbase的架构，都是采用的廉价PC，因此单个IO的延迟其实并不小，一般在几十到上百ms之间。这里说的高并发，主要是在并发的情况下，Hbase的单个IO延迟下降并不多。能获得高并发、低延迟的服务。</p>
<p><strong>5**</strong>）稀疏**</p>
<p>稀疏主要是针对Hbase列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的。</p>
<h2 id="五架构"><a href="#五架构" class="headerlink" title="五架构"></a>五架构</h2><p><a href="https://manzhong.github.io/images/Hbase/hbase%E6%9E%B6%E6%9E%84.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Hbase/hbase%E6%9E%B6%E6%9E%84.png" alt="img"></a></p>
<p><a href="https://manzhong.github.io/images/Hbase/hbase2.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Hbase/hbase2.png" alt="img"></a></p>
<h2 id="1、HMaster"><a href="#1、HMaster" class="headerlink" title="1、HMaster"></a>1、HMaster</h2><p><strong>功能：</strong></p>
<p>1) 监控RegionServer</p>
<p>2) 处理RegionServer故障转移</p>
<p>3) 处理元数据的变更</p>
<p>4) 处理region的分配或移除</p>
<p>5) 在空闲时间进行数据的负载均衡</p>
<p>6) 通过Zookeeper发布自己的位置给客户端</p>
<h2 id="2、RegionServer"><a href="#2、RegionServer" class="headerlink" title="2、RegionServer"></a>2、RegionServer</h2><p><strong>功能：</strong></p>
<p>1) 负责存储HBase的实际数据</p>
<p>2) 处理分配给它的Region</p>
<p>3) 刷新缓存到HDFS</p>
<p>4) 维护HLog</p>
<p>5) 执行压缩</p>
<p>6) 负责处理Region分片</p>
<p><strong>组件：</strong></p>
<p><strong>1) Write-Ahead logs</strong></p>
<p>HBase的修改记录，当对HBase读写数据的时候，数据不是直接写进磁盘，它会在内存中保留一段时间（时间以及数据量阈值可以设定）。但把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，然后再写入内存中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。</p>
<p><strong>2) HFile</strong></p>
<p>这是在磁盘上保存原始数据的实际的物理文件，是实际的存储文件。</p>
<p><strong>3) Store</strong></p>
<p>HFile存储在Store中，一个Store对应HBase表中的一个列族。</p>
<p><strong>4) MemStore</strong></p>
<p>顾名思义，就是内存存储，位于内存中，用来保存当前的数据操作，所以当数据保存在WAL中之后，RegsionServer会在内存中存储键值对。</p>
<p><strong>5) Region</strong></p>
<p>Hbase表的分片，HBase表会根据RowKey值被切分成不同的region存储在RegionServer中，在一个RegionServer中可以有多个不同的region。</p>
<p><strong>存储架构:</strong></p>
<p>主节点：HMaster</p>
<p> 监控regionServer的健康状态</p>
<p> 处理regionServer的故障转移</p>
<p> 处理元数据变更</p>
<p> 处理region的分配或者移除</p>
<p> 空闲时间做数据的负载均衡</p>
<p>从节点：HRegionServer</p>
<p> 负责存储HBase的实际数据</p>
<p> 处理分配给他的region</p>
<p> 刷新缓存的数据到HDFS上面去</p>
<p> 维护HLog</p>
<p> 执行数据的压缩</p>
<p> 负责处理region的分片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个HRegionServer = 1个HLog  +  很多个region</span><br><span class="line">1个region  = 很多个store模块</span><br><span class="line">1个store模块 =  1个memoryStore + 很多个storeFile    当memoryStore达到128m或者一个小时 会落地到storeFile中</span><br><span class="line">HLog：hbase当中预写日志模块，write ahead  log</span><br><span class="line">将storeFile 文件合并压缩存到hdfs上格式Hfile</span><br><span class="line">当memoryStore达到128m或者一个小时 会落地到storeFile中</span><br><span class="line">当hdfs的数据达到阀值,会分region,创建另一个region存储这个数据  用其他的HregionServer 管理  对比MySQL的分库分表</span><br></pre></td></tr></table></figure>

<h2 id="六集群搭建"><a href="#六集群搭建" class="headerlink" title="六集群搭建"></a>六集群搭建</h2><p>注意事项：Hbase强依赖于HDFS以及zookeeper，所以安装Hbase之前一定要保证Hadoop和zookeeper正常启动</p>
<p>上传压缩包并解压:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf hbase-2.0.0-bin.tar.gz -C /export/servers/</span><br></pre></td></tr></table></figure>

<p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/hbase-2.0.0/conf</span><br></pre></td></tr></table></figure>

<p>1 修改hbase-env.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim hbase-env.sh</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/export/servers/jdk1.8.0_141</span><br><span class="line">export HBASE_MANAGES_ZK=false</span><br></pre></td></tr></table></figure>

<p>2 修改hbase-site.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/hbase-2.0.0/conf</span><br><span class="line">vim hbase-site.xml</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;!-- hbase根路径 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;hdfs://node01:8020/hbase&lt;/value&gt;  </span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;!-- 指定hbase为分布式 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 0.98后的新变动，之前版本没有.port,默认端口为60000 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hbase.master.port&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;16000&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">                &lt;value&gt;node01:2181,node02:2181,node03:2181&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;!-- 指顶存在哪里 --&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">                &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;/export/servers/zookeeper-3.4.9/zkdatas&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>3 修改regionservers</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node01</span><br><span class="line">node02</span><br><span class="line">node03</span><br></pre></td></tr></table></figure>

<p>4 创建back-masters文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/hbase-2.0.0/conf</span><br><span class="line">vim backup-masters</span><br><span class="line">node02</span><br></pre></td></tr></table></figure>

<p>向其他节点发送安装包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r hbase-2.0.0/ node02:$PWD</span><br></pre></td></tr></table></figure>

<p>三台节点都要创建软连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /export/servers/hadoop-2.7.5/etc/hadoop/core-site.xml /export/servers/hbase-2.0.0/conf/core-site.xml</span><br><span class="line">ln -s /export/servers/hadoop-2.7.5/etc/hadoop/hdfs-site.xml /export/servers/hbase-2.0.0/conf/hdfs-site.xml</span><br></pre></td></tr></table></figure>

<p>三台节点都要配值环境变量;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">export HBASE_HOME=/export/servers/hbase-2.0.0</span><br><span class="line">export PATH=:$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>集群启动:</p>
<p>1在第一台机器上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/hbase-2.0.0</span><br><span class="line">bin/start-hbase.sh</span><br></pre></td></tr></table></figure>

<p>警告提示：HBase启动的时候会产生一个警告，这是因为jdk7与jdk8的问题导致的，如果linux服务器安装jdk8就会产生这样的一个警告</p>
<p>我们可以只是掉所有机器的hbase-env.sh当中的</p>
<p>“HBASE_MASTER_OPTS”和“HBASE_REGIONSERVER_OPTS”配置 来解决这个问题。不过警告不影响我们正常运行，可以不用解决</p>
<p>2另外一种启动方式：</p>
<p>我们也可以执行以下命令单节点进行启动</p>
<p>启动HMaster命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hbase-daemon.sh start master</span><br></pre></td></tr></table></figure>

<p>启动HRegionServer命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure>

<p>页面访问:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://node02:16010/master-status</span><br><span class="line">http://node01:16010/master-status</span><br></pre></td></tr></table></figure>

<h2 id="HBase的表模型"><a href="#HBase的表模型" class="headerlink" title="HBase的表模型"></a>HBase的表模型</h2><p>rowKey：行键，每一条数据都是使用行键来进行唯一标识的</p>
<p>columnFamily：列族。列族下面可以有很多列</p>
<p>column：列的概念。每一个列都必须归属于某一个列族</p>
<p>timestamp：时间戳，每条数据都会有时间戳的概念</p>
<p>versionNum：版本号，每条数据都会有版本号，每次数据变化，版本号都会进行更新</p>
<h2 id="七-HBASE常用shell操作"><a href="#七-HBASE常用shell操作" class="headerlink" title="七 HBASE常用shell操作"></a>七 HBASE常用shell操作</h2><h2 id="1、进入HBase客户端命令操作界面"><a href="#1、进入HBase客户端命令操作界面" class="headerlink" title="1、进入HBase客户端命令操作界面"></a>1、进入HBase客户端命令操作界面</h2><p>node01服务器执行以下命令进入hbase的shell客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/hbase-2.0.0</span><br><span class="line">bin/hbase shell</span><br></pre></td></tr></table></figure>

<h2 id="2、查看帮助命令"><a href="#2、查看帮助命令" class="headerlink" title="2、查看帮助命令"></a>2、查看帮助命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; help</span><br></pre></td></tr></table></figure>

<h2 id="3、查看当前数据库中有哪些表"><a href="#3、查看当前数据库中有哪些表" class="headerlink" title="3、查看当前数据库中有哪些表"></a>3、查看当前数据库中有哪些表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):002:0&gt; list</span><br></pre></td></tr></table></figure>

<h2 id="4、创建一张表"><a href="#4、创建一张表" class="headerlink" title="4、创建一张表"></a>4、创建一张表</h2><p>创建user表，包含info、data两个列族</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):010:0&gt; create &apos;user&apos;, &apos;info&apos;, &apos;data&apos;</span><br><span class="line">或者</span><br><span class="line">hbase(main):010:0&gt; create &apos;user&apos;, &#123;NAME =&gt; &apos;info&apos;, VERSIONS =&gt; &apos;3&apos;&#125;，&#123;NAME =&gt; &apos;data&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>若建表时指定了多个版本,则在更新操作时,会保存多个版本 ,会把以前的也会保存,但查询时,查到的是最新的,若想获取以前的可以指定版本去查询.</p>
<h2 id="5、添加数据操作"><a href="#5、添加数据操作" class="headerlink" title="5、添加数据操作"></a>5、添加数据操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">向user表中插入信息，row key为rk0001，列族info中添加name列标示符，值为zhangsan</span><br><span class="line">hbase(main):011:0&gt; put &apos;user&apos;, &apos;rk0001&apos;, &apos;info:name&apos;, &apos;zhangsan&apos;</span><br><span class="line">向user表中插入信息，row key为rk0001，列族info中添加gender列标示符，值为female</span><br><span class="line">hbase(main):012:0&gt; put &apos;user&apos;, &apos;rk0001&apos;, &apos;info:gender&apos;, &apos;female&apos;</span><br><span class="line">向user表中插入信息，row key为rk0001，列族info中添加age列标示符，值为20</span><br><span class="line">hbase(main):013:0&gt; put &apos;user&apos;, &apos;rk0001&apos;, &apos;info:age&apos;, 20</span><br><span class="line">向user表中插入信息，row key为rk0001，列族data中添加pic列标示符，值为picture</span><br><span class="line">hbase(main):014:0&gt; put &apos;user&apos;, &apos;rk0001&apos;, &apos;data:pic&apos;, &apos;picture&apos;</span><br></pre></td></tr></table></figure>

<h2 id="6、查询数据操作"><a href="#6、查询数据操作" class="headerlink" title="6、查询数据操作"></a>6、查询数据操作</h2><p>第一种查询方式： get rowkey 直接获取某一条数据</p>
<p>第二种查询方式 ： scan startRow stopRow 范围值扫描</p>
<p>第三种查询方式：scan tableName 全表扫描</p>
<h3 id="1、通过rowkey进行查询"><a href="#1、通过rowkey进行查询" class="headerlink" title="1、通过rowkey进行查询"></a>1、通过rowkey进行查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取user表中row key为rk0001的所有信息</span><br><span class="line"></span><br><span class="line">hbase(main):015:0&gt; get &apos;user&apos;, &apos;rk0001&apos;</span><br></pre></td></tr></table></figure>

<h3 id="2、查看rowkey下面的某个列族的信息"><a href="#2、查看rowkey下面的某个列族的信息" class="headerlink" title="2、查看rowkey下面的某个列族的信息"></a>2、查看rowkey下面的某个列族的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取user表中row key为rk0001，info列族的所有信息</span><br><span class="line"></span><br><span class="line">hbase(main):016:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &apos;info&apos;</span><br></pre></td></tr></table></figure>

<h3 id="3、查看rowkey指定列族指定字段的值"><a href="#3、查看rowkey指定列族指定字段的值" class="headerlink" title="3、查看rowkey指定列族指定字段的值"></a>3、查看rowkey指定列族指定字段的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取user表中row key为rk0001，info列族的name、age列标示符的信息</span><br><span class="line"></span><br><span class="line">hbase(main):017:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &apos;info:name&apos;, &apos;info:age&apos;</span><br></pre></td></tr></table></figure>

<h3 id="4、查看rowkey指定多个列族的信息"><a href="#4、查看rowkey指定多个列族的信息" class="headerlink" title="4、查看rowkey指定多个列族的信息"></a>4、查看rowkey指定多个列族的信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取user表中row key为rk0001，info、data列族的信息</span><br><span class="line">hbase(main):018:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &apos;info&apos;, &apos;data&apos;</span><br><span class="line">或者你也可以这样写</span><br><span class="line">hbase(main):019:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &#123;COLUMN =&gt; [&apos;info&apos;, &apos;data&apos;]&#125;</span><br><span class="line">或者你也可以这样写，也行</span><br><span class="line">hbase(main):020:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &#123;COLUMN =&gt; [&apos;info:name&apos;, &apos;data:pic&apos;]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、指定rowkey与列值查询"><a href="#4、指定rowkey与列值查询" class="headerlink" title="4、指定rowkey与列值查询"></a>4、指定rowkey与列值查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取user表中row key为rk0001，cell的值为zhangsan的信息</span><br><span class="line"></span><br><span class="line">hbase(main):030:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &#123;FILTER =&gt; &quot;ValueFilter(=, &apos;binary:zhangsan&apos;)&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、指定rowkey与列值模糊查询"><a href="#5、指定rowkey与列值模糊查询" class="headerlink" title="5、指定rowkey与列值模糊查询"></a>5、指定rowkey与列值模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取user表中row key为rk0001，列标示符中含有a的信息</span><br><span class="line">hbase(main):031:0&gt; get &apos;user&apos;, &apos;rk0001&apos;, &#123;FILTER =&gt; &quot;(QualifierFilter(=,&apos;substring:a&apos;))&quot;&#125;</span><br><span class="line">继续插入一批数据</span><br><span class="line">hbase(main):032:0&gt; put &apos;user&apos;, &apos;rk0002&apos;, &apos;info:name&apos;, &apos;fanbingbing&apos;</span><br><span class="line">hbase(main):033:0&gt; put &apos;user&apos;, &apos;rk0002&apos;, &apos;info:gender&apos;, &apos;female&apos;</span><br><span class="line">hbase(main):034:0&gt; put &apos;user&apos;, &apos;rk0002&apos;, &apos;info:nationality&apos;, &apos;中国&apos;</span><br><span class="line">hbase(main):035:0&gt; get &apos;user&apos;, &apos;rk0002&apos;, &#123;FILTER =&gt; &quot;ValueFilter(=, &apos;binary:中国&apos;)&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、查询所有数据"><a href="#6、查询所有数据" class="headerlink" title="6、查询所有数据"></a>6、查询所有数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询user表中的所有信息</span><br><span class="line">scan &apos;user&apos;</span><br></pre></td></tr></table></figure>

<h3 id="7、列族查询"><a href="#7、列族查询" class="headerlink" title="7、列族查询"></a>7、列族查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询user表中列族为info的信息</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; &apos;info&apos;&#125;</span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; &apos;info&apos;, RAW =&gt; true, VERSIONS =&gt; 5&#125;</span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; &apos;info&apos;, RAW =&gt; true, VERSIONS =&gt; 3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、多列族查询"><a href="#8、多列族查询" class="headerlink" title="8、多列族查询"></a>8、多列族查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询user表中列族为info和data的信息</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; [&apos;info&apos;, &apos;data&apos;]&#125;</span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; [&apos;info:name&apos;, &apos;data:pic&apos;]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、指定列族与某个列名查询"><a href="#9、指定列族与某个列名查询" class="headerlink" title="9、指定列族与某个列名查询"></a>9、指定列族与某个列名查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询user表中列族为info、列标示符为name的信息</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; &apos;info:name&apos;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、指定列族与列名以及限定版本查询"><a href="#10、指定列族与列名以及限定版本查询" class="headerlink" title="10、指定列族与列名以及限定版本查询"></a>10、指定列族与列名以及限定版本查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询user表中列族为info、列标示符为name的信息,并且版本最新的5个</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; &apos;info:name&apos;, VERSIONS =&gt; 5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、指定多个列族与按照数据值模糊查询"><a href="#11、指定多个列族与按照数据值模糊查询" class="headerlink" title="11、指定多个列族与按照数据值模糊查询"></a>11、指定多个列族与按照数据值模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询user表中列族为info和data且列标示符中含有a字符的信息</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; [&apos;info&apos;, &apos;data&apos;], FILTER =&gt; &quot;(QualifierFilter(=,&apos;substring:a&apos;))&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、rowkey的范围值查询"><a href="#12、rowkey的范围值查询" class="headerlink" title="12、rowkey的范围值查询"></a>12、rowkey的范围值查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询user表中列族为info，rk范围是[rk0001, rk0003)的数据</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;COLUMNS =&gt; &apos;info&apos;, STARTROW =&gt; &apos;rk0001&apos;, ENDROW =&gt; &apos;rk0003&apos;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、指定rowkey模糊查询"><a href="#13、指定rowkey模糊查询" class="headerlink" title="13、指定rowkey模糊查询"></a>13、指定rowkey模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询user表中row key以rk字符开头的</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;,&#123;FILTER=&gt;&quot;PrefixFilter(&apos;rk&apos;)&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14、指定数据范围值查询"><a href="#14、指定数据范围值查询" class="headerlink" title="14、指定数据范围值查询"></a>14、指定数据范围值查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询user表中指定范围的数据</span><br><span class="line"></span><br><span class="line">scan &apos;user&apos;, &#123;TIMERANGE =&gt; [1392368783980, 1392380169184]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、更新数据操作"><a href="#7、更新数据操作" class="headerlink" title="7、更新数据操作"></a>7、更新数据操作</h2><h3 id="1、更新数据值"><a href="#1、更新数据值" class="headerlink" title="1、更新数据值"></a>1、更新数据值</h3><p>更新操作同插入操作一模一样，只不过有数据就更新，没数据就添加</p>
<h3 id="2、更新版本号"><a href="#2、更新版本号" class="headerlink" title="2、更新版本号"></a>2、更新版本号</h3><p>将user表的f1列族版本号改为5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;user&apos;,NAME =&gt;&apos;info&apos;,VERSIONS =&gt;5</span><br></pre></td></tr></table></figure>

<h2 id="8、删除数据以及删除表操作"><a href="#8、删除数据以及删除表操作" class="headerlink" title="8、删除数据以及删除表操作"></a>8、删除数据以及删除表操作</h2><h3 id="1、指定rowkey以及列名进行删除"><a href="#1、指定rowkey以及列名进行删除" class="headerlink" title="1、指定rowkey以及列名进行删除"></a>1、指定rowkey以及列名进行删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除user表row key为rk0001，列标示符为info:name的数据</span><br><span class="line">delete &apos;user&apos;,&apos;rk001&apos;,&apos;info;name&apos;</span><br></pre></td></tr></table></figure>

<h3 id="2、指定rowkey，列名以及字段值进行删除"><a href="#2、指定rowkey，列名以及字段值进行删除" class="headerlink" title="2、指定rowkey，列名以及字段值进行删除"></a>2、指定rowkey，列名以及字段值进行删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除user表row key为rk0001，列标示符为info:name，timestamp为1392383705316的数据</span><br><span class="line">delete &apos;user&apos;,&apos;rk001&apos;,&apos;info:name&apos;,1392383705316</span><br></pre></td></tr></table></figure>

<h3 id="3、删除一个列族"><a href="#3、删除一个列族" class="headerlink" title="3、删除一个列族"></a>3、删除一个列族</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;user&apos;,NAME =&gt; &apos;info&apos;,METHOD =&gt;&apos;delete&apos;</span><br><span class="line">或者</span><br><span class="line">alter &apos;user&apos;,&apos;delete&apos; =&gt;&apos;info&apos;</span><br></pre></td></tr></table></figure>

<h3 id="4、清空表数据"><a href="#4、清空表数据" class="headerlink" title="4、清空表数据"></a>4、清空表数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate &apos;user&apos;</span><br></pre></td></tr></table></figure>

<h3 id="5、删除表"><a href="#5、删除表" class="headerlink" title="5、删除表"></a>5、删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">该表处于disable状态:</span><br><span class="line">disable &apos;user&apos;</span><br><span class="line">然后删除表:</span><br><span class="line">drop &apos;user&apos;</span><br><span class="line">如直接drop表 会报错 Drop the named table. Table must first be disabled</span><br></pre></td></tr></table></figure>

<h2 id="9、统计一张表有多少行数据"><a href="#9、统计一张表有多少行数据" class="headerlink" title="9、统计一张表有多少行数据"></a>9、统计一张表有多少行数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count &apos;user&apos;</span><br></pre></td></tr></table></figure>

<h2 id="八-HBASE的高级shell管理命令"><a href="#八-HBASE的高级shell管理命令" class="headerlink" title="八 HBASE的高级shell管理命令"></a>八 HBASE的高级shell管理命令</h2><h2 id="1、status"><a href="#1、status" class="headerlink" title="1、status"></a>1、status</h2><p>例如：显示服务器状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status &apos;node01&apos;</span><br></pre></td></tr></table></figure>

<h2 id="2、whoami"><a href="#2、whoami" class="headerlink" title="2、whoami"></a>2、whoami</h2><p>显示HBase当前用户，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>

<h2 id="3、list"><a href="#3、list" class="headerlink" title="3、list"></a>3、list</h2><p>显示当前所有的表</p>
<h2 id="4、count"><a href="#4、count" class="headerlink" title="4、count"></a>4、count</h2><p>统计指定表的记录数，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; count &apos;user&apos;</span><br></pre></td></tr></table></figure>

<h2 id="5、describe"><a href="#5、describe" class="headerlink" title="5、describe"></a>5、describe</h2><p>展示表结构信息</p>
<h2 id="6、exists"><a href="#6、exists" class="headerlink" title="6、exists"></a>6、exists</h2><p>检查表是否存在，适用于表量特别多的情况</p>
<h2 id="7、is-enabled、is-disabled"><a href="#7、is-enabled、is-disabled" class="headerlink" title="7、is_enabled、is_disabled"></a>7、is_enabled、is_disabled</h2><p>检查表是否启用或禁用</p>
<h2 id="8、alter"><a href="#8、alter" class="headerlink" title="8、alter"></a>8、alter</h2><p>该命令可以改变表和列族的模式，例如：</p>
<p><strong>为当前表增加列族：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;user&apos;,NAME=&gt; &apos;CF2&apos;,versions =&gt;2</span><br></pre></td></tr></table></figure>

<p><strong>为当前表删除列族：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter &apos;user&apos;.&apos;delete&apos;=&gt;&apos;cf2&apos;</span><br></pre></td></tr></table></figure>

<h2 id="9、disable-enable"><a href="#9、disable-enable" class="headerlink" title="9、disable/enable"></a>9、disable/enable</h2><p>禁用一张表/启用一张表</p>
<h2 id="10、drop"><a href="#10、drop" class="headerlink" title="10、drop"></a>10、drop</h2><p>删除一张表，记得在删除表之前必须先禁用</p>
<h2 id="11、truncate"><a href="#11、truncate" class="headerlink" title="11、truncate"></a>11、truncate</h2><p>禁用表-删除表-创建表</p>
<h2 id="九-HBASE的java代码开发"><a href="#九-HBASE的java代码开发" class="headerlink" title="九 HBASE的java代码开发"></a>九 HBASE的java代码开发</h2><p>依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">       &lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-client --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-server --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    			&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">    			&lt;artifactId&gt;hbase-server&lt;/artifactId&gt;</span><br><span class="line">    			&lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.testng&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;testng&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.14.3&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;!--    &lt;verbal&gt;true&lt;/verbal&gt;--&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>步骤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一 配置类  设置zookeeper的连接地址</span><br><span class="line">* 二根据 配置传参  得到连接对象</span><br><span class="line">* 三 根据连接对象 得到管理员对象</span><br><span class="line">* 四创建表的对象  创建列簇的对象  将列簇的对象添加到 表对象</span><br><span class="line">* 五 管理员对象创建表  并将表对象传入</span><br></pre></td></tr></table></figure>

<p><strong>1创建表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 创建hbase表 myuser，带有两个列族 f1  f2</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void createTable() throws IOException &#123;</span><br><span class="line">      //连接hbase集群</span><br><span class="line">      Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">      //指定hbase的zk连接地址</span><br><span class="line">      configuration.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line">      Connection connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">      //获取管理员对象</span><br><span class="line">      Admin admin = connection.getAdmin();</span><br><span class="line">      //通过管理员对象创建表</span><br><span class="line">      HTableDescriptor hTableDescriptor = new HTableDescriptor(TableName.valueOf(&quot;myuser&quot;));</span><br><span class="line">      //给我们的表添加列族，指定两个列族  f1   f2</span><br><span class="line">      HColumnDescriptor f1 = new HColumnDescriptor(&quot;f1&quot;);</span><br><span class="line">      HColumnDescriptor f2 = new HColumnDescriptor(&quot;f2&quot;);</span><br><span class="line">      //将两个列族设置到  hTableDescriptor里面去</span><br><span class="line">      hTableDescriptor.addFamily(f1);</span><br><span class="line">      hTableDescriptor.addFamily(f2);</span><br><span class="line">      //创建表</span><br><span class="line">      admin.createTable(hTableDescriptor);</span><br><span class="line">      //关闭资源</span><br><span class="line">      admin.close();</span><br><span class="line">      connection.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2插入数据</strong></p>
<p>步骤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">一 配置类 设置zookeeper连接地址</span><br><span class="line">二  根据配置类 获取连接对象</span><br><span class="line">三  根据连接对象 获得表对象 传参为表名 </span><br><span class="line">四  new一个put对象 传参为 rowkey的值得字节数组</span><br><span class="line">五  根据put对象 添加例</span><br><span class="line">六 表对象 调put方法 传参为put对象  </span><br><span class="line">七  关闭表</span><br><span class="line">/***</span><br><span class="line">    * 向表当中添加数据</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public  void  addData() throws IOException &#123;</span><br><span class="line">       //获取连接</span><br><span class="line">       Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">       configuration.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line">       Connection connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">       //获取表对象</span><br><span class="line">       Table myuser = connection.getTable(TableName.valueOf(&quot;myuser&quot;));</span><br><span class="line">       Put put = new Put(&quot;0001&quot;.getBytes());</span><br><span class="line">       put.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(), Bytes.toBytes(1));</span><br><span class="line">       put.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;张三&quot;));</span><br><span class="line">       put.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(18));</span><br><span class="line">       put.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;地球人&quot;));</span><br><span class="line">       put.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;15845678952&quot;));</span><br><span class="line">       myuser.put(put);</span><br><span class="line">       //关闭表</span><br><span class="line">       myuser.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询数据</strong></p>
<p>初始化数据用于查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void insertBatchData() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        //获取连接</span><br><span class="line">        Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.quorum&quot;, &quot;node01:2181,node02:2181&quot;);</span><br><span class="line">        Connection connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        //获取表</span><br><span class="line">        Table myuser = connection.getTable(TableName.valueOf(&quot;myuser&quot;));</span><br><span class="line">        //创建put对象，并指定rowkey</span><br><span class="line">        Put put = new Put(&quot;0002&quot;.getBytes());</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(),Bytes.toBytes(1));</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;曹操&quot;));</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(30));</span><br><span class="line">        put.addColumn(&quot;f2&quot;.getBytes(),&quot;sex&quot;.getBytes(),Bytes.toBytes(&quot;1&quot;));</span><br><span class="line">        put.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;沛国谯县&quot;));</span><br><span class="line">        put.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;16888888888&quot;));</span><br><span class="line">        put.addColumn(&quot;f2&quot;.getBytes(),&quot;say&quot;.getBytes(),Bytes.toBytes(&quot;helloworld&quot;));</span><br><span class="line"></span><br><span class="line">        Put put2 = new Put(&quot;0003&quot;.getBytes());</span><br><span class="line">        put2.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(),Bytes.toBytes(2));</span><br><span class="line">        put2.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;刘备&quot;));</span><br><span class="line">        put2.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(32));</span><br><span class="line">        put2.addColumn(&quot;f2&quot;.getBytes(),&quot;sex&quot;.getBytes(),Bytes.toBytes(&quot;1&quot;));</span><br><span class="line">        put2.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;幽州涿郡涿县&quot;));</span><br><span class="line">        put2.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;17888888888&quot;));</span><br><span class="line">        put2.addColumn(&quot;f2&quot;.getBytes(),&quot;say&quot;.getBytes(),Bytes.toBytes(&quot;talk is cheap , show me the code&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Put put3 = new Put(&quot;0004&quot;.getBytes());</span><br><span class="line">        put3.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(),Bytes.toBytes(3));</span><br><span class="line">        put3.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;孙权&quot;));</span><br><span class="line">        put3.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(35));</span><br><span class="line">        put3.addColumn(&quot;f2&quot;.getBytes(),&quot;sex&quot;.getBytes(),Bytes.toBytes(&quot;1&quot;));</span><br><span class="line">        put3.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;下邳&quot;));</span><br><span class="line">        put3.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;12888888888&quot;));</span><br><span class="line">        put3.addColumn(&quot;f2&quot;.getBytes(),&quot;say&quot;.getBytes(),Bytes.toBytes(&quot;what are you 弄啥嘞！&quot;));</span><br><span class="line"></span><br><span class="line">        Put put4 = new Put(&quot;0005&quot;.getBytes());</span><br><span class="line">        put4.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(),Bytes.toBytes(4));</span><br><span class="line">        put4.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;诸葛亮&quot;));</span><br><span class="line">        put4.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(28));</span><br><span class="line">        put4.addColumn(&quot;f2&quot;.getBytes(),&quot;sex&quot;.getBytes(),Bytes.toBytes(&quot;1&quot;));</span><br><span class="line">        put4.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;四川隆中&quot;));</span><br><span class="line">        put4.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;14888888888&quot;));</span><br><span class="line">        put4.addColumn(&quot;f2&quot;.getBytes(),&quot;say&quot;.getBytes(),Bytes.toBytes(&quot;出师表你背了嘛&quot;));</span><br><span class="line"></span><br><span class="line">        Put put5 = new Put(&quot;0005&quot;.getBytes());</span><br><span class="line">        put5.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(),Bytes.toBytes(5));</span><br><span class="line">        put5.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;司马懿&quot;));</span><br><span class="line">        put5.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(27));</span><br><span class="line">        put5.addColumn(&quot;f2&quot;.getBytes(),&quot;sex&quot;.getBytes(),Bytes.toBytes(&quot;1&quot;));</span><br><span class="line">        put5.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;哪里人有待考究&quot;));</span><br><span class="line">        put5.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;15888888888&quot;));</span><br><span class="line">        put5.addColumn(&quot;f2&quot;.getBytes(),&quot;say&quot;.getBytes(),Bytes.toBytes(&quot;跟诸葛亮死掐&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Put put6 = new Put(&quot;0006&quot;.getBytes());</span><br><span class="line">        put6.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes(),Bytes.toBytes(5));</span><br><span class="line">        put6.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),Bytes.toBytes(&quot;xiaobubu—吕布&quot;));</span><br><span class="line">        put6.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),Bytes.toBytes(28));</span><br><span class="line">        put6.addColumn(&quot;f2&quot;.getBytes(),&quot;sex&quot;.getBytes(),Bytes.toBytes(&quot;1&quot;));</span><br><span class="line">        put6.addColumn(&quot;f2&quot;.getBytes(),&quot;address&quot;.getBytes(),Bytes.toBytes(&quot;内蒙人&quot;));</span><br><span class="line">        put6.addColumn(&quot;f2&quot;.getBytes(),&quot;phone&quot;.getBytes(),Bytes.toBytes(&quot;15788888888&quot;));</span><br><span class="line">        put6.addColumn(&quot;f2&quot;.getBytes(),&quot;say&quot;.getBytes(),Bytes.toBytes(&quot;貂蝉去哪了&quot;));</span><br><span class="line"></span><br><span class="line">        List&lt;Put&gt; listPut = new ArrayList&lt;Put&gt;();</span><br><span class="line">        listPut.add(put);</span><br><span class="line">        listPut.add(put2);</span><br><span class="line">        listPut.add(put3);</span><br><span class="line">        listPut.add(put4);</span><br><span class="line">        listPut.add(put5);</span><br><span class="line">        listPut.add(put6);</span><br><span class="line"></span><br><span class="line">        myuser.put(listPut);</span><br><span class="line">        myuser.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询</strong></p>
<p>初始化操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">以下所有共用这个:</span><br><span class="line"> private  Connection connection;</span><br><span class="line"> private Configuration configuration;</span><br><span class="line"> private Table table;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化的操作</span><br><span class="line">     */</span><br><span class="line">    @BeforeTest</span><br><span class="line">    public void initTable() throws IOException &#123;</span><br><span class="line">        //获取连接</span><br><span class="line">        configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line"></span><br><span class="line">        connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">        table= connection.getTable(TableName.valueOf(&quot;myuser&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">释放资源:</span><br><span class="line"></span><br><span class="line"> @AfterTest</span><br><span class="line">    public void closeTable() throws IOException &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">        table.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>按照rowkey进行查询获取所有列的所有值</strong></p>
<p>步骤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">前三同 与插入同</span><br><span class="line">四 new 一个Get 对象  get设置查询参数</span><br><span class="line">六 表对象 调get方法 得到结果对象</span><br><span class="line">七 根据结果对象调方法  得到集合 元素为Cell cell包含列簇 列名 列值等</span><br><span class="line">八  遍历 集合  根据需要得到数据</span><br><span class="line">/**</span><br><span class="line">   * 查询rowkey为0003的人，所有的列</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public  void  getData() throws IOException &#123;</span><br><span class="line">      Get get = new Get(&quot;0003&quot;.getBytes());</span><br><span class="line">     // get.addFamily(&quot;f1&quot;.getBytes());</span><br><span class="line">      //get.addColumn(&quot;f1&quot;.getBytes(),&quot;id&quot;.getBytes());//查询指定列簇下,的指定列的值就加这一条******</span><br><span class="line">      //Result是一个对象，封装了我们所有的结果数据</span><br><span class="line">      Result result = table.get(get);</span><br><span class="line">      //获取0003这条数据所有的cell值</span><br><span class="line">      List&lt;Cell&gt; cells = result.listCells();</span><br><span class="line">      for (Cell cell : cells) &#123;</span><br><span class="line">          //获取列族的名称</span><br><span class="line">          String familyName = Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());</span><br><span class="line">          //获取列的名称</span><br><span class="line">          String columnName = Bytes.toString(cell.getQualifierArray(),cell.getQualifierOffset(),cell.getQualifierLength());</span><br><span class="line">          if(familyName.equals(&quot;f1&quot;) &amp;&amp; columnName.equals(&quot;id&quot;) || columnName.equals(&quot;age&quot;))&#123;</span><br><span class="line">              //获取int类型列值</span><br><span class="line">              int value = Bytes.toInt(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength());</span><br><span class="line">              System.out.println(&quot;列族名为&quot;+familyName+&quot;列名为&quot; +  columnName + &quot;列的值为&quot; +  value);</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              String value = Bytes.toString(cell.getValueArray(),cell.getValueOffset(),cell.getValueLength());</span><br><span class="line">              System.out.println(&quot;列族名为&quot;+familyName+&quot;列名为&quot; +  columnName + &quot;列的值为&quot; +  value);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过startRowKey和endRowKey进行范围扫描"><a href="#通过startRowKey和endRowKey进行范围扫描" class="headerlink" title="通过startRowKey和endRowKey进行范围扫描"></a>通过startRowKey和endRowKey进行范围扫描</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 按照rowkey进行范围值的扫描</span><br><span class="line">  * 扫描rowkey范围是0004到0006的所有的值</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void scanRange() throws IOException &#123;</span><br><span class="line">     Scan scan = new Scan();</span><br><span class="line">     //设置我们起始和结束rowkey,范围值扫描是包括前面的，不包括后面的</span><br><span class="line">     scan.setStartRow(&quot;0004&quot;.getBytes());</span><br><span class="line">     scan.setStopRow(&quot;0006&quot;.getBytes());</span><br><span class="line">     //返回多条数据结果值都封装在resultScanner里面了</span><br><span class="line">     ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">     for (Result result : scanner) &#123;</span><br><span class="line">         List&lt;Cell&gt; cells = result.listCells();</span><br><span class="line">         for (Cell cell : cells) &#123;</span><br><span class="line">             String rowkey = Bytes.toString(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());</span><br><span class="line">             //获取列族名</span><br><span class="line">             String familyName  = Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());</span><br><span class="line">             //获取列名</span><br><span class="line">             String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());</span><br><span class="line">             if(familyName.equals(&quot;f1&quot;) &amp;&amp; columnName.equals(&quot;id&quot;) || columnName.equals(&quot;age&quot;))&#123;</span><br><span class="line">                 int value = Bytes.toInt(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                 System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 String value = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                 System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>全表扫描</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//全表扫描</span><br><span class="line">@Test</span><br><span class="line">public void scanAll() throws Exception&#123;</span><br><span class="line">	Scan scan=new Scan();</span><br><span class="line">    ResultScanner scanner=table.getScanner(scan);</span><br><span class="line">    for (Result result: scanner)&#123;</span><br><span class="line">        List&lt;Cell&gt; cells=result.listCells();</span><br><span class="line">        for(Cell cell:cells)&#123;</span><br><span class="line">              String rowkey = Bytes.toString(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());</span><br><span class="line">                //获取列族名</span><br><span class="line">                String familyName  = Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());</span><br><span class="line">                //获取列名</span><br><span class="line">                String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());</span><br><span class="line">                if(familyName.equals(&quot;f1&quot;) &amp;&amp; columnName.equals(&quot;id&quot;) || columnName.equals(&quot;age&quot;))&#123;</span><br><span class="line">                    int value = Bytes.toInt(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                    System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    String value = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                    System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十-过滤查询"><a href="#十-过滤查询" class="headerlink" title="十 过滤查询"></a>十 过滤查询</h2><p>过滤器的类型很多，但是可以分为两大类——比较过滤器，专用过滤器</p>
<p>过滤器的作用是在服务端判断数据是否满足条件，然后只将满足条件的数据返回给客户端；</p>
<p>hbase过滤器的比较运算符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LESS  &lt;</span><br><span class="line">LESS_OR_EQUAL &lt;=</span><br><span class="line">EQUAL =</span><br><span class="line">NOT_EQUAL &lt;&gt;</span><br><span class="line">GREATER_OR_EQUAL &gt;=</span><br><span class="line">GREATER &gt;</span><br><span class="line">NO_OP 排除所有</span><br></pre></td></tr></table></figure>

<p>Hbase过滤器的比较器（指定比较机制）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BinaryComparator  按字节索引顺序比较指定字节数组，采用Bytes.compareTo(byte[])</span><br><span class="line">BinaryPrefixComparator 跟前面相同，只是比较左端的数据是否相同</span><br><span class="line">NullComparator 判断给定的是否为空</span><br><span class="line">BitComparator 按位比较</span><br><span class="line">RegexStringComparator 提供一个正则的比较器，仅支持 EQUAL 和非EQUAL</span><br><span class="line">SubstringComparator 判断提供的子串是否出现在value中。</span><br></pre></td></tr></table></figure>

<h3 id="1-比较过滤器"><a href="#1-比较过滤器" class="headerlink" title="1 比较过滤器"></a>1 比较过滤器</h3><p>四种:</p>
<p>rowkey过滤器: RowFilter</p>
<p>列簇过滤器: FamilyFilter</p>
<p>列过滤器: QualifierFilter</p>
<p>列值过滤器: ValueFilter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void filterStudy() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    Scan scan = new Scan();</span><br><span class="line"></span><br><span class="line">    //查询rowkey比0003小的所有的数据       rowkey过滤器: </span><br><span class="line">  //  RowFilter rowFilter = new RowFilter(CompareOperator.LESS, new BinaryComparator(Bytes.toBytes(&quot;0003&quot;)));</span><br><span class="line">  //  scan.setFilter(rowFilter);</span><br><span class="line"></span><br><span class="line">    //查询比f2列族小的所有的列族里面的数据    FamilyFilter</span><br><span class="line"></span><br><span class="line">   // FamilyFilter f2 = new FamilyFilter(CompareOperator.LESS, new SubstringComparator(&quot;f2&quot;));</span><br><span class="line">   // scan.setFilter(f2);</span><br><span class="line"></span><br><span class="line">    //只查询name列的值                           列过滤器:</span><br><span class="line">  //  QualifierFilter name = new QualifierFilter(CompareOperator.EQUAL, new SubstringComparator(&quot;name&quot;));</span><br><span class="line">  //  scan.setFilter(name);</span><br><span class="line"></span><br><span class="line">    //查询value值当中包含8的所有的数据                 列值过滤器:</span><br><span class="line">    // ValueFilter valueFilter = new ValueFilter(CompareOperator.EQUAL, new SubstringComparator(&quot;8&quot;));</span><br><span class="line">  //  scan.setFilter(valueFilter);</span><br><span class="line"></span><br><span class="line">    //查询name值为刘备的数据</span><br><span class="line">    //SingleColumnValueFilter singleColumnValueFilter = new SingleColumnValueFilter(&quot;f1&quot;.getBytes(), &quot;name&quot;.getBytes(), CompareOperator.EQUAL, &quot;刘备&quot;.getBytes());</span><br><span class="line">    //scan.setFilter(singleColumnValueFilter);</span><br><span class="line"></span><br><span class="line">    //查询rowkey以00开头所有的数据</span><br><span class="line">    PrefixFilter prefixFilter = new PrefixFilter(&quot;00&quot;.getBytes());</span><br><span class="line">    scan.setFilter(prefixFilter);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //返回多条数据结果值都封装在resultScanner里面了</span><br><span class="line">    ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">    for (Result result : scanner) &#123;</span><br><span class="line">        List&lt;Cell&gt; cells = result.listCells();</span><br><span class="line">        for (Cell cell : cells) &#123;</span><br><span class="line">            String rowkey = Bytes.toString(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());</span><br><span class="line">            //获取列族名</span><br><span class="line">            String familyName  = Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());</span><br><span class="line">            String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());</span><br><span class="line">            if(familyName.equals(&quot;f1&quot;) &amp;&amp; columnName.equals(&quot;id&quot;) || columnName.equals(&quot;age&quot;))&#123;</span><br><span class="line">                int value = Bytes.toInt(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                String value = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-专用过滤器"><a href="#2-专用过滤器" class="headerlink" title="2 专用过滤器"></a>2 专用过滤器</h3><h5 id="1、单列值过滤器-SingleColumnValueFilter"><a href="#1、单列值过滤器-SingleColumnValueFilter" class="headerlink" title="1、单列值过滤器 SingleColumnValueFilter"></a>1、单列值过滤器 SingleColumnValueFilter</h5><h5 id="2、列值排除过滤器SingleColumnValueExcludeFilter"><a href="#2、列值排除过滤器SingleColumnValueExcludeFilter" class="headerlink" title="2、列值排除过滤器SingleColumnValueExcludeFilter"></a>2、列值排除过滤器SingleColumnValueExcludeFilter</h5><p>与SingleColumnValueFilter相反，会排除掉指定的列，其他的列全部返回</p>
<h5 id="3、rowkey前缀过滤器PrefixFilter"><a href="#3、rowkey前缀过滤器PrefixFilter" class="headerlink" title="3、rowkey前缀过滤器PrefixFilter"></a>3、rowkey前缀过滤器PrefixFilter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void filterStudy() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">       Scan scan = new Scan();</span><br><span class="line"></span><br><span class="line">       //查询name值为刘备的数据        单列值过滤器 </span><br><span class="line">       //SingleColumnValueFilter singleColumnValueFilter = new SingleColumnValueFilter(&quot;f1&quot;.getBytes(), &quot;name&quot;.getBytes(), CompareOperator.EQUAL, &quot;刘备&quot;.getBytes());</span><br><span class="line">       //scan.setFilter(singleColumnValueFilter);</span><br><span class="line">	</span><br><span class="line">       //查询name值不为刘备的数据   列值排除过滤器</span><br><span class="line">   //SingleColumnValueExcludeFilter singleColumnValueExcludeFilter   = new SingleColumnValueExcludeFilter(&quot;f1&quot;.getBytes(), &quot;name&quot;.getBytes(), CompareOperator.EQUAL, &quot;刘备&quot;.getBytes());</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       //查询rowkey以00开头所有的数据</span><br><span class="line">       PrefixFilter prefixFilter = new PrefixFilter(&quot;00&quot;.getBytes());</span><br><span class="line">       scan.setFilter(prefixFilter);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //返回多条数据结果值都封装在resultScanner里面了</span><br><span class="line">       ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">       for (Result result : scanner) &#123;</span><br><span class="line">           List&lt;Cell&gt; cells = result.listCells();</span><br><span class="line">           for (Cell cell : cells) &#123;</span><br><span class="line">               String rowkey = Bytes.toString(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());</span><br><span class="line">               //获取列族名</span><br><span class="line">               String familyName  = Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());</span><br><span class="line">               String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());</span><br><span class="line">               if(familyName.equals(&quot;f1&quot;) &amp;&amp; columnName.equals(&quot;id&quot;) || columnName.equals(&quot;age&quot;))&#123;</span><br><span class="line">                   int value = Bytes.toInt(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                   System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   String value = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                   System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、分页过滤器PageFilter"><a href="#4、分页过滤器PageFilter" class="headerlink" title="4、分页过滤器PageFilter"></a>4、分页过滤器PageFilter</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 实现hbase的分页的功能</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void hbasePage() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      int pageNum= 3;</span><br><span class="line">      int pageSize = 2 ;</span><br><span class="line">      if(pageNum == 1)&#123;</span><br><span class="line">          Scan scan = new Scan();</span><br><span class="line">          //如果是查询第一页数据，就按照空来进行扫描</span><br><span class="line">          scan.withStartRow(&quot;&quot;.getBytes());</span><br><span class="line">          PageFilter pageFilter = new PageFilter(pageSize);</span><br><span class="line">          scan.setFilter(pageFilter);</span><br><span class="line"></span><br><span class="line">          ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">          for (Result result : scanner) &#123;</span><br><span class="line">              byte[] row = result.getRow();</span><br><span class="line">              System.out.println(Bytes.toString(row));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;else&#123;</span><br><span class="line"></span><br><span class="line">          String  startRow = &quot;&quot;;</span><br><span class="line">          //计算我们前两页的数据的最后一条，再加上一条，就是第三页的起始rowkey</span><br><span class="line">          Scan scan = new Scan();</span><br><span class="line">          scan.withStartRow(&quot;&quot;.getBytes());</span><br><span class="line">          PageFilter pageFilter = new PageFilter((pageNum - 1) * pageSize + 1);</span><br><span class="line">          scan.setFilter(pageFilter);</span><br><span class="line">          ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">          for (Result result : scanner) &#123;</span><br><span class="line">              byte[] row = result.getRow();</span><br><span class="line">              startRow = Bytes.toString(row);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          //获取第三页的数据</span><br><span class="line">          scan.withStartRow(startRow.getBytes());</span><br><span class="line">          PageFilter pageFilter1 = new PageFilter(pageSize);</span><br><span class="line">          scan.setFilter(pageFilter1);</span><br><span class="line">          ResultScanner scanner1 = table.getScanner(scan);</span><br><span class="line">          for (Result result : scanner1) &#123;</span><br><span class="line">              byte[] row = result.getRow();</span><br><span class="line">              System.out.println(Bytes.toString(row));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多过滤器综合查询FilterList"><a href="#3-多过滤器综合查询FilterList" class="headerlink" title="3 多过滤器综合查询FilterList"></a>3 多过滤器综合查询FilterList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 多过滤器综合查询</span><br><span class="line">   * 需求：使用SingleColumnValueFilter查询f1列族，name为刘备的数据，并且同时满足rowkey的前缀以00开头的数据（PrefixFilter）</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void filterList() throws IOException &#123;</span><br><span class="line"></span><br><span class="line">      SingleColumnValueFilter singleColumnValueFilter = new SingleColumnValueFilter(&quot;f1&quot;.getBytes(), &quot;name&quot;.getBytes(), CompareOperator.EQUAL, &quot;刘备&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">      PrefixFilter prefixFilter = new PrefixFilter(&quot;00&quot;.getBytes());</span><br><span class="line">      //使用filterList来实现多过滤器综合查询</span><br><span class="line">      FilterList filterList = new FilterList(singleColumnValueFilter, prefixFilter);</span><br><span class="line"></span><br><span class="line">      Scan scan = new Scan();</span><br><span class="line">      scan.setFilter(filterList);//设定为FilterList</span><br><span class="line">      </span><br><span class="line">      ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">      for (Result result : scanner) &#123;</span><br><span class="line">          List&lt;Cell&gt; cells = result.listCells();</span><br><span class="line">          for (Cell cell : cells) &#123;</span><br><span class="line">              String rowkey = Bytes.toString(cell.getRowArray(), cell.getRowOffset(), cell.getRowLength());</span><br><span class="line">              //获取列族名</span><br><span class="line">              String familyName  = Bytes.toString(cell.getFamilyArray(), cell.getFamilyOffset(), cell.getFamilyLength());</span><br><span class="line">              String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(), cell.getQualifierLength());</span><br><span class="line">              if(familyName.equals(&quot;f1&quot;) &amp;&amp; columnName.equals(&quot;id&quot;) || columnName.equals(&quot;age&quot;))&#123;</span><br><span class="line">                  int value = Bytes.toInt(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                  System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                  String value = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());</span><br><span class="line">                  System.out.println(&quot;数据的rowkey为&quot; +  rowkey + &quot;    数据的列族名为&quot; +  familyName + &quot;    列名为&quot; + columnName + &quot;   列值为&quot; +  value);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据rowkey删除数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 根据rowkey删除某一条数据</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public   void deleteData() throws IOException &#123;</span><br><span class="line">      Delete delete = new Delete(&quot;0007&quot;.getBytes());</span><br><span class="line">      table.delete(delete);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除表操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 删除表操作</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void deleteTable() throws IOException &#123;</span><br><span class="line">      //获取管理员对象</span><br><span class="line">      Admin admin = connection.getAdmin();</span><br><span class="line">      //禁用表</span><br><span class="line">      admin.disableTable(TableName.valueOf(&quot;myuser&quot;));</span><br><span class="line">      //删除表</span><br><span class="line">      admin.deleteTable(TableName.valueOf(&quot;myuser&quot;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新表操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 更新操作与插入操作是一模一样的，如果rowkey已经存在那么就更新</span><br><span class="line">    * 如果rowkey不存在，那么就添加</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void updateOperate()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表的创建与预分区</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 通过javaAPI进行HBase的表的创建以及预分区操作</span><br><span class="line">   */</span><br><span class="line">  @Test</span><br><span class="line">  public void hbaseSplit() throws IOException &#123;</span><br><span class="line">      //获取连接</span><br><span class="line">      Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">      configuration.set(&quot;hbase.zookeeper.quorum&quot;, &quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line">      Connection connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">      Admin admin = connection.getAdmin();</span><br><span class="line">      //自定义算法，产生一系列Hash散列值存储在二维数组中</span><br><span class="line">      byte[][] splitKeys = &#123;&#123;1,2,3,4,5&#125;,&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //通过HTableDescriptor来实现我们表的参数设置，包括表名，列族等等</span><br><span class="line">      HTableDescriptor hTableDescriptor = new HTableDescriptor(TableName.valueOf(&quot;staff3&quot;));</span><br><span class="line">      //添加列族</span><br><span class="line">      hTableDescriptor.addFamily(new HColumnDescriptor(&quot;f1&quot;));</span><br><span class="line">      //添加列族</span><br><span class="line">      hTableDescriptor.addFamily(new HColumnDescriptor(&quot;f2&quot;));</span><br><span class="line">      </span><br><span class="line">      admin.createTable(hTableDescriptor,splitKeys);</span><br><span class="line">      admin.close();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一-Hbase的底层原理"><a href="#十一-Hbase的底层原理" class="headerlink" title="十一 Hbase的底层原理"></a>十一 Hbase的底层原理</h2><p>系统架构:</p>
<p><a href="https://manzhong.github.io/images/Hbase/hbase%E6%9E%B6%E6%9E%84.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Hbase/hbase%E6%9E%B6%E6%9E%84.png" alt="img"></a></p>
<p><strong>Client</strong></p>
<p>1 包含访问hbase的接口，client维护着一些cache来加快对hbase的访问，比如regione的位置信息。</p>
<p><strong>Zookeeper</strong></p>
<p>1 保证任何时候，集群中只有一个master</p>
<p>2 存贮所有Region的寻址入口</p>
<p>3 实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master</p>
<p>4 存储Hbase的schema,包括有哪些table，每个table有哪些column family</p>
<p><strong>Master职责</strong></p>
<p>1 为Region server分配region</p>
<p>2 负责region server的负载均衡</p>
<p>3 发现失效的region server并重新分配其上的region</p>
<p>4 HDFS上的垃圾文件回收</p>
<p>5 处理schema更新请求</p>
<p><strong>Region Server职责</strong></p>
<p>1 Region server维护Master分配给它的region，处理对这些region的IO请求</p>
<p>2 Region server负责切分在运行过程中变得过大的region</p>
<p>可以看到，client访问hbase上数据的过程并不需要master参与（寻址访问zookeeper和region server，数据读写访问regione server），master仅仅维护者table和region的元数据信息，负载很低。</p>
<h2 id="HBase的表数据模型"><a href="#HBase的表数据模型" class="headerlink" title="HBase的表数据模型"></a>HBase的表数据模型</h2><h3 id="Row-Key"><a href="#Row-Key" class="headerlink" title="Row Key"></a>Row Key</h3><p>与nosql数据库们一样,row key是用来检索记录的主键。访问hbase table中的行，只有三种方式：</p>
<p>1 通过单个row key访问</p>
<p>2 通过row key的range</p>
<p>3 全表扫描</p>
<p>Row key行键 (Row key)可以是任意字符串(最大长度是 64KB，实际应用中长度一般为 10-100bytes)，在hbase内部，row key保存为字节数组。</p>
<p><strong>Hbase</strong>:<strong>会对表中的数据按照rowkey排序(字典顺序)</strong></p>
<p>存储时，数据按照Row key的字典序(byte order)排序存储。设计key时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性)</p>
<p>注意：</p>
<p>字典序对int排序的结果是</p>
<p>1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99。要保持整形的自然序，行键必须用0作左填充。</p>
<p>行的一次读写是原子操作 (不论一次读写多少列)。这个设计决策能够使用户很容易的理解程序在对同一个行进行并发更新操作时的行为。</p>
<h3 id="列族Column-Family"><a href="#列族Column-Family" class="headerlink" title="列族Column Family"></a>列族Column Family</h3><p>hbase表中的每个列，都归属与某个列族。列族是表的schema的一部分(而列不是)，必须在使用表之前定义。</p>
<p>列名都以列族作为前缀。例如courses:history ， courses:math 都属于 courses 这个列族。</p>
<p>访问控制、磁盘和内存的使用统计都是在列族层面进行的。</p>
<p>列族越多，在取一行数据时所要参与IO、搜寻的文件就越多，所以，如果没有必要，不要设置太多的列族</p>
<h3 id="列-Column"><a href="#列-Column" class="headerlink" title="列 Column"></a>列 Column</h3><p>列族下面的具体列，属于某一个ColumnFamily,类似于我们mysql当中创建的具体的列</p>
<p>列是插入数据的时候动态指定的</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>HBase中通过row和columns确定的为一个存贮单元称为cell。每个 cell都保存着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64位整型。时间戳可以由hbase(在数据写入时自动 )赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显式赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个 cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</p>
<p>为了避免数据存在过多版本造成的的管理 (包括存贮和索引)负担，hbase提供了两种数据版本回收方式：</p>
<p>² 保存数据的最后n个版本</p>
<p>² 保存最近一段时间内的版本（设置数据的生命周期TTL）。</p>
<p>用户可以针对每个列族进行设置。</p>
<h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h3><p>由{row key, column( = + ), version} 唯一确定的单元。</p>
<p>cell中的数据是没有类型的，全部是字节码形式存贮。</p>
<h3 id="VersionNum"><a href="#VersionNum" class="headerlink" title="VersionNum"></a>VersionNum</h3><p>数据的版本号，每条数据可以有多个版本号，默认值为系统时间戳，类型为Long</p>
<h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><h3 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h3><p>1 Table中的所有行都按照row key的字典序排列。</p>
<p>2 Table 在行的方向上分割为多个Hregion</p>
<p><strong>3 region按大小分割的(默认10G)，每个表一开始只有一个region，随着数据不断插入表，region不断增大，当增大到一个阀值的时候，Hregion就会等分会两个新的Hregion。分出新的 会分一个新的 HRegionServer去管理. 当table中的行不断增多，就会有越来越多的Hregion。</strong></p>
<p>4 Hregion是Hbase中分布式存储和负载均衡的最小单元。最小单元就表示不同的Hregion可以分布在不同的HRegion server上。但一个Hregion是不会拆分到多个server上的。</p>
<p>5 HRegion虽然是负载均衡的最小单元，但并不是物理存储的最小单元。</p>
<p>事实上，HRegion由一个或者多个Store组成，每个store保存一个column family。</p>
<p>每个Strore又由一个memStore和0至多个StoreFile组成。</p>
<h3 id="STORE-FILE-amp-HFILE结构"><a href="#STORE-FILE-amp-HFILE结构" class="headerlink" title="STORE FILE &amp; HFILE结构"></a>STORE FILE &amp; HFILE结构</h3><p>StoreFile以HFile格式保存在HDFS上。</p>
<p>首先HFile文件是不定长的，长度固定的只有其中的两块：Trailer和FileInfo。正如图中所示的，Trailer中有指针指向其他数 据块的起始点。</p>
<p>File Info中记录了文件的一些Meta信息，例如：AVG_KEY_LEN, AVG_VALUE_LEN, LAST_KEY, COMPARATOR, MAX_SEQ_ID_KEY等。</p>
<p>Data Index和Meta Index块记录了每个Data块和Meta块的起始点。</p>
<p>Data Block是HBase I/O的基本单元，为了提高效率，HRegionServer中有基于LRU的Block Cache机制。每个Data块的大小可以在创建一个Table的时候通过参数指定，大号的Block有利于顺序Scan，小号Block利于随机查询。 每个Data块除了开头的Magic以外就是一个个KeyValue对拼接而成, Magic内容就是一些随机数字，目的是防止数据损坏。</p>
<p>HFile里面的每个对就是一个简单的数组。但是这个数组里面包含了很多项，并且有固定的结构。</p>
<p>开始是两个固定长度的数值，分别表示Key的长度和Value的长度。紧接着是Key，开始是固定长度的数值，表示RowKey的长度，紧接着是 RowKey，然后是固定长度的数值，表示Family的长度，然后是Family，接着是Qualifier，然后是两个固定长度的数值，表示Time Stamp和Key Type（Put/Delete）。Value部分没有这么复杂的结构，就是纯粹的二进制数据了。</p>
<p>HFile分为六个部分：</p>
<p>Data Block 段–保存表中的数据，这部分可以被压缩</p>
<p>Meta Block 段 (可选的)–保存用户自定义的kv对，可以被压缩。</p>
<p>File Info 段–Hfile的元信息，不被压缩，用户也可以在这一部分添加自己的元信息。</p>
<p>Data Block Index 段–Data Block的索引。每条索引的key是被索引的block的第一条记录的key。</p>
<p>Meta Block Index段 (可选的)–Meta Block的索引。</p>
<p>Trailer–这一段是定长的。保存了每一段的偏移量，读取一个HFile时，会首先 读取Trailer，Trailer保存了每个段的起始位置(段的Magic Number用来做安全check)，然后，DataBlock Index会被读取到内存中，这样，当检索某个key时，不需要扫描整个HFile，而只需从内存中找到key所在的block，通过一次磁盘io将整个 block读取到内存中，再找到需要的key。DataBlock Index采用LRU机制淘汰。</p>
<p>HFile的Data Block，Meta Block通常采用压缩方式存储，压缩之后可以大大减少网络IO和磁盘IO，随之而来的开销当然是需要花费cpu进行压缩和解压缩。</p>
<p>目标Hfile的压缩支持两种方式：Gzip，Lzo。</p>
<h3 id="Memstore与storefile"><a href="#Memstore与storefile" class="headerlink" title="Memstore与storefile"></a>Memstore与storefile</h3><p><strong>一个region由多个store组成，每个store包含一个列族的所有数据</strong></p>
<p>Store包括位于内存的memstore和位于硬盘的storefile</p>
<p>写操作先写入memstore,当memstore中的数据量达到某个阈值，Hregionserver启动flashcache进程写入storefile,每次写入形成单独一个storefile</p>
<p>当storefile大小超过一定阈值后，会把当前的region分割成两个，并由Hmaster分配给相应的HregionServer服务器，实现负载均衡</p>
<p>客户端检索数据时，先在memstore找，找不到再找storefile</p>
<h3 id="HLog-WAL-log"><a href="#HLog-WAL-log" class="headerlink" title="HLog(WAL log)"></a>HLog(WAL log)</h3><p>WAL 意为Write ahead log(<a href="http://en.wikipedia.org/wiki/Write-ahead_logging" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Write-ahead_logging)，类似mysql中的binlog,用来</a>%EF%BC%8C%E7%B1%BB%E4%BC%BCmysql%E4%B8%AD%E7%9A%84binlog,%E7%94%A8%E6%9D%A5) 做灾难恢复时用，<strong>Hlog记录数据的所有变更,一旦数据修改，就可以从log中进行恢复.</strong></p>
<p>每个Region Server维护一个Hlog,而不是每个Region一个。这样不同region(来自不同table)的日志会混在一起，这样做的目的是不断追加单个文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高对table的写性能。带来的麻烦是，如果一台region server下线，为了恢复其上的region，需要将region server上的log进行拆分，然后分发到其它region server上进行恢复。</p>
<p>HLog文件就是一个普通的Hadoop Sequence File：</p>
<p>² HLog Sequence File 的Key是HLogKey对象，HLogKey中记录了写入数据的归属信息，除了table和region名字外，同时还包括 sequence number和timestamp，timestamp是”写入时间”，sequence number的起始值为0，或者是最近一次存入文件系统中sequence number。</p>
<p>² HLog Sequece File的Value是HBase的KeyValue对象，即对应HFile中的KeyValue，可参见上文描述。</p>
<h3 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h3><h3 id="读请求过程："><a href="#读请求过程：" class="headerlink" title="读请求过程："></a>读请求过程：</h3><p>HRegionServer保存着meta表以及表数据，要访问表数据，首先Client先去访问zookeeper，从zookeeper里面获取meta表所在的位置信息，即找到这个meta表在哪个HRegionServer上保存着。</p>
<p>接着Client通过刚才获取到的HRegionServer的IP来访问Meta表所在的HRegionServer，从而读取到Meta，进而获取到Meta表中存放的元数据。</p>
<p>Client通过元数据中存储的信息，访问对应的HRegionServer，然后扫描所在HRegionServer的Memstore和Storefile来查询数据</p>
<p>最后HRegionServer把查询到的数据响应给Client。</p>
<p>查看meta表信息</p>
<p>hbase(main):011:0&gt; scan ‘hbase:meta’</p>
<h3 id="2、写请求过程："><a href="#2、写请求过程：" class="headerlink" title="2、写请求过程："></a>2、写请求过程：</h3><p>Client也是先访问zookeeper，找到Meta表，并获取Meta表元数据。</p>
<p>确定当前将要写入的数据所对应的HRegion和HRegionServer服务器。</p>
<p>Client向该HRegionServer服务器发起写入数据请求，然后HRegionServer收到请求并响应。</p>
<p>Client先把数据写入到HLog，以防止数据丢失。</p>
<p>然后将数据写入到Memstore。</p>
<p>如果HLog和Memstore均写入成功，则这条数据写入成功</p>
<p>如果Memstore达到阈值，会把Memstore中的数据flush到Storefile中。</p>
<p>当Storefile越来越多，会触发Compact合并操作，把过多的Storefile合并成一个大的HFile。</p>
<p>当HFile越来越大，Region也会越来越大，达到阈值后，会触发Split操作，将Region一分为二。</p>
<p>细节描述：</p>
<p>hbase使用MemStore和StoreFile存储对表的更新。</p>
<p>数据在更新时首先写入Log(WAL log)和内存(MemStore)中，MemStore中的数据是排序的，当MemStore累计到一定阈值时，就会创建一个新的MemStore，并 且将老的MemStore添加到flush队列，由单独的线程flush到磁盘上，成为一个StoreFile。于此同时，系统会在zookeeper中记录一个redo point，表示这个时刻之前的变更已经持久化了。</p>
<p>当系统出现意外时，可能导致内存(MemStore)中的数据丢失，此时使用Log(WAL log)来恢复checkpoint之后的数据。</p>
<p>StoreFile是只读的，一旦创建后就不可以再修改。因此Hbase的更新其实是不断追加的操作。当一个Store中的StoreFile达到一定的阈值后，就会进行一次合并(minor_compact, major_compact),将对同一个key的修改合并到一起，形成一个大的StoreFile，当StoreFile的大小达到一定阈值后，又会对 StoreFile进行split，等分为两个StoreFile。</p>
<p>由于对表的更新是不断追加的，compact时，需要访问Store中全部的 StoreFile和MemStore，将他们按row key进行合并，由于StoreFile和MemStore都是经过排序的，并且StoreFile带有内存中索引，合并的过程还是比较快。</p>
<p><strong>Region管理</strong></p>
<p>(1) region分配</p>
<p>任何时刻，一个region只能分配给一个region server。master记录了当前有哪些可用的region server。以及当前哪些region分配给了哪些region server，哪些region还没有分配。当需要分配的新的region，并且有一个region server上有可用空间时，master就给这个region server发送一个装载请求，把region分配给这个region server。region server得到请求后，就开始对此region提供服务。</p>
<p>(2) region server上线</p>
<p>master使用zookeeper来跟踪region server状态。当某个region server启动时，会首先在zookeeper上的server目录下建立代表自己的znode。由于master订阅了server目录上的变更消息，当server目录下的文件出现新增或删除操作时，master可以得到来自zookeeper的实时通知。因此一旦region server上线，master能马上得到消息。</p>
<p>(3) region server下线</p>
<p>当region server下线时，它和zookeeper的会话断开，zookeeper而自动释放代表这台server的文件上的独占锁。master就可以确定：</p>
<p>1 region server和zookeeper之间的网络断开了。</p>
<p>2 region server挂了。</p>
<p>无论哪种情况，region server都无法继续为它的region提供服务了，此时master会删除server目录下代表这台region server的znode数据，并将这台region server的region分配给其它还活着的同志。</p>
<h2 id="Master工作机制"><a href="#Master工作机制" class="headerlink" title="Master工作机制"></a>Master工作机制</h2><p>Ø master上线</p>
<p>master启动进行以下步骤:</p>
<p>1 从zookeeper上获取唯一一个代表active master的锁，用来阻止其它master成为master。</p>
<p>2 扫描zookeeper上的server父节点，获得当前可用的region server列表。</p>
<p>3 和每个region server通信，获得当前已分配的region和region server的对应关系。</p>
<p>4 扫描.META.region的集合，计算得到当前还未分配的region，将他们放入待分配region列表。</p>
<p>Ø master下线</p>
<p>由于master只维护表和region的元数据，而不参与表数据IO的过程，master下线仅导致所有元数据的修改被冻结(无法创建删除表，无法修改表的schema，无法进行region的负载均衡，无法处理region 上下线，无法进行region的合并，唯一例外的是region的split可以正常进行，因为只有region server参与)，表的数据读写还可以正常进行。因此master下线短时间内对整个hbase集群没有影响。</p>
<p>从上线过程可以看到，master保存的信息全是可以冗余信息（都可以从系统其它地方收集到或者计算出来）</p>
<p>因此，一般hbase集群中总是有一个master在提供服务，还有一个以上的‘master’在等待时机抢占它的位置。</p>
<h2 id="十二-hbase三个重要机制"><a href="#十二-hbase三个重要机制" class="headerlink" title="十二 hbase三个重要机制"></a>十二 hbase三个重要机制</h2><h2 id="1、flush机制"><a href="#1、flush机制" class="headerlink" title="1、flush机制"></a>1、flush机制</h2><p>1.（hbase.regionserver.global.memstore.size）默认;堆大小的40%</p>
<p>regionServer的全局memstore的大小，超过该大小会触发flush到磁盘的操作,默认是堆大小的40%,而且regionserver级别的flush会阻塞客户端读写</p>
<p>2.（hbase.hregion.memstore.flush.size）默认：128M</p>
<p>单个region里memstore的缓存大小，超过那么整个HRegion就会flush,</p>
<p>3.（hbase.regionserver.optionalcacheflushinterval）默认：1h</p>
<p>内存中的文件在自动刷新之前能够存活的最长时间</p>
<p>4.（hbase.regionserver.global.memstore.size.lower.limit）默认：堆大小 * 0.4 * 0.95</p>
<p>有时候集群的“写负载”非常高，写入量一直超过flush的量，这时，我们就希望memstore不要超过一定的安全设置。在这种情况下，写操作就要被阻塞一直到memstore恢复到一个“可管理”的大小, 这个大小就是默认值是堆大小 * 0.4 * 0.95，也就是当regionserver级别的flush操作发送后,会阻塞客户端写,一直阻塞到整个regionserver级别的memstore的大小为 堆大小 * 0.4 *0.95为止</p>
<p>5.（hbase.hregion.preclose.flush.size）默认为：5M</p>
<p>当一个 region 中的 memstore 的大小大于这个值的时候，我们又触发 了 close.会先运行“pre-flush”操作，清理这个需要关闭的memstore，然后 将这个 region 下线。当一个 region 下线了，我们无法再进行任何写操作。 如果一个 memstore 很大的时候，flush 操作会消耗很多时间。”pre-flush” 操作意味着在 region 下线之前，会先把 memstore 清空。这样在最终执行 close 操作的时候，flush 操作会很快。</p>
<p>6.（hbase.hstore.compactionThreshold）默认：超过3个</p>
<p>一个store里面允许存的hfile的个数，超过这个个数会被写到新的一个hfile里面 也即是每个region的每个列族对应的memstore在fulsh为hfile的时候，默认情况下当超过3个hfile的时候就会 对这些文件进行合并重写为一个新文件，设置个数越大可以减少触发合并的时间，但是每次合并的时间就会越长</p>
<h2 id="2-compact机制"><a href="#2-compact机制" class="headerlink" title="2 compact机制"></a>2 compact机制</h2><p>把小的storeFile文件合并成大的Storefile文件。</p>
<p>清理过期的数据，包括删除的数据</p>
<p>将数据的版本号保存为3个</p>
<h2 id="3、split机制"><a href="#3、split机制" class="headerlink" title="3、split机制"></a>3、split机制</h2><p>当Region达到阈值，会把过大的Region一分为二。</p>
<p>默认一个HFile达到10Gb的时候就会进行切分</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Hbase/" data-id="cjz25rjc2000td8u5n92c8mmx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hbase增强" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Hbase增强/" class="article-date">
  <time datetime="2019-08-08T03:56:49.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Hbase增强/">Hbase增强</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hbase增强"><a href="#Hbase增强" class="headerlink" title="Hbase增强"></a>Hbase增强</h1><h2 id="一-Hbase与MapReduce的集成"><a href="#一-Hbase与MapReduce的集成" class="headerlink" title="一 Hbase与MapReduce的集成"></a>一 Hbase与MapReduce的集成</h2><p>HBase当中的数据最终都是存储在HDFS上面的，HBase天生的支持MR的操作，我们可以通过MR直接处理HBase当中的数据，并且MR可以将处理后的结果直接存储到HBase当中去</p>
<h3 id="需求一-读取myuser这张表当中的数据写入到HBase的另外一张表当中去"><a href="#需求一-读取myuser这张表当中的数据写入到HBase的另外一张表当中去" class="headerlink" title="需求一 读取myuser这张表当中的数据写入到HBase的另外一张表当中去"></a>需求一 读取myuser这张表当中的数据写入到HBase的另外一张表当中去</h3><h4 id="1-创建myuser2-表"><a href="#1-创建myuser2-表" class="headerlink" title="1 创建myuser2 表"></a>1 创建myuser2 表</h4><p>其中列簇名与myuser中列簇名一致</p>
<p>依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-client --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-server --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hbase-server&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.testng&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;testng&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;6.14.3&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-mapreduce --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hbase-mapreduce&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt; 2.7.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;!--    &lt;verbal&gt;true&lt;/verbal&gt;--&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--将我们其他用到的一些jar包全部都打包进来  --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;minimizeJar&gt;false&lt;/minimizeJar&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<h4 id="定义mapper类"><a href="#定义mapper类" class="headerlink" title="定义mapper类"></a>定义mapper类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 负责读取myuser表当中的数据</span><br><span class="line"> * 如果mapper类需要读取hbase表数据，那么我们mapper类需要继承TableMapper这样的一个类</span><br><span class="line"> * 将key2   value2定义成 text  和put类型</span><br><span class="line"> * text里面装rowkey</span><br><span class="line"> * put装我们需要插入的数据</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class HBaseSourceMapper extends TableMapper&lt;Text,Put&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param key  rowkey</span><br><span class="line">     * @param value  result对象，封装了我们一条条的数据</span><br><span class="line">     * @param context  上下文对象</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     *</span><br><span class="line">     * 需求：读取myuser表当中f1列族下面的name和age列</span><br><span class="line">     *</span><br><span class="line">     ImmutableBytesWritable 封装了rowkey</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(ImmutableBytesWritable key, Result value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">       //获取到rowkey的字节数组</span><br><span class="line">        byte[] bytes = key.get();</span><br><span class="line">        String rowkey = Bytes.toString(bytes);</span><br><span class="line"></span><br><span class="line">        Put put = new Put(bytes);</span><br><span class="line"></span><br><span class="line">        //获取到所有的cell</span><br><span class="line">        List&lt;Cell&gt; cells = value.listCells();</span><br><span class="line">        for (Cell cell : cells) &#123;</span><br><span class="line">            //获取cell对应的列族</span><br><span class="line">            byte[] familyBytes = CellUtil.cloneFamily(cell);</span><br><span class="line">            //获取对应的列</span><br><span class="line">            byte[] qualifierBytes = CellUtil.cloneQualifier(cell);</span><br><span class="line">            //这里判断我们只需要f1列族，下面的name和age列</span><br><span class="line">            if(Bytes.toString(familyBytes).equals(&quot;f1&quot;) &amp;&amp; Bytes.toString(qualifierBytes).equals(&quot;name&quot;) ||  Bytes.toString(qualifierBytes).equals(&quot;age&quot;))&#123;</span><br><span class="line">                put.add(cell);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //将数据写出去</span><br><span class="line">        if(!put.isEmpty())&#123;</span><br><span class="line">            context.write(new Text(rowkey),put);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义-reduce"><a href="#定义-reduce" class="headerlink" title="定义 reduce"></a>定义 reduce</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line">import org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 负责将数据写入到myuser2</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HBaseSinkReducer extends TableReducer&lt;Text,Put,ImmutableBytesWritable&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;Put&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        for (Put put : values) &#123;</span><br><span class="line">            context.write(new ImmutableBytesWritable(key.toString().getBytes()),put);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义主类"><a href="#定义主类" class="headerlink" title="定义主类"></a>定义主类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.conf.Configured;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.client.Scan;</span><br><span class="line">import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.util.Tool;</span><br><span class="line">import org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.nimbus.AbstractRegionPainter;</span><br><span class="line"></span><br><span class="line">public class HBaseMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;hbaseMR&quot;);</span><br><span class="line"></span><br><span class="line">        //打包运行，必须设置main方法所在的主类</span><br><span class="line">        job.setJarByClass(HBaseMain.class);</span><br><span class="line"></span><br><span class="line">        Scan scan = new Scan();</span><br><span class="line"></span><br><span class="line">        //定义我们的mapper类和reducer类</span><br><span class="line">        /**</span><br><span class="line">         * String table, Scan scan,</span><br><span class="line">         Class&lt;? extends TableMapper&gt; mapper,</span><br><span class="line">         Class&lt;?&gt; outputKeyClass,</span><br><span class="line">         Class&lt;?&gt; outputValueClass, Job job,</span><br><span class="line">         boolean addDependencyJars</span><br><span class="line">         */</span><br><span class="line">        TableMapReduceUtil.initTableMapperJob(&quot;myuser&quot;,scan,HBaseSourceMapper.class, Text.class, Put.class,job,false);</span><br><span class="line">        //使用工具类初始化reducer类</span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(&quot;myuser2&quot;,HBaseSinkReducer.class,job);</span><br><span class="line">        boolean b = job.waitForCompletion(true);</span><br><span class="line">        return b?0:1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //程序入口类</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //Configuration conf, Tool tool, String[] args</span><br><span class="line">        Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line">        int run = ToolRunner.run(configuration, new HBaseMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>1 本地运行</p>
<p>直接选中main方法所在的类，运行即可</p>
<p>2 打包集群运行</p>
<p>注意，我们需要使用打包插件，将HBase的依赖jar包都打入到工程jar包里面去</p>
<p>pom.xml当中添加打包插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;minimizeJar&gt;true&lt;/minimizeJar&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>代码中添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setJarByClass(HBaseMain.class);</span><br></pre></td></tr></table></figure>

<p>使用maven打包</p>
<p>将jar包上传服务器:运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jar hbaseStudy-1.0-SNAPSHOT.jar  cn.baidu.hbasemr.HBaseMR</span><br></pre></td></tr></table></figure>

<p>或者我们也可以自己设置我们的环境变量，然后运行original那个比较小的jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/export/servers/hadoop-2.7.5/</span><br><span class="line">export HBASE_HOME=/export/servers/hbase-2.0.0/</span><br><span class="line">export HADOOP_CLASSPATH=$&#123;HBASE_HOME&#125;/bin/hbase mapredcp</span><br><span class="line">yarn jar original-hbaseStudy-1.0-SNAPSHOT.jar  cn.baidu.hbasemr.HbaseMR</span><br></pre></td></tr></table></figure>

<h4 id="需求2-读取HDFS文件，写入到HBase表当中去"><a href="#需求2-读取HDFS文件，写入到HBase表当中去" class="headerlink" title="需求2 读取HDFS文件，写入到HBase表当中去"></a>需求2 读取HDFS文件，写入到HBase表当中去</h4><p>读取hdfs路径/hbase/input/user.txt，然后将数据写入到myuser2这张表当中去</p>
<p>准备数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /hbase/input</span><br><span class="line">cd /export/servers/</span><br><span class="line">vim user.txt</span><br><span class="line"> </span><br><span class="line"> 0007    zhangsan        18</span><br><span class="line">0008    lisi    25</span><br><span class="line">0009    wangwu  20</span><br></pre></td></tr></table></figure>

<p>上传hdfs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put user.txt /hbase/input</span><br></pre></td></tr></table></figure>

<h4 id="定义mapper"><a href="#定义mapper" class="headerlink" title="定义mapper"></a>定义mapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.io.LongWritable;</span><br><span class="line">import org.apache.hadoop.io.NullWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过这个mapper读取hdfs上面的文件，然后进行处理</span><br><span class="line"> */</span><br><span class="line">public class HDFSMapper extends Mapper&lt;LongWritable,Text,Text,NullWritable&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //读取到数据之后不做任何处理，直接将数据写入到reduce里面去进行处理</span><br><span class="line">        context.write(value,NullWritable.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义reduce"><a href="#定义reduce" class="headerlink" title="定义reduce"></a>定义reduce</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line">import org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line">import org.apache.hadoop.io.NullWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class HBaseWriteReducer extends TableReducer&lt;Text,NullWritable,ImmutableBytesWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 0007    zhangsan        18</span><br><span class="line">     0008    lisi    25</span><br><span class="line">     0009    wangwu  20</span><br><span class="line"></span><br><span class="line">     * @param key</span><br><span class="line">     * @param values</span><br><span class="line">     * @param context</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void reduce(Text key, Iterable&lt;NullWritable&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String[] split = key.toString().split(&quot;\t&quot;);</span><br><span class="line"></span><br><span class="line">        Put put = new Put(split[0].getBytes());</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),split[1].getBytes());</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),split[2].getBytes());</span><br><span class="line">        //将我们的数据写出去，key3是ImmutableBytesWritable，这个里面装的是rowkey</span><br><span class="line">        //然后将写出去的数据封装到put对象里面去了</span><br><span class="line">        context.write(new ImmutableBytesWritable(split[0].getBytes()),put);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义主类-1"><a href="#定义主类-1" class="headerlink" title="定义主类"></a>定义主类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.conf.Configured;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line">import org.apache.hadoop.io.NullWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class="line">import org.apache.hadoop.util.Tool;</span><br><span class="line">import org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line">import javax.swing.plaf.nimbus.AbstractRegionPainter;</span><br><span class="line"></span><br><span class="line">public class HdfsHBaseMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        //获取job对象</span><br><span class="line">        Job job = Job.getInstance(super.getConf(), &quot;hdfs2Hbase&quot;);</span><br><span class="line"></span><br><span class="line">        //第一步：读取文件，解析成key，value对</span><br><span class="line">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        TextInputFormat.addInputPath(job,new Path(&quot;hdfs://node01:8020/hbase/input&quot;));</span><br><span class="line"></span><br><span class="line">        //第二步：自定义map逻辑，接受k1,v1，转换成为k2  v2进行输出</span><br><span class="line">        job.setMapperClass(HDFSMapper.class);</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(NullWritable.class);</span><br><span class="line"></span><br><span class="line">        //分区，排序，规约，分组</span><br><span class="line"></span><br><span class="line">        //第七步：设置reduce类</span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(&quot;myuser2&quot;,HBaseWriteReducer.class,job);</span><br><span class="line"></span><br><span class="line">        boolean b = job.waitForCompletion(true);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return b?0:1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line">        int run = ToolRunner.run(configuration, new HdfsHBaseMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="需求三-通过bulkload的方式批量加载数据到HBase当中去"><a href="#需求三-通过bulkload的方式批量加载数据到HBase当中去" class="headerlink" title="需求三 通过bulkload的方式批量加载数据到HBase当中去"></a>需求三 通过bulkload的方式批量加载数据到HBase当中去</h4><p>加载数据到HBase当中去的方式多种多样，我们可以使用HBase的javaAPI或者使用sqoop将我们的数据写入或者导入到HBase当中去，但是这些方式不是慢就是在导入的过程的占用Region资源导致效率低下，我们也可以通过MR的程序，将我们的数据直接转换成HBase的最终存储格式HFile，然后直接load数据到HBase当中去即可</p>
<p>HBase中每张Table在根目录（/HBase）下用一个文件夹存储，Table名为文件夹名，在Table文件夹下每个Region同样用一个文件夹存储，每个Region文件夹下的每个列族也用文件夹存储，而每个列族下存储的就是一些HFile文件，HFile就是HBase数据在HFDS下存储格式，所以HBase存储文件最终在hdfs上面的表现形式就是HFile，如果我们可以直接将数据转换为HFile的格式，那么我们的HBase就可以直接读取加载HFile格式的文件，就可以直接读取了</p>
<p>优点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.导入过程不占用Region资源 </span><br><span class="line">2.能快速导入海量的数据</span><br><span class="line">3.节省内存</span><br></pre></td></tr></table></figure>

<p>使用bulkload的方式将我们的数据直接生成HFile格式，然后直接加载到HBase的表当中去,不走hlog和hRegionServer.</p>
<p>例如:</p>
<p>将我们hdfs上面的这个路径/hbase/input/user.txt的数据文件，转换成HFile格式，然后load到myuser2这张表里面去</p>
<h4 id="定义mapper-1"><a href="#定义mapper-1" class="headerlink" title="定义mapper"></a>定义mapper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line">import org.apache.hadoop.io.LongWritable;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line">import org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class HDFSReadMapper  extends Mapper&lt;LongWritable,Text,ImmutableBytesWritable,Put&gt;&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 0007    zhangsan        18</span><br><span class="line">     0008    lisi    25</span><br><span class="line">     0009    wangwu  20</span><br><span class="line"></span><br><span class="line">     * @param key</span><br><span class="line">     * @param value</span><br><span class="line">     * @param context</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">        String[] split = value.toString().split(&quot;\t&quot;);</span><br><span class="line"></span><br><span class="line">        Put put = new Put(split[0].getBytes());</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;name&quot;.getBytes(),split[1].getBytes());</span><br><span class="line">        put.addColumn(&quot;f1&quot;.getBytes(),&quot;age&quot;.getBytes(),split[2].getBytes());</span><br><span class="line"></span><br><span class="line">        context.write(new ImmutableBytesWritable(split[0].getBytes()),put);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主类-程序入口"><a href="#主类-程序入口" class="headerlink" title="主类 程序入口"></a>主类 程序入口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.conf.Configured;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.TableName;</span><br><span class="line">import org.apache.hadoop.hbase.client.Connection;</span><br><span class="line">import org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.client.Table;</span><br><span class="line">import org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line">import org.apache.hadoop.hbase.mapreduce.HFileOutputFormat2;</span><br><span class="line">import org.apache.hadoop.hdfs.DFSUtil;</span><br><span class="line">import org.apache.hadoop.mapreduce.Job;</span><br><span class="line">import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</span><br><span class="line">import org.apache.hadoop.util.Tool;</span><br><span class="line">import org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line">public class BulkLoadMain extends Configured implements Tool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int run(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration conf = super.getConf();</span><br><span class="line">        //获取job对象</span><br><span class="line">        Job job = Job.getInstance(conf, &quot;bulkLoad&quot;);</span><br><span class="line">        Connection connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(&quot;myuser2&quot;));</span><br><span class="line"></span><br><span class="line">        //读取文件</span><br><span class="line">        job.setInputFormatClass(TextInputFormat.class);</span><br><span class="line">        TextInputFormat.addInputPath(job,new Path(&quot;hdfs://node01:8020/hbase/input&quot;));</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(HDFSReadMapper.class);</span><br><span class="line">        job.setMapOutputKeyClass(ImmutableBytesWritable.class);</span><br><span class="line">        job.setMapOutputValueClass(Put.class);</span><br><span class="line"></span><br><span class="line">        //将数据输出成为HFile格式</span><br><span class="line"></span><br><span class="line">        //Job job, Table table, RegionLocator regionLocator</span><br><span class="line">        //配置增量的添加数据</span><br><span class="line">        HFileOutputFormat2.configureIncrementalLoad(job,table,connection.getRegionLocator(TableName.valueOf(&quot;myuser2&quot;)));</span><br><span class="line">        //设置输出classs类，决定了我们输出数据格式</span><br><span class="line">        job.setOutputFormatClass(HFileOutputFormat2.class);</span><br><span class="line">        //设置输出路径</span><br><span class="line">        HFileOutputFormat2.setOutputPath(job,new Path(&quot;hdfs://node01:8020/hbase/hfile_out&quot;));</span><br><span class="line"></span><br><span class="line">        boolean b = job.waitForCompletion(true);</span><br><span class="line"></span><br><span class="line">        return b?0:1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181,node02:2181,node03:2181&quot;);</span><br><span class="line">        int run = ToolRunner.run(configuration, new BulkLoadMain(), args);</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打jar包上传运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jar original-hbaseStudy-1.0-SNAPSHOT.jar  cn.baidu.hbasemr.HBaseLoad</span><br></pre></td></tr></table></figure>

<h4 id="开发代码-加载数据"><a href="#开发代码-加载数据" class="headerlink" title="开发代码 加载数据"></a>开发代码 加载数据</h4><p>将我们的输出路径下面的HFile文件，加载到我们的hbase表当中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.TableName;</span><br><span class="line">import org.apache.hadoop.hbase.client.Admin;</span><br><span class="line">import org.apache.hadoop.hbase.client.Connection;</span><br><span class="line">import org.apache.hadoop.hbase.client.ConnectionFactory;</span><br><span class="line">import org.apache.hadoop.hbase.client.Table;</span><br><span class="line">import org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles;</span><br><span class="line"></span><br><span class="line">public class LoadData &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Configuration configuration = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.property.clientPort&quot;, &quot;2181&quot;);</span><br><span class="line">        configuration.set(&quot;hbase.zookeeper.quorum&quot;, &quot;node01,node02,node03&quot;);</span><br><span class="line">        Connection connection =  ConnectionFactory.createConnection(configuration);</span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(&quot;myuser2&quot;));</span><br><span class="line">        LoadIncrementalHFiles load = new LoadIncrementalHFiles(configuration);</span><br><span class="line">        load.doBulkLoad(new Path(&quot;hdfs://node01:8020/hbase/hfile_out&quot;), admin,table,connection.getRegionLocator(TableName.valueOf(&quot;myuser2&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们也可以通过命令行来进行加载数据</p>
<p>先将hbase的jar包添加到hadoop的classpath路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export HBASE_HOME=/export/servers/hbase-2.0.0/</span><br><span class="line">export HADOOP_HOME=/export/servers/hadoop-2.7.5/</span><br><span class="line">export HADOOP_CLASSPATH=$&#123;HBASE_HOME&#125;/bin/hbase mapredcp</span><br></pre></td></tr></table></figure>

<p>然后执行以下命令，将hbase的HFile直接导入到表myuser2当中来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jar /export/servers/hbase-2.0.0/lib/hbase-server-1.2.0-cdh5.14.0.jar completebulkload /hbase/hfile_out myuser2</span><br></pre></td></tr></table></figure>

<p>##二 hive 与Hbase的对比</p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><h3 id="数据仓库工具"><a href="#数据仓库工具" class="headerlink" title="数据仓库工具"></a>数据仓库工具</h3><p>Hive的本质其实就相当于将HDFS中已经存储的文件在Mysql中做了一个双射关系，以方便使用HQL去管理查询。</p>
<h3 id="用于数据分析、清洗"><a href="#用于数据分析、清洗" class="headerlink" title="用于数据分析、清洗"></a>用于数据分析、清洗</h3><p>Hive适用于离线的数据分析和清洗，延迟较高</p>
<h3 id="基于HDFS、MapReduce"><a href="#基于HDFS、MapReduce" class="headerlink" title="基于HDFS、MapReduce"></a>基于HDFS、MapReduce</h3><p>Hive存储的数据依旧在DataNode上，编写的HQL语句终将是转换为MapReduce代码执行。</p>
<h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h3 id="nosql数据库"><a href="#nosql数据库" class="headerlink" title="nosql数据库"></a>nosql数据库</h3><p>是一种面向列存储的非关系型数据库。</p>
<h3 id="用于存储结构化和非结构话的数据"><a href="#用于存储结构化和非结构话的数据" class="headerlink" title="用于存储结构化和非结构话的数据"></a>用于存储结构化和非结构话的数据</h3><p>适用于单表非关系型数据的存储，不适合做关联查询，类似JOIN等操作。</p>
<h3 id="基于HDFS"><a href="#基于HDFS" class="headerlink" title="基于HDFS"></a>基于HDFS</h3><p>数据持久化存储的体现形式是Hfile，存放于DataNode中，被ResionServer以region的形式进行管理。</p>
<h3 id="延迟较低，接入在线业务使用"><a href="#延迟较低，接入在线业务使用" class="headerlink" title="延迟较低，接入在线业务使用"></a>延迟较低，接入在线业务使用</h3><p>面对大量的企业数据，HBase可以直线单表大量数据的存储，同时提供了高效的数据访问速度。</p>
<h3 id="总结：Hive与HBase"><a href="#总结：Hive与HBase" class="headerlink" title="总结：Hive与HBase"></a>总结：Hive与HBase</h3><p>Hive和Hbase是两种基于Hadoop的不同技术，Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到HBase，或者从HBase写回Hive。</p>
<p>##三 hive 与hbase的整合</p>
<p>hive与我们的HBase各有千秋，各自有着不同的功能，但是归根接地，hive与hbase的数据最终都是存储在hdfs上面的，一般的我们为了存储磁盘的空间，不会将一份数据存储到多个地方，导致磁盘空间的浪费，我们可以直接将数据存入hbase，然后通过hive整合hbase直接使用sql语句分析hbase里面的数据即可，非常方便</p>
<h3 id="需求一将hive分析结果的数据，保存到HBase当中去"><a href="#需求一将hive分析结果的数据，保存到HBase当中去" class="headerlink" title="需求一将hive分析结果的数据，保存到HBase当中去"></a>需求一将hive分析结果的数据，保存到HBase当中去</h3><h4 id="1-拷贝hbase的五个依赖jar包到hive的lib目录下"><a href="#1-拷贝hbase的五个依赖jar包到hive的lib目录下" class="headerlink" title="1 拷贝hbase的五个依赖jar包到hive的lib目录下"></a>1 拷贝hbase的五个依赖jar包到hive的lib目录下</h4><p>将我们HBase的五个jar包拷贝到hive的lib目录下</p>
<p>hbase的jar包都在/export/servers/hbase-2.0.0/lib</p>
<p>我们需要拷贝五个jar包名字如下</p>
<p>hbase-client-2.0.0.jar</p>
<p>hbase-hadoop2-compat-2.0.0.jar</p>
<p>hbase-hadoop-compat-2.0.0.jar</p>
<p>hbase-it-2.0.0.jar</p>
<p>hbase-server-2.0.0.jar</p>
<p>我们直接在node03执行以下命令，通过创建软连接的方式来进行jar包的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ln -s /export/servers/hbase-2.0.0/lib/hbase-client-2.0.0.jar /export/servers/apache-hive-2.1.0-bin/lib/hbase-client-2.0.0.jar</span><br><span class="line">ln -s /export/servers/hbase-2.0.0/lib/hbase-hadoop2-compat-2.0.0.jar /export/servers/apache-hive-2.1.0-bin/lib/hbase-hadoop2-compat-2.0.0.jar</span><br><span class="line">ln -s /export/servers/hbase-2.0.0/lib/hbase-hadoop-compat-2.0.0.jar /export/servers/apache-hive-2.1.0-bin/lib/hbase-hadoop-compat-2.0.0.jar</span><br><span class="line">ln -s /export/servers/hbase-2.0.0/lib/hbase-it-2.0.0.jar /export/servers/apache-hive-2.1.0-bin/lib/hbase-it-2.0.0.jar</span><br><span class="line">ln -s /export/servers/hbase-2.0.0/lib/hbase-server-2.0.0.jar /export/servers/apache-hive-2.1.0-bin/lib/hbase-server-2.0.0.jar</span><br></pre></td></tr></table></figure>

<h4 id="2-修改hive的配置文件"><a href="#2-修改hive的配置文件" class="headerlink" title="2 修改hive的配置文件"></a>2 修改hive的配置文件</h4><p>编辑node03服务器上面的hive的配置文件hive-site.xml添加以下两行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hive.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node01,node02,node03&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line"> &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;node01,node02,node03&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-修改hive-env-sh配置文件添加以下配置"><a href="#3-修改hive-env-sh配置文件添加以下配置" class="headerlink" title="3 修改hive-env.sh配置文件添加以下配置"></a>3 修改hive-env.sh配置文件添加以下配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/export/servers/hadoop-2.7.5</span><br><span class="line">export HBASE_HOME=/export/servers/hbase-2.0.0</span><br><span class="line">export HIVE_CONF_DIR=/export/servers/apache-hive-2.1.0-bin/conf</span><br></pre></td></tr></table></figure>

<h4 id="4-hive当中建表并加载以下数据"><a href="#4-hive当中建表并加载以下数据" class="headerlink" title="4 hive当中建表并加载以下数据"></a>4 hive当中建表并加载以下数据</h4><h4 id="hive当中建表"><a href="#hive当中建表" class="headerlink" title="hive当中建表"></a>hive当中建表</h4><p>进入hive客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hive</span><br></pre></td></tr></table></figure>

<p>创建hive数据库与hive对应的数据库表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database course;</span><br><span class="line">use course;</span><br><span class="line">create external table if not exists course.score(id int,cname string,score int) row format delimited fields terminated by &apos;\t&apos; stored as textfile;</span><br></pre></td></tr></table></figure>

<h4 id="准备数据内容如下"><a href="#准备数据内容如下" class="headerlink" title="准备数据内容如下"></a>准备数据内容如下</h4><p>node03执行以下命令，准备数据文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim hive-hbase.txt</span><br><span class="line"></span><br><span class="line">1       zhangsan        80</span><br><span class="line">2       lisi    60</span><br><span class="line">3       wangwu  30</span><br><span class="line">4       zhaoliu 70</span><br></pre></td></tr></table></figure>

<h4 id="进行加载数据"><a href="#进行加载数据" class="headerlink" title="进行加载数据"></a>进行加载数据</h4><p>进入hive客户端进行加载数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (course)&gt; load data local inpath &apos;/export/hive-hbase.txt&apos; into table score;</span><br><span class="line">hive (course)&gt; select * from score;</span><br></pre></td></tr></table></figure>

<h4 id="5-创建hive管理表与HBase进行映射"><a href="#5-创建hive管理表与HBase进行映射" class="headerlink" title="5 创建hive管理表与HBase进行映射"></a>5 创建hive管理表与HBase进行映射</h4><p>我们可以创建一个hive的管理表与hbase当中的表进行映射，hive管理表当中的数据，都会存储到hbase上面去</p>
<p>hive当中创建内部表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table course.hbase_score(id int,cname string,score int)  </span><br><span class="line">stored by &apos;org.apache.hadoop.hive.hbase.HBaseStorageHandler&apos;  </span><br><span class="line">with serdeproperties(&quot;hbase.columns.mapping&quot; = &quot;cf:name,cf:score&quot;) </span><br><span class="line">tblproperties(&quot;hbase.table.name&quot; = &quot;hbase_score&quot;);</span><br></pre></td></tr></table></figure>

<p>通过insert overwrite select 插入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert overwrite table course.hbase_score select id,cname,score from course.score;</span><br></pre></td></tr></table></figure>

<h4 id="6-hbase当中查看表hbase-score"><a href="#6-hbase当中查看表hbase-score" class="headerlink" title="6 hbase当中查看表hbase_score"></a>6 hbase当中查看表hbase_score</h4><p>进入hbase的客户端查看表hbase_score，并查看当中的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):023:0&gt; list</span><br><span class="line">TABLE                                                                                       </span><br><span class="line">hbase_score                                                                                 </span><br><span class="line">myuser                                                                                      </span><br><span class="line">myuser2                                                                                     </span><br><span class="line">student                                                                                     </span><br><span class="line">user                                                                                        </span><br><span class="line">5 row(s) in 0.0210 seconds</span><br><span class="line"></span><br><span class="line">=&gt; [&quot;hbase_score&quot;, &quot;myuser&quot;, &quot;myuser2&quot;, &quot;student&quot;, &quot;user&quot;]</span><br><span class="line">hbase(main):024:0&gt; scan &apos;hbase_score&apos;</span><br><span class="line">ROW                      COLUMN+CELL                                                        </span><br><span class="line"> 1                       column=cf:name, timestamp=1550628395266, value=zhangsan            </span><br><span class="line"> 1                       column=cf:score, timestamp=1550628395266, value=80                 </span><br><span class="line"> 2                       column=cf:name, timestamp=1550628395266, value=lisi                </span><br><span class="line"> 2                       column=cf:score, timestamp=1550628395266, value=60                 </span><br><span class="line"> 3                       column=cf:name, timestamp=1550628395266, value=wangwu              </span><br><span class="line"> 3                       column=cf:score, timestamp=1550628395266, value=30                 </span><br><span class="line"> 4                       column=cf:name, timestamp=1550628395266, value=zhaoliu             </span><br><span class="line"> 4                       column=cf:score, timestamp=1550628395266, value=70                 </span><br><span class="line">4 row(s) in 0.0360 seconds</span><br></pre></td></tr></table></figure>

<h3 id="需求二创建hive外部表，映射HBase当中已有的表模型，"><a href="#需求二创建hive外部表，映射HBase当中已有的表模型，" class="headerlink" title="需求二创建hive外部表，映射HBase当中已有的表模型，"></a>需求二创建hive外部表，映射HBase当中已有的表模型，</h3><h3 id="第一步：HBase当中创建表并手动插入加载一些数据"><a href="#第一步：HBase当中创建表并手动插入加载一些数据" class="headerlink" title="第一步：HBase当中创建表并手动插入加载一些数据"></a>第一步：HBase当中创建表并手动插入加载一些数据</h3><p>进入HBase的shell客户端，手动创建一张表，并插入加载一些数据进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create &apos;hbase_hive_score&apos;,&#123; NAME =&gt;&apos;cf&apos;&#125;</span><br><span class="line">put &apos;hbase_hive_score&apos;,&apos;1&apos;,&apos;cf:name&apos;,&apos;zhangsan&apos;</span><br><span class="line">put &apos;hbase_hive_score&apos;,&apos;1&apos;,&apos;cf:score&apos;, &apos;95&apos;</span><br><span class="line">put &apos;hbase_hive_score&apos;,&apos;2&apos;,&apos;cf:name&apos;,&apos;lisi&apos;</span><br><span class="line">put &apos;hbase_hive_score&apos;,&apos;2&apos;,&apos;cf:score&apos;, &apos;96&apos;</span><br><span class="line">put &apos;hbase_hive_score&apos;,&apos;3&apos;,&apos;cf:name&apos;,&apos;wangwu&apos;</span><br><span class="line">put &apos;hbase_hive_score&apos;,&apos;3&apos;,&apos;cf:score&apos;, &apos;97&apos;</span><br></pre></td></tr></table></figure>

<p>操作成功结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):049:0&gt; create &apos;hbase_hive_score&apos;,&#123; NAME =&gt;&apos;cf&apos;&#125;</span><br><span class="line">0 row(s) in 1.2970 seconds</span><br><span class="line"></span><br><span class="line">=&gt; Hbase::Table - hbase_hive_score</span><br><span class="line">hbase(main):050:0&gt; put &apos;hbase_hive_score&apos;,&apos;1&apos;,&apos;cf:name&apos;,&apos;zhangsan&apos;</span><br><span class="line">0 row(s) in 0.0600 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):051:0&gt; put &apos;hbase_hive_score&apos;,&apos;1&apos;,&apos;cf:score&apos;, &apos;95&apos;</span><br><span class="line">0 row(s) in 0.0310 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):052:0&gt; put &apos;hbase_hive_score&apos;,&apos;2&apos;,&apos;cf:name&apos;,&apos;lisi&apos;</span><br><span class="line">0 row(s) in 0.0230 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):053:0&gt; put &apos;hbase_hive_score&apos;,&apos;2&apos;,&apos;cf:score&apos;, &apos;96&apos;</span><br><span class="line">0 row(s) in 0.0220 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):054:0&gt; put &apos;hbase_hive_score&apos;,&apos;3&apos;,&apos;cf:name&apos;,&apos;wangwu&apos;</span><br><span class="line">0 row(s) in 0.0200 seconds</span><br><span class="line"></span><br><span class="line">hbase(main):055:0&gt; put &apos;hbase_hive_score&apos;,&apos;3&apos;,&apos;cf:score&apos;, &apos;97&apos;</span><br><span class="line">0 row(s) in 0.0250 seconds</span><br></pre></td></tr></table></figure>

<h3 id="第二步：建立hive的外部表，映射HBase当中的表以及字段"><a href="#第二步：建立hive的外部表，映射HBase当中的表以及字段" class="headerlink" title="第二步：建立hive的外部表，映射HBase当中的表以及字段"></a>第二步：建立hive的外部表，映射HBase当中的表以及字段</h3><p>在hive当中建立外部表，</p>
<p>进入hive客户端，然后执行以下命令进行创建hive外部表，就可以实现映射HBase当中的表数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE external TABLE course.hbase2hive(id int, name string, score int) STORED BY &apos;org.apache.hadoop.hive.hbase.HBaseStorageHandler&apos; WITH SERDEPROPERTIES (&quot;hbase.columns.mapping&quot; = &quot;:key,cf:name,cf:score&quot;) TBLPROPERTIES(&quot;hbase.table.name&quot; =&quot;hbase_hive_score&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="四-hbase预分区"><a href="#四-hbase预分区" class="headerlink" title="四 hbase预分区"></a>四 hbase预分区</h2><h2 id="1、为何要预分区？"><a href="#1、为何要预分区？" class="headerlink" title="1、为何要预分区？"></a>1、为何要预分区？</h2><p>* 增加数据读写效率</p>
<p>* 负载均衡，防止数据倾斜</p>
<p>* 方便集群容灾调度region</p>
<p>* 优化Map数量</p>
<h2 id="2、如何预分区？"><a href="#2、如何预分区？" class="headerlink" title="2、如何预分区？"></a>2、如何预分区？</h2><p>每一个region维护着startRow与endRowKey，如果加入的数据符合某个region维护的rowKey范围，则该数据交给这个region维护。</p>
<h2 id="3、如何设定预分区？"><a href="#3、如何设定预分区？" class="headerlink" title="3、如何设定预分区？"></a>3、如何设定预分区？</h2><h3 id="1、手动指定预分区"><a href="#1、手动指定预分区" class="headerlink" title="1、手动指定预分区"></a>1、手动指定预分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):001:0&gt; create &apos;staff&apos;,&apos;info&apos;,&apos;partition1&apos;,SPLITS =&gt; [&apos;1000&apos;,&apos;2000&apos;,&apos;3000&apos;,&apos;4000&apos;]</span><br></pre></td></tr></table></figure>

<h3 id="2、使用16进制算法生成预分区"><a href="#2、使用16进制算法生成预分区" class="headerlink" title="2、使用16进制算法生成预分区"></a>2、使用16进制算法生成预分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):003:0&gt; create &apos;staff2&apos;,&apos;info&apos;,&apos;partition2&apos;,&#123;NUMREGIONS =&gt; 15, SPLITALGO =&gt; &apos;HexStringSplit&apos;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、使用JavaAPI创建预分区"><a href="#3、使用JavaAPI创建预分区" class="headerlink" title="3、使用JavaAPI创建预分区"></a>3、使用JavaAPI创建预分区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同 hbase上篇</span><br></pre></td></tr></table></figure>

<h2 id="五-HBase的rowKey设计技巧"><a href="#五-HBase的rowKey设计技巧" class="headerlink" title="五 HBase的rowKey设计技巧"></a>五 HBase的rowKey设计技巧</h2><p>HBase是三维有序存储的，通过rowkey（行键），column key（column family和qualifier）和TimeStamp（时间戳）这个三个维度可以对HBase中的数据进行快速定位。</p>
<p>HBase中rowkey可以唯一标识一行记录，在HBase查询的时候，有以下几种方式：</p>
<ol>
<li>通过get方式，指定rowkey获取唯一一条记录</li>
<li>通过scan方式，设置startRow和stopRow参数进行范围匹配</li>
<li>全表扫描，即直接扫描整张表中所有行记录</li>
</ol>
<h3 id="1-rowkey长度原则"><a href="#1-rowkey长度原则" class="headerlink" title="1 rowkey长度原则"></a>1 rowkey长度原则</h3><p>rowkey是一个二进制码流，可以是任意字符串，最大长度64kb，实际应用中一般为10-100bytes，以byte[]形式保存，一般设计成定长。</p>
<p>建议越短越好，不要超过16个字节，原因如下：</p>
<p>v 数据的持久化文件HFile中是按照KeyValue存储的，如果rowkey过长，比如超过100字节，1000w行数据，光rowkey就要占用100*1000w=10亿个字节，将近1G数据，这样会极大影响HFile的存储效率；</p>
<p>v MemStore将缓存部分数据到内存，如果rowkey字段过长，内存的有效利用率就会降低，系统不能缓存更多的数据，这样会降低检索效率。</p>
<h3 id="2-rowkey散列原则"><a href="#2-rowkey散列原则" class="headerlink" title="2 rowkey散列原则"></a>2 rowkey散列原则</h3><p>如果rowkey按照时间戳的方式递增，不要将时间放在二进制码的前面，建议将rowkey的高位作为散列字段，由程序随机生成，低位放时间字段，这样将提高数据均衡分布在每个RegionServer，以实现负载均衡的几率。如果没有散列字段，首字段直接是时间信息，所有的数据都会集中在一个RegionServer上，这样在数据检索的时候负载会集中在个别的RegionServer上，造成热点问题，会降低查询效率。</p>
<h3 id="3-rowkey唯一原则"><a href="#3-rowkey唯一原则" class="headerlink" title="3 rowkey唯一原则"></a>3 rowkey唯一原则</h3><p>必须在设计上保证其唯一性，rowkey是按照字典顺序排序存储的，因此，设计rowkey的时候，要充分利用这个排序的特点，将经常读取的数据存储到一块，将最近可能会被访问的数据放到一块。</p>
<h3 id="4什么是热点"><a href="#4什么是热点" class="headerlink" title="4什么是热点"></a>4什么是热点</h3><p>HBase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。然而糟糕的rowkey设计是热点的源头。</p>
<p>热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作）。大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求。</p>
<p>设计良好的数据访问模式以使集群被充分，均衡的利用。为了避免写热点，设计rowkey使得不同行在同一个region，但是在更多数据情况下，数据应该被写入集群的多个region，而不是一个。下面是一些常见的避免热点的方法以及它们的优缺点：</p>
<h4 id="1加盐"><a href="#1加盐" class="headerlink" title="1加盐"></a>1加盐</h4><p>这里所说的加盐不是密码学中的加盐，而是在rowkey的前面增加随机数，具体就是给rowkey分配一个随机前缀以使得它和之前的rowkey的开头不同。分配的前缀种类数量应该和你想使用数据分散到不同的region的数量一致。加盐之后的rowkey就会根据随机生成的前缀分散到各个region上，以避免热点。</p>
<h4 id="2哈希"><a href="#2哈希" class="headerlink" title="2哈希"></a>2哈希</h4><p>哈希会使同一行永远用一个前缀加盐。哈希也可以使负载分散到整个集群，但是读却是可以预测的。使用确定的哈希可以让客户端重构完整的rowkey，可以使用get操作准确获取某一个行数据。</p>
<h4 id="3反转"><a href="#3反转" class="headerlink" title="3反转"></a>3反转</h4><p>第三种防止热点的方法时反转固定长度或者数字格式的rowkey。这样可以使得rowkey中经常改变的部分（最没有意义的部分）放在前面。这样可以有效的随机rowkey，但是牺牲了rowkey的有序性。</p>
<p>反转rowkey的例子以手机号为rowkey，可以将手机号反转后的字符串作为rowkey，这样的就避免了以手机号那样比较固定开头导致热点问题</p>
<h4 id="3时间戳反转"><a href="#3时间戳反转" class="headerlink" title="3时间戳反转"></a>3时间戳反转</h4><p>一个常见的数据处理问题是快速获取数据的最近版本，使用反转的时间戳作为rowkey的一部分对这个问题十分有用，可以用 Long.Max_Value - timestamp 追加到key的末尾，例如 [key][reverse_timestamp] , [key] 的最新值可以通过scan [key]获得[key]的第一条记录，因为HBase中rowkey是有序的，第一条记录是最后录入的数据。</p>
<p>其他一些建议：</p>
<p>尽量减少行键和列族的大小在HBase中，value永远和它的key一起传输的。当具体的值在系统间传输时，它的rowkey，列名，时间戳也会一起传输。如果你的rowkey和列名很大，这个时候它们将会占用大量的存储空间。</p>
<p>列族尽可能越短越好，最好是一个字符。</p>
<p>冗长的属性名虽然可读性好，但是更短的属性名存储在HBase中会更好。</p>
<h2 id="六-Hbase的协处理器"><a href="#六-Hbase的协处理器" class="headerlink" title="六 Hbase的协处理器"></a>六 Hbase的协处理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hbase.apache.org/book.html#cp</span><br></pre></td></tr></table></figure>

<p>1、 起源 Hbase 作为列族数据库最经常被人诟病的特性包括：无法轻易建立“二级索引”，难以执 行求和、计数、排序等操作。比如，在旧版本的(&lt;0.92)Hbase 中，统计数据表的总行数，需 要使用 Counter 方法，执行一次 MapReduce Job 才能得到。虽然 HBase 在数据存储层中集成 了 MapReduce，能够有效用于数据表的分布式计算。然而在很多情况下，做一些简单的相 加或者聚合计算的时候， 如果直接将计算过程放置在 server 端，能够减少通讯开销，从而获 得很好的性能提升。于是， HBase 在 0.92 之后引入了协处理器(coprocessors)，实现一些激动 人心的新特性：能够轻易建立二次索引、复杂过滤器(谓词下推)以及访问控制等。</p>
<h2 id="2、协处理器有两种：-observer-和-endpoint"><a href="#2、协处理器有两种：-observer-和-endpoint" class="headerlink" title="2、协处理器有两种： observer 和 endpoint"></a>2、协处理器有两种： observer 和 endpoint</h2><p>(1) Observer 类似于传统数据库中的触发器，当发生某些事件的时候这类协处理器会被 Server 端调用。Observer Coprocessor 就是一些散布在 HBase Server 端代码中的 hook 钩子， 在固定的事件发生时被调用。比如： put 操作之前有钩子函数 prePut，该函数在 put 操作<br>执行前会被 Region Server 调用；在 put 操作之后则有 postPut 钩子函数</p>
<p>以 Hbase2.0.0 版本为例，它提供了三种观察者接口：<br>● RegionObserver：提供客户端的数据操纵事件钩子： Get、 Put、 Delete、 Scan 等。<br>● WALObserver：提供 WAL 相关操作钩子。<br>● MasterObserver：提供 DDL-类型的操作钩子。如创建、删除、修改数据表等。<br>到 0.96 版本又新增一个 RegionServerObserver</p>
<p>下图是以 RegionObserver 为例子讲解 Observer 这种协处理器的原理：</p>
<p><a href="https://manzhong.github.io/images/Hbase/xcl.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Hbase/xcl.png" alt="img"></a></p>
<p>(2) Endpoint 协处理器类似传统数据库中的存储过程，客户端可以调用这些 Endpoint 协处 理器执行一段 Server 端代码，并将 Server 端代码的结果返回给客户端进一步处理，最常 见的用法就是进行聚集操作。如果没有协处理器，当用户需要找出一张表中的最大数据，即</p>
<p>max 聚合操作，就必须进行全表扫描，在客户端代码内遍历扫描结果，并执行求最大值的 操作。这样的方法无法利用底层集群的并发能力，而将所有计算都集中到 Client 端统一执 行，势必效率低下。利用 Coprocessor，用户可以将求最大值的代码部署到 HBase Server 端，<br>HBase 将利用底层 cluster 的多个节点并发执行求最大值的操作。即在每个 Region 范围内 执行求最大值的代码，将每个 Region 的最大值在 Region Server 端计算出，仅仅将该 max 值返回给客户端。在客户端进一步将多个 Region 的最大值进一步处理而找到其中的最大值。<br>这样整体的执行效率就会提高很多<br>下图是 EndPoint 的工作原理：</p>
<p><a href="https://manzhong.github.io/images/Hbase/xcl2.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Hbase/xcl2.png" alt="img"></a></p>
<p>(3)总结</p>
<p>Observer 允许集群在正常的客户端操作过程中可以有不同的行为表现<br>Endpoint 允许扩展集群的能力，对客户端应用开放新的运算命令<br>observer 类似于 RDBMS 中的触发器，主要在服务端工作<br>endpoint 类似于 RDBMS 中的存储过程，主要在 client 端工作<br>observer 可以实现权限管理、优先级设置、监控、 ddl 控制、 二级索引等功能<br>endpoint 可以实现 min、 max、 avg、 sum、 distinct、 group by 等功能</p>
<h2 id="3、协处理器加载方式"><a href="#3、协处理器加载方式" class="headerlink" title="3、协处理器加载方式"></a>3、协处理器加载方式</h2><p> 协处理器的加载方式有两种，我们称之为静态加载方式（ Static Load） 和动态加载方式 （ Dynamic Load）。 静态加载的协处理器称之为 System Coprocessor，动态加载的协处理器称 之为 Table Coprocessor<br>​ 1、静态加载</p>
<p>通过修改 hbase-site.xml 这个文件来实现， 启动全局 aggregation，能过操纵所有的表上 的数据。只需要添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hbase.coprocessor.user.region.classes&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.hbase.coprocessor.AggregateImplementation&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>为所有 table 加载了一个 cp class，可以用” ,”分割加载多个 class</p>
<p>2、动态加载</p>
<p>启用表 aggregation，只对特定的表生效。通过 HBase Shell 来实现。<br>disable 指定表。 hbase&gt; disable ‘mytable’<br>添加 aggregation<br>hbase&gt; alter ‘mytable’, METHOD =&gt; ‘table_att’,’coprocessor’=&gt;<br>‘|org.apache.Hadoop.hbase.coprocessor.AggregateImplementation||’<br>重启指定表 hbase&gt; enable ‘mytable’</p>
<p>协处理器卸载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三步</span><br><span class="line">disable &apos;test&apos;</span><br><span class="line">alter &apos;test&apos;,METHOD=&gt;&apos;table_att_unset&apos;,NAME=&gt;&apos;coprocessor$1&apos;</span><br><span class="line">enable &apos;test&apos;</span><br></pre></td></tr></table></figure>

<h2 id="4、协处理器Observer应用实战"><a href="#4、协处理器Observer应用实战" class="headerlink" title="4、协处理器Observer应用实战"></a>4、协处理器Observer应用实战</h2><p>通过协处理器Observer实现hbase当中一张表插入数据，然后通过协处理器，将数据复制一份保存到另外一张表当中去，但是只取当第一张表当中的部分列数据保存到第二张表当中去</p>
<h3 id="第一步：HBase当中创建第一张表proc1"><a href="#第一步：HBase当中创建第一张表proc1" class="headerlink" title="第一步：HBase当中创建第一张表proc1"></a>第一步：HBase当中创建第一张表proc1</h3><p>在HBase当中创建一张表，表名user2，并只有一个列族info</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/hbase-2.0.0/</span><br><span class="line">bin/hbase shell</span><br><span class="line">hbase(main):053:0&gt; create &apos;proc1&apos;,&apos;info&apos;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：Hbase当中创建第二张表proc2"><a href="#第二步：Hbase当中创建第二张表proc2" class="headerlink" title="第二步：Hbase当中创建第二张表proc2"></a>第二步：Hbase当中创建第二张表proc2</h3><p>创建第二张表’proc2，作为目标表，将第一张表当中插入数据的部分列，使用协处理器，复制到’proc2表当中来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):054:0&gt; create &apos;proc2&apos;,&apos;info&apos;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：开发HBase的协处理器"><a href="#第三步：开发HBase的协处理器" class="headerlink" title="第三步：开发HBase的协处理器"></a>第三步：开发HBase的协处理器</h3><p>开发HBase的协处理器Copo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.hbase.*;</span><br><span class="line">import org.apache.hadoop.hbase.client.*;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.ObserverContext;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;</span><br><span class="line">import org.apache.hadoop.hbase.coprocessor.RegionObserver;</span><br><span class="line">import org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line">import org.apache.hadoop.hbase.wal.WALEdit;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">public class MyProcessor implements RegionObserver,RegionCoprocessor &#123;</span><br><span class="line"></span><br><span class="line">    static Connection connection = null;</span><br><span class="line">    static Table table = null;</span><br><span class="line">    //使用静态代码块来创建连接对象，避免频繁的创建连接对象</span><br><span class="line">    static&#123;</span><br><span class="line">        Configuration conf = HBaseConfiguration.create();</span><br><span class="line">        conf.set(&quot;hbase.zookeeper.quorum&quot;,&quot;node01:2181&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">            table = connection.getTable(TableName.valueOf(&quot;proc2&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private RegionCoprocessorEnvironment env = null;</span><br><span class="line">    //定义列族名</span><br><span class="line">    private static final String FAMAILLY_NAME = &quot;info&quot;;</span><br><span class="line">    //定义列名</span><br><span class="line">    private static final String QUALIFIER_NAME = &quot;name&quot;;</span><br><span class="line">    //2.0加入该方法，否则无法生效</span><br><span class="line">    @Override</span><br><span class="line">    public Optional&lt;RegionObserver&gt; getRegionObserver() &#123;</span><br><span class="line">        // Extremely important to be sure that the coprocessor is invoked as a RegionObserver</span><br><span class="line">        return Optional.of(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化协处理器环境</span><br><span class="line">     * @param e</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void start(CoprocessorEnvironment e) throws IOException &#123;</span><br><span class="line">        env = (RegionCoprocessorEnvironment) e;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void stop(CoprocessorEnvironment e) throws IOException &#123;</span><br><span class="line">        // nothing to do here</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 覆写prePut方法，在我们数据插入之前进行拦截，</span><br><span class="line">     * @param e</span><br><span class="line">     * @param put  put对象里面封装了我们需要插入到目标表的数据</span><br><span class="line">     * @param edit</span><br><span class="line">     * @param durability</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void prePut(final ObserverContext&lt;RegionCoprocessorEnvironment&gt; e,</span><br><span class="line">                       final Put put, final WALEdit edit, final Durability durability)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //通过put对象获取插入数据的rowkey</span><br><span class="line">            byte[] rowBytes = put.getRow();</span><br><span class="line">            String rowkey = Bytes.toString(rowBytes);</span><br><span class="line">            //获取我们插入数据的name字段的值</span><br><span class="line"></span><br><span class="line">            List&lt;Cell&gt; list = put.get(Bytes.toBytes(FAMAILLY_NAME), Bytes.toBytes(QUALIFIER_NAME));</span><br><span class="line">            //判断如果没有获取到info列族，和name列，直接返回即可</span><br><span class="line">            if (list == null || list.size() == 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取到info列族，name列对应的cell</span><br><span class="line">            Cell cell2 = list.get(0);</span><br><span class="line"></span><br><span class="line">            //通过cell获取数据值</span><br><span class="line">            String nameValue = Bytes.toString(CellUtil.cloneValue(cell2));</span><br><span class="line">            //创建put对象，将数据插入到proc2表里面去</span><br><span class="line">            Put put2 = new Put(rowkey.getBytes());</span><br><span class="line">            put2.addColumn(Bytes.toBytes(FAMAILLY_NAME), Bytes.toBytes(QUALIFIER_NAME),  nameValue.getBytes());</span><br><span class="line">            table.put(put2);</span><br><span class="line">            table.close();</span><br><span class="line">        &#125; catch (Exception e1) &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四步：将项目打成jar包，并上传到HDFS上面"><a href="#第四步：将项目打成jar包，并上传到HDFS上面" class="headerlink" title="第四步：将项目打成jar包，并上传到HDFS上面"></a>第四步：将项目打成jar包，并上传到HDFS上面</h3><p>将我们的协处理器打成一个jar包，此处不需要用任何的打包插件即可，然后上传到hdfs</p>
<p>将打好的jar包上传到linux的/export/servers路径下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers</span><br><span class="line">mv original-hbase-1.0-SNAPSHOT.jar  processor.jar</span><br><span class="line">hdfs dfs -mkdir -p /processor</span><br><span class="line">hdfs dfs -put processor.jar /processor</span><br></pre></td></tr></table></figure>

<h3 id="第五步：将打好的jar包挂载到proc1表当中去"><a href="#第五步：将打好的jar包挂载到proc1表当中去" class="headerlink" title="第五步：将打好的jar包挂载到proc1表当中去"></a>第五步：将打好的jar包挂载到proc1表当中去</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):056:0&gt; describe &apos;proc1&apos;</span><br><span class="line">hbase(main):055:0&gt; alter &apos;proc1&apos;,METHOD =&gt; &apos;table_att&apos;,&apos;Coprocessor&apos;=&gt;&apos;hdfs://node01:8020/processor/processor.jar|cn.itcast.hbasemr.demo4.MyProcessor|1001|&apos;</span><br></pre></td></tr></table></figure>

<p>再次查看’proc1’表，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):043:0&gt; describe &apos;proc1&apos;</span><br></pre></td></tr></table></figure>

<p>可以查看到我们的卸载器已经加载了</p>
<h3 id="第六步：proc1表当中添加数据"><a href="#第六步：proc1表当中添加数据" class="headerlink" title="第六步：proc1表当中添加数据"></a>第六步：proc1表当中添加数据</h3><p>进入hbase-shell客户端，然后直接执行以下命令向proc1表当中添加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put &apos;proc1&apos;,&apos;0001&apos;,&apos;info:name&apos;,&apos;zhangsan&apos;</span><br><span class="line">put &apos;proc1&apos;,&apos;0001&apos;,&apos;info:age&apos;,&apos;28&apos;</span><br><span class="line">put &apos;proc1&apos;,&apos;0002&apos;,&apos;info:name&apos;,&apos;lisi&apos;</span><br><span class="line">put &apos;proc1&apos;,&apos;0002&apos;,&apos;info:age&apos;,&apos;25&apos;</span><br></pre></td></tr></table></figure>

<p>向proc1表当中添加数据，然后通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan  &apos;proc2&apos;</span><br></pre></td></tr></table></figure>

<p>我们会发现，proc2表当中也插入了数据，并且只有info列族，name列</p>
<p> 注意：如果需要卸载我们的协处理器，那么进入hbase的shell命令行，执行以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disable &apos;proc1&apos;</span><br><span class="line">alter &apos;proc1&apos;,METHOD=&gt;&apos;table_att_unset&apos;,NAME=&gt;&apos;coprocessor$1&apos;</span><br><span class="line">enable &apos;proc1&apos;</span><br></pre></td></tr></table></figure>

<h2 id="七-HBase当中的二级索引的基本介绍"><a href="#七-HBase当中的二级索引的基本介绍" class="headerlink" title="七 HBase当中的二级索引的基本介绍"></a>七 HBase当中的二级索引的基本介绍</h2><p>由于HBase的查询比较弱，如果需要实现类似于 select name,salary,count(1),max(salary) from user group by name,salary order by salary 等这样的复杂性的统计需求，基本上不可能，或者说比较困难，所以我们在使用HBase的时候，一般都会借助二级索引的方案来进行实现</p>
<p>HBase的一级索引就是rowkey，我们只能通过rowkey进行检索。如果我们相对hbase里面列族的列列进行一些组合查询，就需要采用HBase的二级索引方案来进行多条件的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\1. MapReduce方案 </span><br><span class="line">\2. ITHBASE（Indexed-Transanctional HBase）方案 </span><br><span class="line">\3. IHBASE（Index HBase）方案 </span><br><span class="line">\4. Hbase Coprocessor(协处理器)方案 </span><br><span class="line">\5. Solr+hbase方案</span><br><span class="line">\6. CCIndex（complementalclustering index）方案</span><br><span class="line">还有 MySQL 等数据库</span><br><span class="line">常见的二级索引我们一般可以借助各种其他的方式来实现，例如Phoenix或者solr或者ES等</span><br></pre></td></tr></table></figure>

<h2 id="八-HBase调优"><a href="#八-HBase调优" class="headerlink" title="八 HBase调优"></a>八 HBase调优</h2><h2 id="1、通用优化"><a href="#1、通用优化" class="headerlink" title="1、通用优化"></a>1、通用优化</h2><h3 id="1、NameNode的元数据备份使用SSD"><a href="#1、NameNode的元数据备份使用SSD" class="headerlink" title="1、NameNode的元数据备份使用SSD"></a>1、NameNode的元数据备份使用SSD</h3><h3 id="2、定时备份NameNode上的元数据，每小时或者每天备份，如果数据极其重要，可以5-10分钟备份一次。备份可以通过定时任务复制元数据目录即可。"><a href="#2、定时备份NameNode上的元数据，每小时或者每天备份，如果数据极其重要，可以5-10分钟备份一次。备份可以通过定时任务复制元数据目录即可。" class="headerlink" title="2、定时备份NameNode上的元数据，每小时或者每天备份，如果数据极其重要，可以5~10分钟备份一次。备份可以通过定时任务复制元数据目录即可。"></a>2、定时备份NameNode上的元数据，每小时或者每天备份，如果数据极其重要，可以5~10分钟备份一次。备份可以通过定时任务复制元数据目录即可。</h3><h3 id="3、为NameNode指定多个元数据目录，使用dfs-name-dir或者dfs-namenode-name-dir指定。一个指定本地磁盘，一个指定网络磁盘。这样可以提供元数据的冗余和健壮性，以免发生故障。"><a href="#3、为NameNode指定多个元数据目录，使用dfs-name-dir或者dfs-namenode-name-dir指定。一个指定本地磁盘，一个指定网络磁盘。这样可以提供元数据的冗余和健壮性，以免发生故障。" class="headerlink" title="3、为NameNode指定多个元数据目录，使用dfs.name.dir或者dfs.namenode.name.dir指定。一个指定本地磁盘，一个指定网络磁盘。这样可以提供元数据的冗余和健壮性，以免发生故障。"></a>3、为NameNode指定多个元数据目录，使用dfs.name.dir或者dfs.namenode.name.dir指定。一个指定本地磁盘，一个指定网络磁盘。这样可以提供元数据的冗余和健壮性，以免发生故障。</h3><h3 id="4、设置dfs-namenode-name-dir-restore为true，允许尝试恢复之前失败的dfs-namenode-name-dir目录，在创建checkpoint时做此尝试，如果设置了多个磁盘，建议允许。"><a href="#4、设置dfs-namenode-name-dir-restore为true，允许尝试恢复之前失败的dfs-namenode-name-dir目录，在创建checkpoint时做此尝试，如果设置了多个磁盘，建议允许。" class="headerlink" title="4、设置dfs.namenode.name.dir.restore为true，允许尝试恢复之前失败的dfs.namenode.name.dir目录，在创建checkpoint时做此尝试，如果设置了多个磁盘，建议允许。"></a>4、设置dfs.namenode.name.dir.restore为true，允许尝试恢复之前失败的dfs.namenode.name.dir目录，在创建checkpoint时做此尝试，如果设置了多个磁盘，建议允许。</h3><h3 id="5、NameNode节点必须配置为RAID1（镜像盘）结构。"><a href="#5、NameNode节点必须配置为RAID1（镜像盘）结构。" class="headerlink" title="5、NameNode节点必须配置为RAID1（镜像盘）结构。"></a>5、NameNode节点必须配置为RAID1（镜像盘）结构。</h3><h3 id="6、补充：什么是Raid0、Raid0-1、Raid1、Raid5"><a href="#6、补充：什么是Raid0、Raid0-1、Raid1、Raid5" class="headerlink" title="6、补充：什么是Raid0、Raid0+1、Raid1、Raid5"></a>6、补充：什么是Raid0、Raid0+1、Raid1、Raid5</h3><p><a href="https://manzhong.github.io/images/Hbase/r.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Hbase/r.jpg" alt="img"></a></p>
<p><strong>Standalone</strong></p>
<p>最普遍的单磁盘储存方式。</p>
<p><strong>Cluster</strong></p>
<p>集群储存是通过将数据分布到集群中各节点的存储方式,提供单一的使用接口与界面,使用户可以方便地对所有数据进行统一使用与管理。</p>
<p><strong>Hot swap</strong></p>
<p>用户可以再不关闭系统,不切断电源的情况下取出和更换硬盘,提高系统的恢复能力、拓展性和灵活性。</p>
<p><strong>Raid0</strong></p>
<p>Raid0是所有raid中存储性能最强的阵列形式。其工作原理就是在多个磁盘上分散存取连续的数据,这样,当需要存取数据是多个磁盘可以并排执行,每个磁盘执行属于它自己的那部分数据请求,显著提高磁盘整体存取性能。但是不具备容错能力,适用于低成本、低可靠性的台式系统。</p>
<p><strong>Raid1</strong></p>
<p>又称镜像盘,把一个磁盘的数据镜像到另一个磁盘上,采用镜像容错来提高可靠性,具有raid中最高的数据冗余能力。存数据时会将数据同时写入镜像盘内,读取数据则只从工作盘读出。发生故障时,系统将从镜像盘读取数据,然后再恢复工作盘正确数据。这种阵列方式可靠性极高,但是其容量会减去一半。广泛用于数据要求极严的应用场合,如商业金融、档案管理等领域。只允许一颗硬盘出故障。</p>
<p><strong>Raid0+1</strong></p>
<p>将Raid0和Raid1技术结合在一起,兼顾两者的优势。在数据得到保障的同时,还能提供较强的存储性能。不过至少要求4个或以上的硬盘，但也只允许一个磁盘出错。是一种三高技术。</p>
<p><strong>Raid5</strong></p>
<p>Raid5可以看成是Raid0+1的低成本方案。采用循环偶校验独立存取的阵列方式。将数据和相对应的奇偶校验信息分布存储到组成RAID5的各个磁盘上。当其中一个磁盘数据发生损坏后,利用剩下的磁盘和相应的奇偶校验信息 重新恢复/生成丢失的数据而不影响数据的可用性。至少需要3个或以上的硬盘。适用于大数据量的操作。成本稍高、储存性强、可靠性强的阵列方式。</p>
<p>RAID还有其他方式，请自行查阅。</p>
<h3 id="7、保持NameNode日志目录有足够的空间，这些日志有助于帮助你发现问题。"><a href="#7、保持NameNode日志目录有足够的空间，这些日志有助于帮助你发现问题。" class="headerlink" title="7、保持NameNode日志目录有足够的空间，这些日志有助于帮助你发现问题。"></a>7、保持NameNode日志目录有足够的空间，这些日志有助于帮助你发现问题。</h3><h3 id="8、因为Hadoop是IO密集型框架，所以尽量提升存储的速度和吞吐量（类似位宽）。"><a href="#8、因为Hadoop是IO密集型框架，所以尽量提升存储的速度和吞吐量（类似位宽）。" class="headerlink" title="8、因为Hadoop是IO密集型框架，所以尽量提升存储的速度和吞吐量（类似位宽）。"></a>8、因为Hadoop是IO密集型框架，所以尽量提升存储的速度和吞吐量（类似位宽）。</h3><h2 id="2-、Linux优化"><a href="#2-、Linux优化" class="headerlink" title="2 、Linux优化"></a>2 、Linux优化</h2><h3 id="1、开启文件系统的预读缓存可以提高读取速度"><a href="#1、开启文件系统的预读缓存可以提高读取速度" class="headerlink" title="1、开启文件系统的预读缓存可以提高读取速度"></a>1、开启文件系统的预读缓存可以提高读取速度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo blockdev --setra 32768 /dev/sda</span><br><span class="line"></span><br><span class="line">（注意：ra是readahead的缩写）</span><br></pre></td></tr></table></figure>

<h3 id="2、关闭进程睡眠池"><a href="#2、关闭进程睡眠池" class="headerlink" title="2、关闭进程睡眠池"></a>2、关闭进程睡眠池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w vm.swappiness=0</span><br></pre></td></tr></table></figure>

<h3 id="3、调整ulimit上限，默认值为比较小的数字"><a href="#3、调整ulimit上限，默认值为比较小的数字" class="headerlink" title="3、调整ulimit上限，默认值为比较小的数字"></a>3、调整ulimit上限，默认值为比较小的数字</h3><p>$ ulimit -n 查看允许最大进程数</p>
<p>$ ulimit -u 查看允许打开最大文件数</p>
<p>修改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/security/limits.conf 修改打开文件数限制</span><br><span class="line">末尾添加：</span><br><span class="line">*                soft    nofile          1024000</span><br><span class="line">*                hard    nofile          1024000</span><br><span class="line">Hive             -       nofile          1024000</span><br><span class="line">hive             -       nproc           1024000 </span><br><span class="line">$ sudo vi /etc/security/limits.d/20-nproc.conf 修改用户打开进程数限制</span><br><span class="line">修改为：</span><br><span class="line">#*          soft    nproc     4096</span><br><span class="line">#root       soft    nproc     unlimited</span><br><span class="line">*          soft    nproc     40960</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>

<h3 id="4、开启集群的时间同步NTP，请参看之前文档"><a href="#4、开启集群的时间同步NTP，请参看之前文档" class="headerlink" title="4、开启集群的时间同步NTP，请参看之前文档"></a>4、开启集群的时间同步NTP，请参看之前文档</h3><h3 id="5、更新系统补丁（注意：更新补丁前，请先测试新版本补丁对集群节点的兼容性）"><a href="#5、更新系统补丁（注意：更新补丁前，请先测试新版本补丁对集群节点的兼容性）" class="headerlink" title="5、更新系统补丁（注意：更新补丁前，请先测试新版本补丁对集群节点的兼容性）"></a>5、更新系统补丁（注意：更新补丁前，请先测试新版本补丁对集群节点的兼容性）</h3><h2 id="3、HDFS优化（hdfs-site-xml）"><a href="#3、HDFS优化（hdfs-site-xml）" class="headerlink" title="3、HDFS优化（hdfs-site.xml）"></a>3、HDFS优化（hdfs-site.xml）</h2><h3 id="1、保证RPC调用会有较多的线程数"><a href="#1、保证RPC调用会有较多的线程数" class="headerlink" title="1、保证RPC调用会有较多的线程数"></a>1、保证RPC调用会有较多的线程数</h3><p>属性：dfs.namenode.handler.count</p>
<p>解释：该属性是NameNode服务默认线程数，的默认值是10，根据机器的可用内存可以调整为50~100</p>
<p>属性：dfs.datanode.handler.count</p>
<p>解释：该属性默认值为10，是DataNode的处理线程数，如果HDFS客户端程序读写请求比较多，可以调高到15<del>20，设置的值越大，内存消耗越多，不要调整的过高，一般业务中，5</del>10即可。</p>
<h3 id="2、副本数的调整"><a href="#2、副本数的调整" class="headerlink" title="2、副本数的调整"></a>2、副本数的调整</h3><p>属性：dfs.replication</p>
<p>解释：如果数据量巨大，且不是非常之重要，可以调整为2<del>3，如果数据非常之重要，可以调整为3</del>5。</p>
<h3 id="3-、文件块大小的调整"><a href="#3-、文件块大小的调整" class="headerlink" title="3.、文件块大小的调整"></a>3.、文件块大小的调整</h3><p>属性：dfs.blocksize</p>
<p>解释：块大小定义，该属性应该根据存储的大量的单个文件大小来设置，如果大量的单个文件都小于100M，建议设置成64M块大小，对于大于100M或者达到GB的这种情况，建议设置成256M，一般设置范围波动在64M~256M之间。</p>
<h2 id="4、MapReduce优化（mapred-site-xml）"><a href="#4、MapReduce优化（mapred-site-xml）" class="headerlink" title="4、MapReduce优化（mapred-site.xml）"></a>4、MapReduce优化（mapred-site.xml）</h2><h3 id="1、Job任务服务线程数调整"><a href="#1、Job任务服务线程数调整" class="headerlink" title="1、Job任务服务线程数调整"></a>1、Job任务服务线程数调整</h3><p>mapreduce.jobtracker.handler.count</p>
<p>该属性是Job任务线程数，默认值是10，根据机器的可用内存可以调整为50~100</p>
<h3 id="2、Http服务器工作线程数"><a href="#2、Http服务器工作线程数" class="headerlink" title="2、Http服务器工作线程数"></a>2、Http服务器工作线程数</h3><p>属性：mapreduce.tasktracker.http.threads</p>
<p>解释：定义HTTP服务器工作线程数，默认值为40，对于大集群可以调整到80~100</p>
<h3 id="3、文件排序合并优化"><a href="#3、文件排序合并优化" class="headerlink" title="3、文件排序合并优化"></a>3、文件排序合并优化</h3><p>属性：mapreduce.task.io.sort.factor</p>
<p>解释：文件排序时同时合并的数据流的数量，这也定义了同时打开文件的个数，默认值为10，如果调高该参数，可以明显减少磁盘IO，即减少文件读取的次数。</p>
<h3 id="4、设置任务并发"><a href="#4、设置任务并发" class="headerlink" title="4、设置任务并发"></a>4、设置任务并发</h3><p>属性：mapreduce.map.speculative</p>
<p>解释：该属性可以设置任务是否可以并发执行，如果任务多而小，该属性设置为true可以明显加快任务执行效率，但是对于延迟非常高的任务，建议改为false，这就类似于迅雷下载。</p>
<h3 id="5、MR输出数据的压缩"><a href="#5、MR输出数据的压缩" class="headerlink" title="5、MR输出数据的压缩"></a>5、MR输出数据的压缩</h3><p>属性：mapreduce.map.output.compress、mapreduce.output.fileoutputformat.compress</p>
<p>解释：对于大集群而言，建议设置Map-Reduce的输出为压缩的数据，而对于小集群，则不需要。</p>
<h3 id="6、优化Mapper和Reducer的个数"><a href="#6、优化Mapper和Reducer的个数" class="headerlink" title="6、优化Mapper和Reducer的个数"></a>6、优化Mapper和Reducer的个数</h3><p>属性：</p>
<p>mapreduce.tasktracker.map.tasks.maximum</p>
<p>mapreduce.tasktracker.reduce.tasks.maximum</p>
<p>解释：以上两个属性分别为一个单独的Job任务可以同时运行的Map和Reduce的数量。</p>
<p>设置上面两个参数时，需要考虑CPU核数、磁盘和内存容量。假设一个8核的CPU，业务内容非常消耗CPU，那么可以设置map数量为4，如果该业务不是特别消耗CPU类型的，那么可以设置map数量为40，reduce数量为20。这些参数的值修改完成之后，一定要观察是否有较长等待的任务，如果有的话，可以减少数量以加快任务执行，如果设置一个很大的值，会引起大量的上下文切换，以及内存与磁盘之间的数据交换，这里没有标准的配置数值，需要根据业务和硬件配置以及经验来做出选择。</p>
<p>在同一时刻，不要同时运行太多的MapReduce，这样会消耗过多的内存，任务会执行的非常缓慢，我们需要根据CPU核数，内存容量设置一个MR任务并发的最大值，使固定数据量的任务完全加载到内存中，避免频繁的内存和磁盘数据交换，从而降低磁盘IO，提高性能。</p>
<p>大概配比：</p>
<table>
<thead>
<tr>
<th align="left">CPU CORE</th>
<th align="left">MEM（GB）</th>
<th align="left">Map</th>
<th align="left">Reduce</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">5</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">5</td>
<td align="left">1~4</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">32</td>
<td align="left">16</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">64</td>
<td align="left">16</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">64</td>
<td align="left">24</td>
<td align="left">12</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">128</td>
<td align="left">24</td>
<td align="left">12</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大概估算公式：</span><br><span class="line">map = 2 + ⅔cpu_core</span><br><span class="line">reduce = 2 + ⅓cpu_core</span><br></pre></td></tr></table></figure>

<h2 id="5、HBase优化"><a href="#5、HBase优化" class="headerlink" title="5、HBase优化"></a>5、HBase优化</h2><h3 id="1、在HDFS的文件中追加内容"><a href="#1、在HDFS的文件中追加内容" class="headerlink" title="1、在HDFS的文件中追加内容"></a>1、在HDFS的文件中追加内容</h3><p>不是不允许追加内容么？没错，请看背景故事：</p>
<p>属性：dfs.support.append</p>
<p>文件：hdfs-site.xml、hbase-site.xml</p>
<p>解释：开启HDFS追加同步，可以优秀的配合HBase的数据同步和持久化。默认值为true。</p>
<h3 id="2、优化DataNode允许的最大文件打开数"><a href="#2、优化DataNode允许的最大文件打开数" class="headerlink" title="2、优化DataNode允许的最大文件打开数"></a>2、优化DataNode允许的最大文件打开数</h3><p>属性：dfs.datanode.max.transfer.threads</p>
<p>文件：hdfs-site.xml</p>
<p>解释：HBase一般都会同一时间操作大量的文件，根据集群的数量和规模以及数据动作，设置为4096或者更高。默认值：4096</p>
<h3 id="3、优化延迟高的数据操作的等待时间"><a href="#3、优化延迟高的数据操作的等待时间" class="headerlink" title="3、优化延迟高的数据操作的等待时间"></a>3、优化延迟高的数据操作的等待时间</h3><p>属性：dfs.image.transfer.timeout</p>
<p>文件：hdfs-site.xml</p>
<p>解释：如果对于某一次数据操作来讲，延迟非常高，socket需要等待更长的时间，建议把该值设置为更大的值（默认60000毫秒），以确保socket不会被timeout掉。</p>
<h3 id="4、优化数据的写入效率"><a href="#4、优化数据的写入效率" class="headerlink" title="4、优化数据的写入效率"></a>4、优化数据的写入效率</h3><p>属性：</p>
<p>mapreduce.map.output.compress</p>
<p>mapreduce.map.output.compress.codec</p>
<p>文件：mapred-site.xml</p>
<p>解释：开启这两个数据可以大大提高文件的写入效率，减少写入时间。第一个属性值修改为true，第二个属性值修改为：org.apache.hadoop.io.compress.GzipCodec</p>
<h3 id="5、优化DataNode存储"><a href="#5、优化DataNode存储" class="headerlink" title="5、优化DataNode存储"></a>5、优化DataNode存储</h3><p>属性：dfs.datanode.failed.volumes.tolerated</p>
<p>文件：hdfs-site.xml</p>
<p>解释：默认为0，意思是当DataNode中有一个磁盘出现故障，则会认为该DataNode shutdown了。如果修改为1，则一个磁盘出现故障时，数据会被复制到其他正常的DataNode上，当前的DataNode继续工作。</p>
<h3 id="6、设置RPC监听数量"><a href="#6、设置RPC监听数量" class="headerlink" title="6、设置RPC监听数量"></a>6、设置RPC监听数量</h3><p>属性：hbase.regionserver.handler.count</p>
<p>文件：hbase-site.xml</p>
<p>解释：默认值为30，用于指定RPC监听的数量，可以根据客户端的请求数进行调整，读写请求较多时，增加此值。</p>
<h3 id="7、优化HStore文件大小"><a href="#7、优化HStore文件大小" class="headerlink" title="7、优化HStore文件大小"></a>7、优化HStore文件大小</h3><p>属性：hbase.hregion.max.filesize</p>
<p>文件：hbase-site.xml</p>
<p>解释：默认值10737418240（10GB），如果需要运行HBase的MR任务，可以减小此值，因为一个region对应一个map任务，如果单个region过大，会导致map任务执行时间过长。该值的意思就是，如果HFile的大小达到这个数值，则这个region会被切分为两个Hfile。</p>
<h3 id="8、优化hbase客户端缓存"><a href="#8、优化hbase客户端缓存" class="headerlink" title="8、优化hbase客户端缓存"></a>8、优化hbase客户端缓存</h3><p>属性：hbase.client.write.buffer</p>
<p>文件：hbase-site.xml</p>
<p>解释：用于指定HBase客户端缓存，增大该值可以减少RPC调用次数，但是会消耗更多内存，反之则反之。一般我们需要设定一定的缓存大小，以达到减少RPC次数的目的。</p>
<h3 id="9、指定scan-next扫描HBase所获取的行数"><a href="#9、指定scan-next扫描HBase所获取的行数" class="headerlink" title="9、指定scan.next扫描HBase所获取的行数"></a>9、指定scan.next扫描HBase所获取的行数</h3><p>属性：hbase.client.scanner.caching</p>
<p>文件：hbase-site.xml</p>
<p>解释：用于指定scan.next方法获取的默认行数，值越大，消耗内存越大。</p>
<h2 id="6、内存优化"><a href="#6、内存优化" class="headerlink" title="6、内存优化"></a>6、内存优化</h2><p>HBase操作过程中需要大量的内存开销，毕竟Table是可以缓存在内存中的，一般会分配整个可用内存的70%给HBase的Java堆。但是不建议分配非常大的堆内存，因为GC过程持续太久会导致RegionServer处于长期不可用状态，一般16~48G内存就可以了，如果因为框架占用内存过高导致系统内存不足，框架一样会被系统服务拖死。</p>
<h2 id="7、JVM优化"><a href="#7、JVM优化" class="headerlink" title="7、JVM优化"></a>7、JVM优化</h2><p>涉及文件：hbase-env.sh</p>
<h3 id="1、并行GC"><a href="#1、并行GC" class="headerlink" title="1、并行GC"></a>1、并行GC</h3><p>参数：-XX:+UseParallelGC</p>
<p>解释：开启并行GC</p>
<h3 id="2、同时处理垃圾回收的线程数"><a href="#2、同时处理垃圾回收的线程数" class="headerlink" title="2、同时处理垃圾回收的线程数"></a>2、同时处理垃圾回收的线程数</h3><p>参数：-XX:ParallelGCThreads=cpu_core – 1</p>
<p>解释：该属性设置了同时处理垃圾回收的线程数。</p>
<h3 id="3、禁用手动GC"><a href="#3、禁用手动GC" class="headerlink" title="3、禁用手动GC"></a>3、禁用手动GC</h3><p>参数：-XX:DisableExplicitGC</p>
<p>解释：防止开发人员手动调用GC</p>
<h2 id="8、Zookeeper优化"><a href="#8、Zookeeper优化" class="headerlink" title="8、Zookeeper优化"></a>8、Zookeeper优化</h2><h3 id="1、优化Zookeeper会话超时时间"><a href="#1、优化Zookeeper会话超时时间" class="headerlink" title="1、优化Zookeeper会话超时时间"></a>1、优化Zookeeper会话超时时间</h3><p>参数：zookeeper.session.timeout</p>
<p>文件：hbase-site.xml</p>
<p>解释：In hbase-site.xml, set zookeeper.session.timeout to 30 seconds or less to bound failure detection (20-30 seconds is a good start).该值会直接关系到master发现服务器宕机的最大周期，默认值为30秒，如果该值过小，会在HBase在写入大量数据发生而GC时，导致RegionServer短暂的不可用，从而没有向ZK发送心跳包，最终导致认为从节点shutdown。一般20台左右的集群需要配置5台zookeeper。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Hbase增强/" data-id="cjz25rjc3000ud8u57hby9byr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Storm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Storm/" class="article-date">
  <time datetime="2019-08-08T03:56:33.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Storm/">Storm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Strom"><a href="#Strom" class="headerlink" title="Strom"></a>Strom</h1><h2 id="一概述"><a href="#一概述" class="headerlink" title="一概述"></a>一概述</h2><p>Apache Strom 流式计算框架</p>
<p>Hadoop处理数据时效性不够,Strom能够尽快得到处理后的数据</p>
<p>Strom只负责数据计算,不负责数据存储</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Storm/" data-id="cjz25rjal0003d8u5vrztjlbd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Scala入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Scala入门/" class="article-date">
  <time datetime="2019-08-08T03:56:19.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Scala入门/">Scala入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Scala入门"><a href="#Scala入门" class="headerlink" title="Scala入门"></a>Scala入门</h1><h2 id="一-什么是Scala"><a href="#一-什么是Scala" class="headerlink" title="一 什么是Scala"></a>一 什么是Scala</h2><p> scala是运行在 JVM 上的多范式编程语言，同时支持面向对象和面向函数编程 (如java是面向对象的也是面向接口的,懂得自然懂)</p>
<p>早期，scala刚出现的时候，并没有怎么引起重视，随着Spark和Kafka这样基于scala的大数据框架<br>的兴起，scala逐步进入大数据开发者的眼帘。scala的主要优势是它的表达性。</p>
<h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1 使用场景:"></a>1 使用场景:</h3><p>开发大数据应用程序（Spark程序、Flink程序）<br>表达能力强，一行代码抵得上Java多行，开发速度快<br>兼容Java，可以访问庞大的Java类库，例如：操作mysql、redis、freemarker、activemq等等</p>
<h3 id="2-scala与java的简单对比"><a href="#2-scala与java的简单对比" class="headerlink" title="2 scala与java的简单对比"></a>2 scala与java的简单对比</h3><p>scala定义三个实体类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case class User(var name:String,var orders:List[Order])   //用户实体类</span><br><span class="line">case class Order(var id:Int,var products:List[Product])   //订单实体类</span><br><span class="line">case class Product(var id:Int,var category:String)          //商品实体类</span><br></pre></td></tr></table></figure>

<p>讲一个列表中的字符串(数字类型) 转为数字列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ints = list.map(s =&gt; s.toInt)</span><br></pre></td></tr></table></figure>

<h2 id="二-开发环境搭建"><a href="#二-开发环境搭建" class="headerlink" title="二 开发环境搭建"></a>二 开发环境搭建</h2><h3 id="1-java与scala的编译流程"><a href="#1-java与scala的编译流程" class="headerlink" title="1 java与scala的编译流程"></a>1 java与scala的编译流程</h3><p>java</p>
<p>java源代码&gt; (javac编译)&gt;java字节码和java类库&gt;(加载)&gt;jvm&gt;(解释执行)&gt;操作系统</p>
<p>scala:</p>
<p>scala源代码&gt;(scalac编译)&gt;java字节码和java类库和scala类库&gt;(加载)&gt;jvm&gt;(解释执行)&gt;操作系统</p>
<p>scala程序运行需要依赖于Java类库，必须要有Java运行环境，scala才能正确执行.scala源文件也是编译为class文件</p>
<p>根据上述流程图，要编译运行scala程序，需要<br>jdk（jvm）<br>scala编译器（scala SDK）</p>
<h3 id="2jdk安装"><a href="#2jdk安装" class="headerlink" title="2jdk安装"></a>2jdk安装</h3><p>略</p>
<h3 id="3安装SDK"><a href="#3安装SDK" class="headerlink" title="3安装SDK"></a>3安装SDK</h3><p>下载安装即可.</p>
<p>idea安装scala插件</p>
<h2 id="三scala的解释器"><a href="#三scala的解释器" class="headerlink" title="三scala的解释器"></a>三scala的解释器</h2><p>后续我们会使用scala解释器来学习scala基本语法，scala解释器像Linux命令一样，执行一条代<br>码，马上就可以让我们看到执行结果，用来测试比较方便。</p>
<p>启动:</p>
<p>win+r 后输入scala</p>
<p>退出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:quit</span><br></pre></td></tr></table></figure>

<h2 id="四-语法"><a href="#四-语法" class="headerlink" title="四 语法"></a>四 语法</h2><h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1 定义变量"></a>1 定义变量</h3><p>格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/val 变量标识:变量类型 = 初始值</span><br></pre></td></tr></table></figure>

<p>val 定义的是不可重新赋值的变量<br>var 定义的是可重新赋值的变量</p>
<p>注意: 句尾不用写分号.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重心赋值:</span><br><span class="line">name = &quot;ni&quot;   若为val 则会报错  var 不会报错</span><br></pre></td></tr></table></figure>

<p><strong>使用类型推断来定义变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;nicai&quot;</span><br></pre></td></tr></table></figure>

<p>scala可以自动根据变量的值来自动推断变量的类型，这样编写代码更加简洁。</p>
<p><strong>惰性赋值</strong></p>
<p>在企业的大数据开发中，有时候会编写非常复杂的SQL语句，这些SQL语句可能有几百行甚至上千<br>行。这些SQL语句，如果直接加载到JVM中，会有很大的内存开销。如何解决？</p>
<p>当有一些变量保存的数据较大时，但是不需要马上加载到JVM内存。可以使用惰性赋值来提高效<br>率。<br>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lazy var/val 变量标书:变量类型 = 值</span><br><span class="line">或者</span><br><span class="line">lazy var/val 变量标识 = 值</span><br></pre></td></tr></table></figure>

<p>示例<br>在程序中需要执行一条以下复杂的SQL语句，我们希望只有用到这个SQL语句才加载它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;insert overwrite table adm.itcast_adm_personas</span><br><span class="line">select</span><br><span class="line">a.user_id,</span><br><span class="line">a.user_name,</span><br><span class="line">a.user_sex,</span><br><span class="line">a.user_birthday,</span><br><span class="line">a.user_age,</span><br><span class="line">a.constellation,</span><br><span class="line">a.province,</span><br><span class="line">a.city,</span><br><span class="line">a.city_level,</span><br><span class="line">a.hex_mail,</span><br><span class="line">a.op_mail,</span><br><span class="line">a.hex_phone,</span><br><span class="line">a.fore_phone,</span><br><span class="line">a.figure_model,</span><br><span class="line">a.stature_model,</span><br><span class="line">b.first_order_time,</span><br><span class="line">b.last_order_time,</span><br><span class="line">...</span><br><span class="line">d.month1_hour025_cnt,</span><br><span class="line">d.month1_hour627_cnt,</span><br><span class="line">d.month1_hour829_cnt,</span><br><span class="line">d.month1_hour10212_cnt,</span><br><span class="line">d.month1_hour13214_cnt,</span><br><span class="line">d.month1_hour15217_cnt,</span><br><span class="line">d.month1_hour18219_cnt,</span><br><span class="line">d.month1_hour20221_cnt,</span><br><span class="line">d.month1_hour22223_cnt</span><br><span class="line">from gdm.itcast_gdm_user_basic a</span><br><span class="line">left join gdm.itcast_gdm_user_consume_order b on a.user_id=b.user_id</span><br><span class="line">left join gdm.itcast_gdm_user_buy_category c on a.user_id=c.user_id</span><br><span class="line">left join gdm.itcast_gdm_user_visit d on a.user_id=d.user_id;&quot;&quot;&quot;</span><br><span class="line">参考代码</span><br><span class="line">scala&gt; lazy val sql = &quot;&quot;&quot;insert overwrite table adm.itcast_adm_personas</span><br><span class="line">略</span><br></pre></td></tr></table></figure>

<h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2 字符串"></a>2 字符串</h3><p>多种定义字符串;</p>
<p>使用双引号<br>使用插值表达式<br>使用三引号</p>
<p>1使用双引号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/val name= &quot;值&quot;     name.length  长度</span><br></pre></td></tr></table></figure>

<p>2 使用插值表达式</p>
<p>scala中，可以使用插值表达式来定义字符串，有效避免大量字符串的拼接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name=&quot;n&quot;</span><br><span class="line">var age=123</span><br><span class="line">var sex=&quot;man&quot;</span><br><span class="line">插值拼接:</span><br><span class="line">var info = s&quot;name=$&#123;name&#125;,age=$&#123;age&#125;,sex=$&#123;sex&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>3 使用三引号</p>
<p>如果有大段的文本需要保存，就可以使用三引号来定义字符串。例如：保存一大段的SQL语句。三<br>个引号中间的所有字符串都将作为字符串的值。(包括空行,空格等)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val/var 变量名 = &quot;&quot;&quot;字符串1</span><br><span class="line">字符串2&quot;&quot;&quot;</span><br><span class="line">val sql = &quot;&quot;&quot;select</span><br><span class="line">| *</span><br><span class="line">| from</span><br><span class="line">| t_user</span><br><span class="line">| where</span><br><span class="line">| name = &quot;zhangsan&quot;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">println(sql)</span><br></pre></td></tr></table></figure>

<h2 id="五-数据类型与操作符"><a href="#五-数据类型与操作符" class="headerlink" title="五 数据类型与操作符"></a>五 数据类型与操作符</h2><p>scala中的类型以及操作符绝大多数和Java一样，<br>数据类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">基础类型                                   类型说明</span><br><span class="line">Byte                                       8位带符号整数</span><br><span class="line">Short                                      16位带符号整数</span><br><span class="line">Int                                          32位带符号整数</span><br><span class="line">Long                                      64位带符号整数</span><br><span class="line">Char                                      16位无符号Unicode字符</span><br><span class="line">String                                     Char类型的序列（字符串）</span><br><span class="line">Float                                      32位单精度浮点数</span><br><span class="line">Double                                   64位双精度浮点数</span><br><span class="line">Boolean                                 true或false</span><br></pre></td></tr></table></figure>

<p>与java的区别:</p>
<p>1scala中所有的类型都使用大写字母开头</p>
<p>2 整形使用 Int 而不是Integer</p>
<p>3 scala中定义变量可以不写类型，让scala编译器自动推断</p>
<p><strong>运算符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">类别                                      操作符</span><br><span class="line"></span><br><span class="line">算术运算符                     +、-、*、/</span><br><span class="line"></span><br><span class="line">关系运算符                     &gt;、&lt;、==、!=、&gt;=、&lt;=</span><br><span class="line"></span><br><span class="line">逻辑运算符                     &amp;&amp;、||、!</span><br><span class="line"></span><br><span class="line">位运算符                       &amp;、||、^、&lt;&lt;、&gt;&gt;</span><br><span class="line">与java的异同:</span><br><span class="line"></span><br><span class="line">scala中没有，++、--运算符</span><br><span class="line">== equals 都表示比较值</span><br><span class="line">eq 表示比较地址值是否相等</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a=&quot;aa&quot;</span><br><span class="line">var b=a + &quot;&quot;</span><br><span class="line"></span><br><span class="line">a == b   true</span><br><span class="line">a.equals(b)   true</span><br><span class="line">a.eq(b)        false</span><br></pre></td></tr></table></figure>

<p><strong>scala的类型层次结构</strong></p>
<p><a href="https://manzhong.github.io/images/scala/lxc.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/lxc.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">类型                                       说明</span><br><span class="line"></span><br><span class="line">Any             所有类型的父类，,它有两个子类AnyRef与AnyVal</span><br><span class="line"></span><br><span class="line">AnyVal        所有数值类型的父类</span><br><span class="line"></span><br><span class="line">AnyRef        所有对象类型（引用类型）的父类</span><br><span class="line"></span><br><span class="line">Unit             表示空，Unit是AnyVal的子类，它只有一个的实例()</span><br><span class="line"></span><br><span class="line">它类似于Java中的void，但scala要比Java更加面向对象</span><br><span class="line"></span><br><span class="line">Null             Null是AnyRef的子类，也就是说它是所有引用类型的子类。它的实例是null</span><br><span class="line"></span><br><span class="line">可以将null赋值给任何对象类型</span><br><span class="line"></span><br><span class="line">Nothing</span><br><span class="line"></span><br><span class="line">所有类型的子类</span><br><span class="line">不能直接创建该类型实例，某个方法抛出异常时，返回的就是Nothing类型，因为</span><br><span class="line">Nothing是所有类的子类，那么它可以赋值为任何类型</span><br></pre></td></tr></table></figure>

<p>noting 例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val c = m3(1,0)</span><br><span class="line">&#125;</span><br><span class="line">def m3(x:Int, y:Int):Int = &#123;</span><br><span class="line">  if(y == 0) throw new Exception(&quot;这是一个异常&quot;)</span><br><span class="line">  x / y</span><br><span class="line">&#125;</span><br><span class="line">val b:Int = null   会报错   null不属于Int的子类</span><br></pre></td></tr></table></figure>

<h2 id="六-条件-循环表达式"><a href="#六-条件-循环表达式" class="headerlink" title="六 条件,循环表达式"></a>六 条件,循环表达式</h2><h3 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1 if语句"></a>1 if语句</h3><p>语法与java一样</p>
<p>不一样的是:</p>
<p>在scala中，<strong>条件表达式也是有返回值的</strong><br>在scala中，<strong>没有三元表达式，</strong>可以使用if表达式替代三元表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val sex = &quot;male&quot;</span><br><span class="line">val result = if(sex == &quot;male&quot;) 1 else 0</span><br></pre></td></tr></table></figure>

<h3 id="2-块表达式"><a href="#2-块表达式" class="headerlink" title="2 块表达式"></a>2 块表达式</h3><p>scala中，使用{}表示一个块表达式<br>和if表达式一样，块表达式也是有值的<br><strong>值就是最后一个表达式的值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;</span><br><span class="line">println(&quot;55&quot;)</span><br><span class="line">1+1</span><br><span class="line">&#125; </span><br><span class="line">输出结果微博2</span><br></pre></td></tr></table></figure>

<h3 id="3-循环"><a href="#3-循环" class="headerlink" title="3 循环"></a>3 循环</h3><p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 表达式/数组/集合) &#123;</span><br><span class="line">// 表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环打印1到10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var nums=1.to(10)</span><br><span class="line">for(i &lt;- nums) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">或者:</span><br><span class="line">for(i &lt;- 1 to 10)println(i)</span><br></pre></td></tr></table></figure>

<p>嵌套循环:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i &lt;- 1 to 10;j &lt;- 1 to 3)&#123;</span><br><span class="line">print(&quot;*&quot;);</span><br><span class="line">if(j==3)&#123;</span><br><span class="line">println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>守卫:</p>
<p>for表达式中，可以添加if判断语句，这个if判断就称之为守卫。我们可以使用守卫让for表达式更简<br>洁。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 表达式/数组/集合 if 表达式) &#123;</span><br><span class="line">// 表达式</span><br><span class="line">&#125;</span><br><span class="line">// 添加守卫，打印能够整除3的数字</span><br><span class="line">for(i &lt;- 1 to 10; if i % 3 == 0) println(i)</span><br></pre></td></tr></table></figure>

<p><strong>for推导式</strong>:</p>
<p><strong>将来可以使用for推导式生成一个新的集合（一组数据）</strong><br>在for循环体中，可以使用yield表达式构建出一个集合，我们把使用yield的for表达式称之为推<br>导式</p>
<p>生成一个10,20…..100的集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// for推导式：for表达式中以yield开始，该for表达式会构建出一个集合</span><br><span class="line">val v = for(i &lt;- 1 to 10) yield i * 10</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure>

<p><strong>while循环</strong></p>
<p>语法与java中一致</p>
<p>打印1到10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var i = 1</span><br><span class="line">i: Int = 1</span><br><span class="line">scala&gt; while(i &lt;= 10) &#123;</span><br><span class="line">| println(i)</span><br><span class="line">| i = i+1</span><br><span class="line">| &#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-方法"><a href="#七-方法" class="headerlink" title="七 方法"></a>七 方法</h2><p>一个类可以有自己的方法，scala中的方法和Java方法类似。但scala与Java定义方法的语法是不一<br>样的，而且scala支持多种调用方式。</p>
<h3 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1 定义方法"></a>1 定义方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def  add(参数名:参数类型,参数名:参数类型): [返回值类型 return type] =&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数列表的参数类型不能省略<br>返回值类型可以省略<br>返回值可以不写return，默认就是{}块表达式的值</p>
<p>定方法:实现两数相加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add(a:Int,b:Int):Int =&#123;</span><br><span class="line">a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用 add(1,2)</span><br></pre></td></tr></table></figure>

<h3 id="2-方法参数"><a href="#2-方法参数" class="headerlink" title="2 方法参数:"></a>2 方法参数:</h3><p>scala中的方法参数，使用比较灵活。它支持以下几种类型的参数：<br>默认参数<br>带名参数<br>变长参数</p>
<p><strong>默认参数</strong></p>
<p>在定义方法时可以给参数定义一个默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def add(a:Int =1,b:Int = 2): Int = a+b</span><br></pre></td></tr></table></figure>

<p><strong>带名参数</strong></p>
<p>在调用方法时，可以指定参数的名称来进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def add(a:Int =1,b:Int = 2): Int = a+b</span><br><span class="line"></span><br><span class="line">调用时:</span><br><span class="line">add(a=2)</span><br></pre></td></tr></table></figure>

<p><strong>变长参数</strong></p>
<p>如果方法的参数是不固定的，可以定义一个方法的参数是变长参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add (num:Int*)=num.sum</span><br><span class="line">add(1,2,3)</span><br></pre></td></tr></table></figure>

<p>在参数类型后面加一个 * 号，表示参数可以是0个或者多个</p>
<h3 id="3-方法返回值类型推断"><a href="#3-方法返回值类型推断" class="headerlink" title="3 方法返回值类型推断"></a>3 方法返回值类型推断</h3><p>scala定义方法可以省略返回值，由scala自动推断返回值类型。这样方法定义后更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def add(x:Int, y:Int) = x + y</span><br></pre></td></tr></table></figure>

<p><strong>定义递归返回，不能省略返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-方法调用方式"><a href="#4-方法调用方式" class="headerlink" title="4 方法调用方式"></a>4 方法调用方式</h3><p>在scala中，有以下几种方法调用方式，<br>后缀调用法<br>中缀调用法<br>花括号调用法<br>无括号调用法<br>在spark、flink程序时，使用到这些方法。<br>后缀调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(参数)</span><br><span class="line">Math.abs(-1)</span><br></pre></td></tr></table></figure>

<p>中缀调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名 方法名 参数   若有多个参数用括号</span><br><span class="line">Math abs -1</span><br></pre></td></tr></table></figure>

<p><strong>操作符就是方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 1   与中缀</span><br></pre></td></tr></table></figure>

<p>在scala中，+ - * / %等这些操作符和Java一样，但在scala中，<br>所有的操作符都是方法<br>操作符是一个方法名字是符号的方法</p>
<p><strong>花括号调用发</strong></p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.abs&#123;</span><br><span class="line">// 表达式1</span><br><span class="line">// 表达式2 最后一个表达式 的是传入abs 的参数</span><br><span class="line">&#125;</span><br><span class="line">Math.abs&#123;</span><br><span class="line">print(&quot;nn&quot;)</span><br><span class="line">-10&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无括号调用发</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果方法没有参数，可以省略方法名后面的括号</span><br></pre></td></tr></table></figure>

<p>示例<br>定义一个无参数的方法，打印”hello”<br>使用无括号调用法调用该方法<br>参考代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def m3()=println(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="八-函数"><a href="#八-函数" class="headerlink" title="八 函数"></a>八 函数</h2><p>scala支持函数式编程，将来编写Spark/Flink程序中，会大量经常使用到函数</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">val 函数变量名 = (参数名:参数类型, 参数名:参数类型....) =&gt; 函数体</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">函数是一个对象（变量）</span><br><span class="line">类似于方法，函数也有输入参数和返回值</span><br><span class="line">函数定义不需要使用 def 定义</span><br><span class="line">无需指定返回值类型</span><br><span class="line">scala&gt; val add = (x:Int, y:Int) =&gt; x + y</span><br><span class="line">add: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line">scala&gt; add(1,2)</span><br><span class="line">res3: Int = 3</span><br><span class="line">方法和函数的区别</span><br><span class="line"></span><br><span class="line">方法是隶属于类或者对象的，在运行时，它是加载到JVM的方法区中</span><br><span class="line">可以将函数对象赋值给一个变量，在运行时，它是加载到JVM的堆内存中</span><br><span class="line">函数是一个对象，继承自FunctionN，函数对象有apply，curried，toString，tupled这些方</span><br><span class="line">法。方法则没有</span><br></pre></td></tr></table></figure>

<p>方法转换为函数<br>有时候需要将方法转换为函数，作为变量传递，就需要将方法转换为函数<br>使用 _ 即可将方法转换为函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def add(x:Int,y:Int)=x+y</span><br><span class="line">add: (x: Int, y: Int)Int</span><br><span class="line">scala&gt; val a = add _</span><br><span class="line">a: (Int, Int) =&gt; Int = &lt;function2&gt;</span><br><span class="line">43</span><br></pre></td></tr></table></figure>

<h1 id="九数组"><a href="#九数组" class="headerlink" title="九数组"></a>九数组</h1><p>scala中数组的概念是和Java类似，可以用数组来存放一组数据。scala中，有两种数组，一种是定<br>长数组，另一种是变长数组</p>
<p>定长数组<br>定长数组指的是数组的长度是不允许改变的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 通过指定长度定义数组</span><br><span class="line">val/var 变量名 = new Array[元素类型](数组长度)</span><br><span class="line">// 用元素直接初始化数组</span><br><span class="line">val/var 变量名 = Array(元素1, 元素2, 元素3...)</span><br><span class="line"></span><br><span class="line">在scala中，数组的泛型使用 [] 来指定</span><br><span class="line">使用 () 来获取元素</span><br><span class="line">scala&gt; val a = new Array[Int](100)</span><br><span class="line">a: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</span><br><span class="line">scala&gt; a(0) = 110</span><br><span class="line">scala&gt; println(a(0))</span><br><span class="line">110</span><br><span class="line">// 定义包含jave、scala、python三个元素的数组</span><br><span class="line">scala&gt; val a = Array(&quot;java&quot;, &quot;scala&quot;, &quot;python&quot;)</span><br><span class="line">a: Array[String] = Array(java, scala, python)</span><br><span class="line">scala&gt; a.length</span><br><span class="line">res17: Int = 3</span><br></pre></td></tr></table></figure>

<p>变长数组<br>变长数组指的是数组的长度是可变的，可以往数组中添加、删除元素</p>
<p>定义变长数组<br>语法<br>创建空的ArrayBuffer变长数组，语法结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val/var a = ArrayBuffer[元素类型]()</span><br></pre></td></tr></table></figure>

<p>创建带有初始元素的ArrayBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val/var a = ArrayBuffer(元素1，元素2，元素3....)</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建变长数组，需要提前导入ArrayBuffer类 import scala.collection.mutable.ArrayBuffer</span><br><span class="line">val a = ArrayBuffer[Int]()   长度为0</span><br><span class="line">scala&gt; val a = ArrayBuffer(&quot;hadoop&quot;, &quot;storm&quot;, &quot;spark&quot;)</span><br><span class="line">a: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(hadoop, storm, spark)</span><br></pre></td></tr></table></figure>

<p>添加/修改/删除元素<br>使用 += 添加元素<br>使用 -= 删除元素<br>使用 ++= 追加一个数组到变长数组<br>示例</p>
<ol>
<li>定义一个变长数组，包含以下元素: “hadoop”, “spark”, “flink”</li>
<li>往该变长数组添加一个”flume”元素</li>
<li>从该变长数组删除”hadoop”元素</li>
<li>再将一个数组，该数组包含”hive”, “sqoop”追加到变长数组中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 定义变长数组</span><br><span class="line">scala&gt; val a = ArrayBuffer(&quot;hadoop&quot;, &quot;spark&quot;, &quot;flink&quot;)</span><br><span class="line">a: scala.collection.mutable.ArrayBuffer[String] = ArrayBuffer(hadoop, spark, flink)</span><br><span class="line">// 追加一个元素</span><br><span class="line">scala&gt; a += &quot;flume&quot;</span><br><span class="line">res10: a.type = ArrayBuffer(hadoop, spark, flink, flume)</span><br><span class="line">// 删除一个元素</span><br><span class="line">scala&gt; a -= &quot;hadoop&quot;</span><br><span class="line">res11: a.type = ArrayBuffer(spark, flink, flume)</span><br><span class="line">// 追加一个数组</span><br><span class="line">scala&gt; a ++= Array(&quot;hive&quot;, &quot;sqoop&quot;)</span><br><span class="line">res12: a.type = ArrayBuffer(spark, flink, flume, hive, sqoop)</span><br></pre></td></tr></table></figure>

<p>遍历数组<br>可以使用以下两种方式来遍历数组：<br>使用 for表达式 直接遍历数组中的元素<br>使用 索引 遍历数组中的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4,5)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line">scala&gt; for(i&lt;-a) println(i)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">scala&gt; val a = Array(1,2,3,4,5)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line">scala&gt; for(i &lt;- 0 to a.length - 1) println(a(i))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">scala&gt; for(i &lt;- 0 until a.length) println(a(i))</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 until n——生成一系列的数字，包含0，不包含n</span><br><span class="line">0 to n ——包含0，也包含n</span><br></pre></td></tr></table></figure>

<h3 id="数组常用算法"><a href="#数组常用算法" class="headerlink" title="数组常用算法:"></a>数组常用算法:</h3><p>scala中的数组封装了丰富的计算操作，将来在对数据处理的时候，不需要我们自己再重新实现。<br>以下为常用的几个算法：<br>求和——sum方法<br>求最大值——max方法<br>求最小值——min方法<br>排序——sorted方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = Array(1,2,3,4)</span><br><span class="line">a: Array[Int] = Array(1, 2, 3, 4)</span><br><span class="line">求和   a.sum</span><br><span class="line">最大值  a.max</span><br><span class="line">最小值  a.min</span><br><span class="line">排序   a.sorted</span><br><span class="line">降序  a.sorted.reverse</span><br></pre></td></tr></table></figure>

<h2 id="十-元组"><a href="#十-元组" class="headerlink" title="十 元组"></a>十 元组</h2><p>元组<br>元组可以用来包含一组不同类型的值。例如：姓名，年龄，性别，出生年月。元组的元素是不可变<br>的。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用括号来定义元组</span><br><span class="line">val/var 元组 = (元素1, 元素2, 元素3....)</span><br><span class="line">使用尽头来定义元素（元组只有两个元素）</span><br><span class="line">val/var 元组 = 元素1-&gt;元素2</span><br><span class="line">例子</span><br><span class="line">// 可以直接使用括号来定义一个元组</span><br><span class="line">scala&gt; val a = (1, &quot;张三&quot;, 20, &quot;北京市&quot;)</span><br><span class="line">a: (Int, String, Int, String) = (1,张三,20,北京市)</span><br><span class="line">例子二</span><br><span class="line">scala&gt; val a = 1-&gt;2</span><br><span class="line">a: (Int, Int) = (1,2)</span><br></pre></td></tr></table></figure>

<p>访问元组<br>使用_1、_2、_3….来访问元组中的元素，_1表示访问第一个元素，依次类推</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 可以直接使用括号来定义一个元组</span><br><span class="line">scala&gt; val a = (1, &quot;张三&quot;, 20, &quot;北京市&quot;)</span><br><span class="line">a: (Int, String, Int, String) = (1,张三,20,北京市)</span><br><span class="line">// 获取第一个元素</span><br><span class="line">scala&gt; a._1</span><br><span class="line">res57: Int = 1</span><br><span class="line">// 获取第二个元素</span><br><span class="line">scala&gt; a._2</span><br><span class="line">res58: String = 张三</span><br><span class="line">// 不能修改元组中的值</span><br><span class="line">scala&gt; a._1 = 2</span><br><span class="line">&lt;console&gt;:13: error: reassignment to val</span><br><span class="line">a._1 = 2</span><br><span class="line">^</span><br><span class="line">54</span><br></pre></td></tr></table></figure>

<h2 id="十一列表"><a href="#十一列表" class="headerlink" title="十一列表"></a>十一列表</h2><p>列表<br>List是scala中最重要的、也是最常用的数据结构。List具备以下性质：<br>可以保存重复的值<br>有先后顺序<br>在scala中，也有两种列表，一种是不可变列表、另一种是可变列表</p>
<h3 id="1-不可变列表"><a href="#1-不可变列表" class="headerlink" title="1 不可变列表"></a>1 不可变列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">不可变列表就是列表的元素、长度都是不可变的。</span><br><span class="line">语法</span><br><span class="line">使用 List(元素1, 元素2, 元素3, ...) 来创建一个不可变列表，语法格式：</span><br><span class="line">val/var 变量名 = List(元素1, 元素2, 元素3...)</span><br><span class="line">使用 Nil 创建一个不可变的空列表</span><br><span class="line">val/var 变量名 = Nil</span><br><span class="line">使用::拼接方式来创建列表，必须在最后添加一个Nil</span><br><span class="line">使用 :: 方法创建一个不可变列表</span><br><span class="line">val/var 变量名 = 元素1 :: 元素2 :: Nil</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例一</span><br><span class="line">创建一个不可变列表，存放以下几个元素（1,2,3,4）</span><br><span class="line">参考代码</span><br><span class="line">scala&gt; val a = List(1,2,3,4)</span><br><span class="line">a: List[Int] = List(1, 2, 3, 4)</span><br><span class="line">示例二</span><br><span class="line">使用Nil创建一个不可变的空列表</span><br><span class="line">参考代码</span><br><span class="line">scala&gt; val a = Nil</span><br><span class="line">a: scala.collection.immutable.Nil.type = List()</span><br><span class="line">示例三</span><br><span class="line">使用 :: 方法创建列表，包含-2、-1两个元素</span><br><span class="line">参考代码</span><br><span class="line">scala&gt; val a = -2 :: -1 :: Nil</span><br><span class="line">a: List[Int] = List(-2, -1)</span><br></pre></td></tr></table></figure>

<h3 id="2-可变列表"><a href="#2-可变列表" class="headerlink" title="2 可变列表"></a>2 可变列表</h3><p>可变列表就是列表的元素、长度都是可变的。<br>要使用可变列表，先要导入 import scala.collection.mutable.ListBuffer</p>
<p>注意:</p>
<p>可变集合都在 mutable 包中<br>不可变集合都在 immutable 包中（默认导入）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">初始化列表</span><br><span class="line">语法</span><br><span class="line">使用ListBuffer[元素类型]()创建空的可变列表，语法结构：</span><br><span class="line">val/var 变量名 = ListBuffer[Int]()</span><br><span class="line">使用ListBuffer(元素1, 元素2, 元素3...)创建可变列表，语法结构：</span><br><span class="line">val/var 变量名 = ListBuffer(元素1，元素2，元素3...)</span><br><span class="line">例子:</span><br><span class="line">scala&gt; val a = ListBuffer[Int]()</span><br><span class="line">a: scala.collection.mutable.ListBuffer[Int] = ListBuffer()</span><br><span class="line">例子2:</span><br><span class="line">scala&gt; val a = ListBuffer(1,2,3,4)</span><br><span class="line">a: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>

<p><strong>列表操作</strong><br>获取元素（使用括号访问 (索引值) ）<br>添加元素（ += ）<br>追加一个列表（ ++= ）<br>更改元素（ 使用括号获取元素，然后进行赋值 ）<br>删除元素（ -= ）<br>转换为List（ toList ）<br>转换为Array（ toArray ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 导入不可变列表</span><br><span class="line">scala&gt; import scala.collection.mutable.ListBuffer</span><br><span class="line">import scala.collection.mutable.ListBuffer</span><br><span class="line">// 创建不可变列表</span><br><span class="line">scala&gt; val a = ListBuffer(1,2,3)</span><br><span class="line">a: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)</span><br><span class="line">// 获取第一个元素</span><br><span class="line">scala&gt; a(0)</span><br><span class="line">res19: Int = 1</span><br><span class="line">// 追加一个元素</span><br><span class="line">scala&gt; a += 4</span><br><span class="line">res20: a.type = ListBuffer(1, 2, 3, 4)</span><br><span class="line">// 追加一个列表</span><br><span class="line">scala&gt; a ++= List(5,6,7)</span><br><span class="line">res21: a.type = ListBuffer(1, 2, 3, 4, 5, 6, 7)</span><br><span class="line">// 删除元素</span><br><span class="line">scala&gt; a -= 7</span><br><span class="line">res22: a.type = ListBuffer(1, 2, 3, 4, 5, 6)</span><br><span class="line">// 转换为不可变列表</span><br><span class="line">scala&gt; a.toList</span><br><span class="line">res23: List[Int] = List(1, 2, 3, 4, 5, 6)</span><br><span class="line">// 转换为数组</span><br><span class="line">scala&gt; a.toArray</span><br><span class="line">res24: Array[Int] = Array(1, 2, 3, 4, 5, 6</span><br></pre></td></tr></table></figure>

<p><strong>列表操作</strong></p>
<p>以下是列表常用的操作<br>判断列表是否为空（ isEmpty ）<br>拼接两个列表（ ++ ）<br>获取列表的首个元素（ head ）和剩余部分( tail )<br>反转列表（ reverse ）<br>获取前缀（ take ）、获取后缀（ drop ）<br>扁平化（ flaten ）</p>
<p> 扁平化表示将列表中的列表中的所有元素放到一个列表中。</p>
<p>拉链（ zip ）和拉开（ unzip ）<br>转换字符串（ toString ）<br>生成字符串（ mkString ）<br>并集（ union ）<br>交集（ intersect ）<br>差集（ diff ）</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">a.isEmpty</span><br><span class="line"> a ++ b</span><br><span class="line"> a.head            //获取列表的首个元素（ head ）和剩余部分( tail )</span><br><span class="line"> a.tail</span><br><span class="line"> a.reverse</span><br><span class="line"> a.take(3)    //获取前缀（ take ）、获取后缀（ drop ）</span><br><span class="line"> a.drop(3)</span><br><span class="line">扁平化表示将列表中的列表中的所有元素放到一个列表中。</span><br><span class="line">scala&gt; val a = List(List(1,2), List(3), List(4,5))</span><br><span class="line">a: List[List[Int]] = List(List(1, 2), List(3), List(4, 5))</span><br><span class="line"></span><br><span class="line">scala&gt; a.flatten</span><br><span class="line">res0: List[Int] = List(1, 2, 3, 4, 5)</span><br><span class="line">拉链：使用zip将两个列表，组合成一个元素为元组的列表</span><br><span class="line">拉开：将一个包含元组的列表，解开成包含两个列表的元组</span><br><span class="line"></span><br><span class="line">scala&gt; val a = List(&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;)</span><br><span class="line">a: List[String] = List(zhangsan, lisi, wangwu)</span><br><span class="line"></span><br><span class="line">scala&gt; val b = List(19, 20, 21)</span><br><span class="line">b: List[Int] = List(19, 20, 21)</span><br><span class="line"></span><br><span class="line">scala&gt; a.zip(b)</span><br><span class="line">res1: List[(String, Int)] = List((zhangsan,19), (lisi,20), (wangwu,21))</span><br><span class="line"></span><br><span class="line">拉开</span><br><span class="line">scala&gt; res1.unzip</span><br><span class="line">res2: (List[String], List[Int]) = (List(zhangsan, lisi, wangwu),List(19, 20, 21))</span><br><span class="line">转换字符串（ toString ）</span><br><span class="line">生成字符串（ mkString ）</span><br><span class="line"></span><br><span class="line">a.toString</span><br><span class="line">a.mkString  a.mkString(&quot;:&quot;)</span><br><span class="line">并集</span><br><span class="line">union表示对两个列表取并集，不去重</span><br><span class="line"> a1.union(a2)</span><br><span class="line"> a1.union(a2).distinct  去重</span><br><span class="line">交集</span><br><span class="line">intersect表示对两个列表取交集</span><br><span class="line">scala&gt; val a1 = List(1,2,3,4)</span><br><span class="line">a1: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; val a2 = List(3,4,5,6)</span><br><span class="line">a2: List[Int] = List(3, 4, 5, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; a1.intersect(a2)</span><br><span class="line">res19: List[Int] = List(3, 4)</span><br><span class="line">差集</span><br><span class="line">diff表示对两个列表取差集，例如： a1.diff(a2)，表示获取a1在a2中不存在的元素</span><br><span class="line">scala&gt; val a1 = List(1,2,3,4)</span><br><span class="line">a1: List[Int] = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; val a2 = List(3,4,5,6)</span><br><span class="line">a2: List[Int] = List(3, 4, 5, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; a1.diff(a2)</span><br><span class="line">res24: List[Int] = List(1, 2)</span><br></pre></td></tr></table></figure>

<h2 id="集-set"><a href="#集-set" class="headerlink" title="集 set"></a>集 set</h2><p>Set(集)是代表没有重复元素的集合。Set具备以下性质：</p>
<ol>
<li>元素不重复</li>
<li>不保证插入顺序</li>
</ol>
<p>scala中的集也分为两种，一种是不可变集，另一种是可变集。</p>
<h3 id="不可变集"><a href="#不可变集" class="headerlink" title="不可变集"></a>不可变集</h3><p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val/var 变量名 = Set[类型]()</span><br></pre></td></tr></table></figure>

<p> 给定元素来创建一个不可变集，语法格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val/var 变量名 = Set(元素1, 元素2, 元素3...)</span><br></pre></td></tr></table></figure>

<p>操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取集的大小（size）  a.size</span><br><span class="line">遍历集（和遍历数组一致）   for(i &lt;- a) println(i)</span><br><span class="line">添加一个元素，生成一个Set（+）     a - 1  不是下标 </span><br><span class="line">拼接两个集，生成一个Set（++）      a ++ Set(6,7,8)</span><br><span class="line">拼接集和列表，生成一个Set（++）      a ++ List(6,7,8,9)</span><br></pre></td></tr></table></figure>

<h3 id="可变集"><a href="#可变集" class="headerlink" title="可变集"></a>可变集</h3><p>可变集合不可变集的创建方式一致，只不过需要提前导入一个可变集类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import scala.collection.mutable.Set</span><br><span class="line">scala&gt; val a = Set(1,2,3,4)</span><br><span class="line">a: scala.collection.mutable.Set[Int] = Set(1, 2, 3, 4)                          </span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">scala&gt; a += 5</span><br><span class="line">res25: a.type = Set(1, 5, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">scala&gt; a -= 1</span><br><span class="line">res26: a.type = Set(5, 2, 3, 4)</span><br></pre></td></tr></table></figure>

<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>Map可以称之为映射。它是由键值对组成的集合。在scala中，Map也分为不可变Map和可变Map。</p>
<h3 id="不可变Map"><a href="#不可变Map" class="headerlink" title="不可变Map"></a>不可变Map</h3><p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val/var map = Map(键-&gt;值, 键-&gt;值, 键-&gt;值...)    // 推荐，可读性更好</span><br><span class="line">val/var map = Map((键, 值), (键, 值), (键, 值), (键, 值)...)</span><br><span class="line"></span><br><span class="line">例</span><br><span class="line">val map = Map(&quot;zhangsan&quot;-&gt;30, &quot;lisi&quot;-&gt;40)</span><br><span class="line">val map = Map((&quot;zhangsan&quot;, 30), (&quot;lisi&quot;, 30))</span><br><span class="line">map(&quot;zhangsan&quot;)// 根据key获取value</span><br></pre></td></tr></table></figure>

<h3 id="可变Map"><a href="#可变Map" class="headerlink" title="可变Map"></a>可变Map</h3><p>定义语法与不可变Map一致。但定义可变Map需要手动导入<code>import scala.collection.mutable.Map</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val map = Map(&quot;zhangsan&quot;-&gt;30, &quot;lisi&quot;-&gt;40)</span><br><span class="line"></span><br><span class="line">// 修改value</span><br><span class="line">scala&gt; map(&quot;zhangsan&quot;) = 20</span><br></pre></td></tr></table></figure>

<h2 id="interator-迭代器"><a href="#interator-迭代器" class="headerlink" title="interator 迭代器"></a>interator 迭代器</h2><p>scala针对每一类集合都提供了一个迭代器（iterator）用来迭代访问集合</p>
<p>使用迭代器遍历集合</p>
<ul>
<li>使用<code>iterator</code>方法可以从集合获取一个迭代器</li>
<li>迭代器的两个基本操作<ul>
<li>hasNext——查询容器中是否有下一个元素</li>
<li>next——返回迭代器的下一个元素，如果没有，抛出NoSuchElementException</li>
</ul>
</li>
<li>每一个迭代器都是有状态的<ul>
<li>迭代完后保留在最后一个元素的位置</li>
<li>再次使用则抛出NoSuchElementException</li>
</ul>
</li>
<li>可以使用while或者for来逐个返回元素</li>
</ul>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val ite = a.iterator</span><br><span class="line"> while(ite.hasNext) &#123;</span><br><span class="line">     | println(ite.next)</span><br><span class="line">     | &#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>我们将来使用Spark/Flink的大量业务代码都会使用到函数式编程。下面的这些操作是学习的重点。</p>
<ul>
<li>遍历（<code>foreach</code>）</li>
<li>映射（<code>map</code>）</li>
<li>映射扁平化（<code>flatmap</code>）</li>
<li>过滤（<code>filter</code>）</li>
<li>是否存在（<code>exists</code>）</li>
<li>排序（<code>sorted</code>、<code>sortBy</code>、<code>sortWith</code>）</li>
<li>分组（<code>groupBy</code>）</li>
<li>聚合计算（<code>reduce</code>）</li>
<li>折叠（<code>fold</code>）</li>
</ul>
<p>可以使用类型推断简化函数定义</p>
<ul>
<li>scala可以自动来推断出来集合中每个元素参数的类型</li>
<li>创建函数时，可以省略其参数列表的类型</li>
</ul>
<p>使用下划线简化函数定义</p>
<p> 函数参数，只在函数体中出现一次，而且函数体没有嵌套调用时，可以使用下划线来简化函数定义</p>
<p> 如果方法参数是函数，如果出现了下划线，scala编译器会自动将代码封装到一个函数中</p>
<p> 参数列表也是由scala编译器自动处理</p>
<h3 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1 遍历"></a>1 遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val a = List(1,2,3,4)</span><br><span class="line">a.foreach((x:Int)=&gt;println(x))</span><br><span class="line"></span><br><span class="line">使用类型推断简化</span><br><span class="line">a.foreach(x=&gt;println(x))</span><br><span class="line">使用下划线简化</span><br><span class="line">a.foreach(println(_))</span><br></pre></td></tr></table></figure>

<h3 id="2-映射"><a href="#2-映射" class="headerlink" title="2 映射"></a>2 映射</h3><p>集合的映射操作是将来在编写Spark/Flink用得最多的操作，是我们必须要掌握的。因为进行数据计算的时候，就是一个将一种数据类型转换为另外一种数据类型的过程。</p>
<p>map方法接收一个函数，将这个函数应用到每一个元素，返回一个新的列表</p>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def map[B](f: (A) ⇒ B): TraversableOnce[B]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">map方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型</td>
<td align="left">[B]</td>
<td align="left">指定map方法最终返回的集合泛型</td>
</tr>
<tr>
<td align="left">参数</td>
<td align="left">f: (A) ⇒ B</td>
<td align="left">传入一个函数对象 该函数接收一个类型A（要转换的列表元素），返回值为类型B</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">TraversableOnce[B]</td>
<td align="left">B类型的集合</td>
</tr>
</tbody></table>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=List(1,2,3,4)</span><br><span class="line">scala&gt; a.map(x=&gt;x+1)</span><br><span class="line">res4: List[Int] = List(2, 3, 4, 5)</span><br><span class="line">val a = List(1,2,3,4)</span><br><span class="line">a.map(_ + 1)</span><br></pre></td></tr></table></figure>

<h3 id="3-扁平化映射"><a href="#3-扁平化映射" class="headerlink" title="3 扁平化映射"></a>3 扁平化映射</h3><p>扁平化映射也是将来用得非常多的操作，也是必须要掌握的。</p>
<p>定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以把flatMap，理解为先map，然后再flatten</span><br><span class="line">map是将列表中的元素转换为一个List</span><br><span class="line">flatten再将整个列表进行扁平化</span><br></pre></td></tr></table></figure>

<p>方法签名:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def flatMap[B](f: (A) ⇒ GenTraversableOnce[B]): TraversableOnce[B]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">flatmap方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型</td>
<td align="left">[B]</td>
<td align="left">最终要转换的集合元素类型</td>
</tr>
<tr>
<td align="left">参数</td>
<td align="left">f: (A) ⇒ GenTraversableOnce[B]</td>
<td align="left">传入一个函数对象 函数的参数是集合的元素 函数的返回值是一个集合</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">TraversableOnce[B]</td>
<td align="left">B类型的集合</td>
</tr>
</tbody></table>
<p><strong>案例说明</strong></p>
<ol>
<li><p>有一个包含了若干个文本行的列表：”hadoop hive spark flink flume”, “kudu hbase sqoop storm”</p>
</li>
<li><p>获取到文本行中的每一个单词，并将每一个单词都放到列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定义文本行列表</span><br><span class="line">scala&gt; val a = List(&quot;hadoop hive spark flink flume&quot;, &quot;kudu hbase sqoop storm&quot;)</span><br><span class="line">a: List[String] = List(hadoop hive spark flink flume, kudu hbase sqoop storm)</span><br><span class="line"></span><br><span class="line">// 使用map将文本行转换为单词数组</span><br><span class="line">scala&gt; a.map(x=&gt;x.split(&quot; &quot;))</span><br><span class="line">res5: List[Array[String]] = List(Array(hadoop, hive, spark, flink, flume), Array(kudu, hbase, sqoop, storm))</span><br><span class="line"></span><br><span class="line">// 扁平化，将数组中的</span><br><span class="line">scala&gt; a.map(x=&gt;x.split(&quot; &quot;)).flatten</span><br><span class="line">res6: List[String] = List(hadoop, hive, spark, flink, flume, kudu, hbase, sqoop, storm)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>使用flatMap简化操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;  val a = List(&quot;hadoop hive spark flink flume&quot;, &quot;kudu hbase sqoop storm&quot;)</span><br><span class="line">a: List[String] = List(hadoop hive spark flink flume, kudu hbase sqoop storm)</span><br><span class="line"></span><br><span class="line">scala&gt; a.flatMap(_.split(&quot; &quot;))</span><br><span class="line">res7: List[String] = List(hadoop, hive, spark, flink, flume, kudu, hbase, sqoop, storm)</span><br></pre></td></tr></table></figure>

<h3 id="4-过滤"><a href="#4-过滤" class="headerlink" title="4 过滤"></a>4 过滤</h3><p>过滤符合一定条件的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def filter(p: (A) ⇒ Boolean): TraversableOnce[A]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">filter方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数</td>
<td align="left">p: (A) ⇒ Boolean</td>
<td align="left">传入一个函数对象 接收一个集合类型的参数 返回布尔类型，满足条件返回true, 不满足返回false</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">TraversableOnce[A]</td>
<td align="left">列表</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//过滤偶数   结果得到的权威偶数</span><br><span class="line">List(1,2,3,4,5,6,7,8,9).filter(_ % 2 == 0)</span><br></pre></td></tr></table></figure>

<h3 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h3><p>在scala集合中，可以使用以下几种方式来进行排序</p>
<ul>
<li>sorted默认排序</li>
<li>sortBy指定字段排序</li>
<li>sortWith自定义排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//默认排序</span><br><span class="line">List(3,1,2,9,7).sorted</span><br></pre></td></tr></table></figure>

<p>指定字段排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def sortBy[B](f: (A) ⇒ B): List[A]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">sortBy方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型</td>
<td align="left">[B]</td>
<td align="left">按照什么类型来进行排序</td>
</tr>
<tr>
<td align="left">参数</td>
<td align="left">f: (A) ⇒ B</td>
<td align="left">传入函数对象 接收一个集合类型的元素参数 返回B类型的元素进行排序</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">List[A]</td>
<td align="left">返回排序后的列表</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val a = List(&quot;01 hadoop&quot;, &quot;02 flume&quot;, &quot;03 hive&quot;, &quot;04 spark&quot;)</span><br><span class="line"> a.sortBy(_.split(&quot; &quot;)(1))</span><br><span class="line">res8: List[String] = List(02 flume, 01 hadoop, 03 hive, 04 spark)  //按照单词字母进行排序</span><br></pre></td></tr></table></figure>

<h3 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h3><p>自定义排序，根据一个函数来进行自定义排序</p>
<p>方法签名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def sortWith(lt: (A, A) ⇒ Boolean): List[A]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">sortWith方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数</td>
<td align="left">lt: (A, A) ⇒ Boolean</td>
<td align="left">传入一个比较大小的函数对象 接收两个集合类型的元素参数 返回两个元素大小，小于返回true，大于返回false</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">List[A]</td>
<td align="left">返回排序后的列表</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = List(2,3,1,6,4,5)</span><br><span class="line">a: List[Int] = List(2, 3, 1, 6, 4, 5)</span><br><span class="line"></span><br><span class="line">scala&gt; a.sortWith((x,y) =&gt; if(x&lt;y)true else false)  </span><br><span class="line">res15: List[Int] = List(1, 2, 3, 4, 5, 6)</span><br><span class="line"></span><br><span class="line">scala&gt; res15.reverse</span><br><span class="line">res18: List[Int] = List(6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure>

<p>使用下划线简写上述案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = List(2,3,1,6,4,5)</span><br><span class="line">a: List[Int] = List(2, 3, 1, 6, 4, 5)</span><br><span class="line"></span><br><span class="line">// 函数参数只在函数中出现一次，可以使用下划线代替</span><br><span class="line">scala&gt; a.sortWith(_ &lt; _).reverse</span><br><span class="line">res19: List[Int] = List(6, 5, 4, 3, 2, 1)</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们如果要将数据按照分组来进行统计分析，就需要使用到分组方法</p>
<p>groupBy表示按照函数将列表分成不同的组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方法签名</span><br><span class="line">def groupBy[K](f: (A) ⇒ K): Map[K, List[A]]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">groupBy方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型</td>
<td align="left">[K]</td>
<td align="left">分组字段的类型</td>
</tr>
<tr>
<td align="left">参数</td>
<td align="left">f: (A) ⇒ K</td>
<td align="left">传入一个函数对象 接收集合元素类型的参数 返回一个K类型的key，这个key会用来进行分组，相同的key放在一组中</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">Map[K, List[A]]</td>
<td align="left">返回一个映射，K为分组字段，List为这个分组字段对应的一组数据</td>
</tr>
</tbody></table>
<ol>
<li><p>有一个列表，包含了学生的姓名和性别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;张三&quot;, &quot;男&quot;</span><br><span class="line">&quot;李四&quot;, &quot;女&quot;</span><br><span class="line">&quot;王五&quot;, &quot;男&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请按照性别进行分组，统计不同性别的学生人数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = List(&quot;张三&quot;-&gt;&quot;男&quot;, &quot;李四&quot;-&gt;&quot;女&quot;, &quot;王五&quot;-&gt;&quot;男&quot;)</span><br><span class="line">a: List[(String, String)] = List((张三,男), (李四,女), (王五,男))</span><br><span class="line"></span><br><span class="line">// 按照性别分组</span><br><span class="line">scala&gt; a.groupBy(_._2)</span><br><span class="line">res0: scala.collection.immutable.Map[String,List[(String, String)]] = Map(男 -&gt; List((张三,男), (王五,男)),</span><br><span class="line">女 -&gt; List((李四,女)))</span><br><span class="line"></span><br><span class="line">// 将分组后的映射转换为性别/人数元组列表</span><br><span class="line">scala&gt; res0.map(x =&gt; x._1 -&gt; x._2.size)</span><br><span class="line">res3: scala.collection.immutable.Map[String,Int] = Map(男 -&gt; 2, 女 -&gt; 1)</span><br></pre></td></tr></table></figure>

<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合操作，可以将一个列表中的数据合并为一个。这种操作经常用来统计分析中</p>
<p>reduce表示将列表，传入一个函数进行聚合计算</p>
<p>方法签名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def reduce[A1 &gt;: A](op: (A1, A1) ⇒ A1): A1</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">reduce方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型</td>
<td align="left">[A1 &gt;: A]</td>
<td align="left">（下界）A1必须是集合元素类型的父类</td>
</tr>
<tr>
<td align="left">参数</td>
<td align="left">op: (A1, A1) ⇒ A1</td>
<td align="left">传入函数对象，用来不断进行聚合操作 第一个A1类型参数为：当前聚合后的变量 第二个A1类型参数为：当前要进行聚合的元素</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">A1</td>
<td align="left">列表最终聚合为一个元素</td>
</tr>
</tbody></table>
<p>注意:</p>
<ul>
<li>reduce和reduceLeft效果一致，表示从左到右计算</li>
<li>reduceRight表示从右到左计算</li>
</ul>
<ol>
<li>定义一个列表，包含以下元素：1,2,3,4,5,6,7,8,9,10</li>
<li>使用reduce计算所有元素的和</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = List(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line">a: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line"></span><br><span class="line">scala&gt; a.reduce((x,y) =&gt; x + y)</span><br><span class="line">res5: Int = 55</span><br><span class="line"></span><br><span class="line">// 第一个下划线表示第一个参数，就是历史的聚合数据结果</span><br><span class="line">// 第二个下划线表示第二个参数，就是当前要聚合的数据元素</span><br><span class="line">scala&gt; a.reduce(_ + _)</span><br><span class="line">res53: Int = 55</span><br><span class="line"></span><br><span class="line">// 与reduce一样，从左往右计算</span><br><span class="line">scala&gt; a.reduceLeft(_ + _)</span><br><span class="line">res0: Int = 55</span><br><span class="line"></span><br><span class="line">// 从右往左聚合计算</span><br><span class="line">scala&gt; a.reduceRight(_ + _)</span><br><span class="line">res1: Int = 55</span><br></pre></td></tr></table></figure>

<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p>fold与reduce很像，但是多了一个指定初始值参数</p>
<p>方法签名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def fold[A1 &gt;: A](z: A1)(op: (A1, A1) ⇒ A1): A1</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">reduce方法</th>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">泛型</td>
<td align="left">[A1 &gt;: A]</td>
<td align="left">（下界）A1必须是集合元素类型的父类</td>
</tr>
<tr>
<td align="left">参数1</td>
<td align="left">z: A1</td>
<td align="left">初始值</td>
</tr>
<tr>
<td align="left">参数2</td>
<td align="left">op: (A1, A1) ⇒ A1</td>
<td align="left">传入函数对象，用来不断进行折叠操作 第一个A1类型参数为：当前折叠后的变量 第二个A1类型参数为：当前要进行折叠的元素</td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">A1</td>
<td align="left">列表最终折叠为一个元素</td>
</tr>
</tbody></table>
<p>注意:</p>
<ul>
<li>fold和foldLet效果一致，表示从左往右计算</li>
<li>foldRight表示从右往左计算</li>
</ul>
<ol>
<li>定义一个列表，包含以下元素：1,2,3,4,5,6,7,8,9,10</li>
<li>使用fold方法计算所有元素的和</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a = List(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line">a: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line"></span><br><span class="line">scala&gt; a.fold(0)(_ + _)</span><br><span class="line">res4: Int = 155</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Scala入门/" data-id="cjz25rjbq000ld8u518ybkn16" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Scala进阶1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Scala进阶1/" class="article-date">
  <time datetime="2019-08-08T03:56:02.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Scala进阶1/">Scala进阶1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Scala-进阶"><a href="#Scala-进阶" class="headerlink" title="Scala 进阶"></a>Scala 进阶</h1><h1 id="一-类与对象"><a href="#一-类与对象" class="headerlink" title="一 类与对象"></a>一 类与对象</h1><p>scala是支持面向对象的，也有类和对象的概念。</p>
<p>创建类和对象</p>
<ul>
<li>使用<code>class</code>关键字来定义类</li>
<li>使用<code>var</code>/<code>val</code>来定义成员变量</li>
<li>使用<code>def</code>来定义成员方法</li>
<li>使用<code>new</code>来创建一个实例对象</li>
</ul>
<ol>
<li><p>var name:String = <em>，</em>表示使用默认值进行初始化</p>
<p>例如：String类型默认值是null，Int类型默认值是0，Boolean类型默认值是false…</p>
</li>
<li><p>val变量不能使用_来进行初始化，因为val是不可变的，所以必须手动指定一个默认值</p>
</li>
<li><p>main方法必须要放在一个scala的<code>object</code>（单例对象）中才能执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo4 &#123;</span><br><span class="line">  class Pe&#123;</span><br><span class="line">    var name:String=_</span><br><span class="line">    var age:Int =_</span><br><span class="line">    def add(m:String) = print(m)</span><br><span class="line">    private def a(a:String )= print(a)  //private不可被访问</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val pe = new Pe</span><br><span class="line">    pe.add(&quot;mm&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>geter和setter方法:</p>
<ol>
<li>scala会自动为成员变量生成scala语言的getter/setter</li>
<li>scala的getter为<code>字段名()</code>，setter为<code>字段名_=()</code></li>
<li>要生成Java的getter/setter，可以在成员变量上加一个<code>@BeanProperty</code>注解，这样将来去调用一些Java库的时候很有</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BeanProperty</span><br><span class="line">var name:String = _             // 姓名</span><br><span class="line"></span><br><span class="line">@BeanProperty</span><br><span class="line">val registerDate = new Date()   // 注册时间</span><br></pre></td></tr></table></figure>

<h1 id="二构造器"><a href="#二构造器" class="headerlink" title="二构造器"></a>二构造器</h1><h2 id="1-主构造器"><a href="#1-主构造器" class="headerlink" title="1 主构造器"></a>1 主构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Demo5 &#123;</span><br><span class="line">  class Per(var name:String =&quot;&quot;,var sex:String= &quot;&quot;)&#123;</span><br><span class="line">    print(&quot;构造&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ni = new Per(&quot;ni&quot;,&quot;男&quot;)</span><br><span class="line">    println(ni.name)</span><br><span class="line">    println(ni.sex)</span><br><span class="line"></span><br><span class="line">    val per = new Per()</span><br><span class="line">    println(ni.sex)</span><br><span class="line">    println(ni.name)</span><br><span class="line"></span><br><span class="line">    println(new Per(sex = &quot;女&quot;).sex)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-辅助构造器"><a href="#2-辅助构造器" class="headerlink" title="2 辅助构造器"></a>2 辅助构造器</h2><p>与定义方法一样,且方法名一定为this</p>
<p>注意:</p>
<p>辅助构造器第一行必须调用主构造器或者其他辅助构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">object Demo6 &#123;</span><br><span class="line"></span><br><span class="line">  class Cus(var name: String = &quot;&quot;, var add: String = &quot;&quot;) &#123;</span><br><span class="line">    //辅助构造器</span><br><span class="line">    def this(fu: Array[String]) &#123;</span><br><span class="line">      this(fu(0), fu(1))</span><br><span class="line">    &#125;</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">      this(name,&quot;郑州&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">   /* def this (add:String)&#123;</span><br><span class="line">      this(&quot;你猜&quot;,add)</span><br><span class="line">    &#125;*/</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val cus = new Cus(Array[String](&quot;aa&quot;,&quot;北京&quot;))</span><br><span class="line">    println(cus.add)</span><br><span class="line">    val cus2 = new Cus(&quot;niu&quot;)</span><br><span class="line">    println(cus2.add)//郑州</span><br><span class="line">    print(cus2.name)//niu</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>主构造器直接在类名后面定义</li>
<li>主构造器中的参数列表会自动定义为私有的成员变量</li>
<li>一般在主构造器中直接使用val/var定义成员变量，这样看起来会更简洁</li>
<li>在辅助构造器中必须调用其他构造器（主构造器、其他辅助构造器）</li>
</ol>
<h2 id="三-单例对象-类似于java中的static"><a href="#三-单例对象-类似于java中的static" class="headerlink" title="三 单例对象 (类似于java中的static)"></a>三 单例对象 (类似于java中的static)</h2><p>scala要比Java更加面向对象，所以，scala中是没有Java中的静态成员的。如果将来我们需要用到static变量、static方法，就要用到scala中的单例对象——object。可以把object理解为全是包含静态字段、静态方法的class，object本质上也是一个class。</p>
<p><strong>定义object</strong></p>
<p>定义单例对象和定义类很像，就是把class换成object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">定义一个工具类，用来格式化日期时间</span><br><span class="line">object DateUtils &#123;</span><br><span class="line"></span><br><span class="line">  // 在object中定义的成员变量，相当于Java中定义一个静态变量</span><br><span class="line">  // 定义一个SimpleDateFormat日期时间格式化对象</span><br><span class="line">  val simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;)</span><br><span class="line"></span><br><span class="line">  // 构造代码</span><br><span class="line">  println(&quot;构造代码&quot;)</span><br><span class="line">    </span><br><span class="line">  // 相当于Java中定义一个静态方法</span><br><span class="line">  def format(date:Date) = simpleDateFormat.format(date)</span><br><span class="line"></span><br><span class="line">  // main是一个静态方法，所以必须要写在object中</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println &#123; DateUtils.format(new Date()) &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>使用<code>object 单例对象名</code>定义一个单例对象，可以用object作为工具类或者存放常量</li>
<li>在单例对象中定义的变量，类似于Java中的static成员变量</li>
<li>在单例对象中定义的方法，类似于Java中的static方法</li>
<li>object单例对象的构造代码可以直接写在花括号中</li>
<li>调用单例对象的方法，直接使用<code>单例对象名.方法名</code>，访问单例对象的成员变量也是使用<code>单例对象名.变量名</code></li>
<li>单例对象只能有一个<code>无参的主构造器</code>，不能添加其他参数</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">object Demo7 &#123;</span><br><span class="line">  object Dog&#123;</span><br><span class="line">    val num=4;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    print(Dog.num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//调用方法</span><br><span class="line">object Demo8 &#123;</span><br><span class="line">  object Uf&#123;</span><br><span class="line">    def add(): Unit =&#123;</span><br><span class="line">      print(&quot;-&quot; * 15)   //生成15 个-</span><br><span class="line">      print(&quot;nicai&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    Uf.add()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>伴生对象</strong></p>
<p>在Java中，经常会有一些类，同时有实例成员又有静态成员。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CustomerService &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = Logger.getLogger(&quot;customerService&quot;);</span><br><span class="line"></span><br><span class="line">    public void save(String customer) &#123;</span><br><span class="line">        logger.info(&quot;添加一个用户&quot;);</span><br><span class="line">        // 保存客户</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new CustomerService().save(&quot;客户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在scala中，可以使用<code>伴生对象</code>来实现。</p>
<p><strong>一个class和object具有同样的名字。这个object称为伴生对象，这个class称为伴生类</strong></p>
<p>注意:</p>
<p>半生类和伴生对象一样的名字</p>
<p>这两个要在同一个scala源文件中</p>
<p>这两个可以互相访问private属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">object Demo11 &#123;</span><br><span class="line">  //半生类</span><br><span class="line">  class Ssm()&#123;</span><br><span class="line">    def fin(): Unit =&#123;</span><br><span class="line">        print(Ssm.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //半生对象</span><br><span class="line">  object Ssm&#123;</span><br><span class="line">    var name=&quot;nicai&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ssm = new Ssm</span><br><span class="line">    ssm.fin()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="private-this-访问权限-表示只能在当前类中访问-伴生对象也不可访问"><a href="#private-this-访问权限-表示只能在当前类中访问-伴生对象也不可访问" class="headerlink" title="private[this] 访问权限 表示只能在当前类中访问,伴生对象也不可访问"></a>private[this] 访问权限 表示只能在当前类中访问,伴生对象也不可访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object Demo12 &#123;</span><br><span class="line">  class De(private[this] var name:String,var age:Int)</span><br><span class="line"></span><br><span class="line">  object De&#123;</span><br><span class="line">    def p(d:De): Unit =print(d.name)   //直接报错</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    De.p(new De(&quot;aa&quot;,788))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具类案例:</p>
<p>需求:</p>
<p>编写一个工具类专门格式化日期时间</p>
<p>定义一个方法用于将日期转换为年月日字符串 2012-10-15</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo9 &#123;</span><br><span class="line">  object Forma&#123;</span><br><span class="line">    //java 中的类</span><br><span class="line">    private val format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line"></span><br><span class="line">    //定义方法</span><br><span class="line">    def fm(data:Date)=format.format(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(Forma.fm(new Date()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>apply方法</strong></p>
<p><strong>必须用在伴生对象中</strong></p>
<p>我们之前使用过这种方式来创建一个Array对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a=Array(1,2)</span><br></pre></td></tr></table></figure>

<p>这种写法非常简便，不需要再写一个new，然后敲一个空格，再写类名。如何直接使用类名来创建对象呢？</p>
<p>答案就是：**实现伴生对象的<code>apply</code>方法</p>
<p>伴生对象的apply方法用来快速地创建一个伴生类的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">object Demo13 &#123;</span><br><span class="line">  class Person(var name:String, var age:Int) &#123;</span><br><span class="line"></span><br><span class="line">    override def toString = s&quot;Person($name, $age)&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  object Person &#123;</span><br><span class="line">    // 实现apply方法</span><br><span class="line">    // 返回的是伴生类的对象</span><br><span class="line">    def apply(name:String, age:Int): Person = new Person(name, age)</span><br><span class="line"></span><br><span class="line">    // apply方法支持重载</span><br><span class="line">    def apply(name:String):Person = new Person(name, 20)</span><br><span class="line"></span><br><span class="line">    def apply(age:Int):Person = new Person(&quot;某某某&quot;, age)</span><br><span class="line"></span><br><span class="line">    def apply():Person = new Person(&quot;某某某&quot;, 20)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(Person(&quot;jjj&quot;).name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当遇到<code>类名(参数1, 参数2...)</code>会自动调用apply方法，在apply方法中来创建对象</li>
<li>定义apply时，如果参数列表是空，也不能省略括号()，否则引用的是伴生对象</li>
</ol>
<p><strong>main方法</strong></p>
<p>scala和Java一样，如果要运行一个程序，必须有一个main方法。而在Java中main方法是静态的，而在scala中没有静态方法。在scala中，这个main方法必须放在一个object中。</p>
<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Main5 &#123;</span><br><span class="line">  def main(args:Array[String]) = &#123;</span><br><span class="line">    println(&quot;hello, scala&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以继承自App Trait（特质），然后将需要编写在main方法中的代码，写在object的构造方法体内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object 	Main extends App&#123;</span><br><span class="line">println(&quot;heoo&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四继承"><a href="#四继承" class="headerlink" title="四继承"></a>四继承</h2><p>scala和Java一样，使用<strong>extends</strong>关键字来实现继承。可以在子类中定义父类中没有的字段和方法，或者重写父类的方法。</p>
<p>类和单例对象都可以从某个父类继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo14 &#123;</span><br><span class="line">  class Per()&#123;</span><br><span class="line">    var name=&quot;&quot;</span><br><span class="line">    def getName()=this.name</span><br><span class="line">  &#125;</span><br><span class="line">  class Student extends Per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val student = new Student</span><br><span class="line">    student.name=&quot;ni&quot;</span><br><span class="line">    println(student.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object Demo15&#123;</span><br><span class="line">  class Per()&#123;</span><br><span class="line">    var name=&quot;&quot;</span><br><span class="line">    def a()=print(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  object Stu extends Per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    Stu.name=&quot;ni&quot;</span><br><span class="line">    println(Stu.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="override-和supper"><a href="#override-和supper" class="headerlink" title="override 和supper"></a>override 和supper</h3><hr>
<ul>
<li>如果子类要覆盖父类中的一个非抽象方法，必须要使用override关键字</li>
<li>可以使用override关键字来重写一个val字段</li>
<li>可以使用super关键字来访问父类的成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Demo16 &#123;</span><br><span class="line">  class Per()&#123;</span><br><span class="line">    val name:String =&quot;22&quot;</span><br><span class="line">    var age:Int=0</span><br><span class="line">    def getName()=this.name</span><br><span class="line">  &#125;</span><br><span class="line">  class Stu extends Per&#123;</span><br><span class="line">    override val name: String = &quot;nn&quot;</span><br><span class="line"></span><br><span class="line">    override def getName(): String = &quot;ni&quot;+super.getName()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val stu = new Stu</span><br><span class="line">    println(stu.getName())  //ninn</span><br><span class="line">    println(stu.name)    //nn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型的判断与转换"><a href="#类型的判断与转换" class="headerlink" title="类型的判断与转换"></a>类型的判断与转换</h3><p>我们经常要在代码中进行类型的判断和类型的转换。在Java中，我们可以使用instanceof关键字、以及(类型)object来实现，在scala中如何实现呢？</p>
<p>scala中对象提供isInstanceOf和asInstanceOf方法。</p>
<ul>
<li>isInstanceOf判断对象是否为指定类的对象</li>
<li>asInstanceOf将对象转换为指定类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object Demo17 &#123;</span><br><span class="line">  class per</span><br><span class="line">  class Stu extends per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val stu = new Stu</span><br><span class="line">    if(stu.isInstanceOf[Stu])&#123;</span><br><span class="line">      stu.asInstanceOf[Stu]</span><br><span class="line">      print(stu)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      print(&quot;不是stu类型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getClass和classOf"><a href="#getClass和classOf" class="headerlink" title="getClass和classOf"></a>getClass和classOf</h3><p>isInstanceOf 只能判断出对象是否为指定类以及其子类的对象，而不能精确的判断出，对象就是指定类的对象。如果要求精确地判断出对象就是指定类的对象，那么就只能使用 getClass 和 classOf 。</p>
<ul>
<li>p.getClass可以精确获取对象的类型</li>
<li>classOf[x]可以精确获取类型</li>
<li>使用==操作符就可以直接比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">object Demo18 &#123;</span><br><span class="line">  class Per()</span><br><span class="line">  class Stu extends Per</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val stu:Per=new Stu</span><br><span class="line"></span><br><span class="line">    if(stu.isInstanceOf[Per])&#123;</span><br><span class="line">      println(&quot;stu是一个per类型&quot;)      ///y</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      println(&quot;stu 不是一个per类型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(stu.getClass == classOf[Per])&#123;</span><br><span class="line">      println(&quot;stu是一个per类型&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      println(&quot;stu 不是一个per类型&quot;)     ////y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(stu.getClass == classOf[Stu])&#123;</span><br><span class="line">      println(&quot;stu是一个STU类型&quot;)       //y</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      println(&quot;stu 不是一个stu类型&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用父类的constructor</strong></p>
<p>实例化子类对象，必须要调用父类的构造器，在scala中，只能在子类的<code>主构造器</code>中调用父类的构造器</p>
<p>步骤：</p>
<ol>
<li>创建一个Person类，编写带有一个可变的name字段的主构造器</li>
<li>创建一个Student类，继承自Person类<ul>
<li>编写带有一个name参数、clazz班级字段的主构造器</li>
<li>调用父类的构造器</li>
</ul>
</li>
<li>创建main方法，创建Student对象实例，并打印它的姓名、班级</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> class Person5(var name:String)</span><br><span class="line">// 直接在父类的类名后面调用父类构造器</span><br><span class="line">class Student5(name:String, var clazz:String) extends Person5(name)</span><br><span class="line"></span><br><span class="line">object Main5 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val s1 = new Student5(&quot;张三&quot;, &quot;三年二班&quot;)</span><br><span class="line">    println(s&quot;$&#123;s1.name&#125; - $&#123;s1.clazz&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果类的某个成员在当前类中的定义是不包含完整的，它就是一个<strong>抽象类</strong></p>
<p>不完整定义有两种情况：</p>
<ol>
<li>方法没有方法体</li>
<li>变量没有初始化</li>
</ol>
<p>没有方法体的方法称为<strong>抽象方法</strong>，没有初始化的变量称为<strong>抽象字段</strong>。定义抽象类和Java一样，在类前面加上<strong>abstract</strong>关键字就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//抽象方法</span><br><span class="line">object Demo19 &#123;</span><br><span class="line">   abstract class Sop()&#123;</span><br><span class="line">      def m():Double    //或者 def  m:Double</span><br><span class="line">    &#125;</span><br><span class="line">  class z(l:Double ) extends Sop&#123;</span><br><span class="line">    override def m:Double  = l*l</span><br><span class="line">  &#125;</span><br><span class="line">  class Cyc(r:Double) extends Sop&#123;</span><br><span class="line">    override def m:Double  =  Math.PI*r*r</span><br><span class="line">  &#125;</span><br><span class="line">  class Ju(l:Double,k:Double) extends Sop&#123;</span><br><span class="line">    override def m: Double = l*k</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val z = new z(12.3)</span><br><span class="line">    val cyc = new Cyc(2)</span><br><span class="line">    val ju = new Ju(1,3.0)</span><br><span class="line">    println(z.m)</span><br><span class="line">    println(cyc.m)</span><br><span class="line">    println(ju.m)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象字段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个人的抽象类</span><br><span class="line">abstract class Person6 &#123;</span><br><span class="line">  // 没有初始化的val字段就是抽象字段</span><br><span class="line">  val WHO_AM_I:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student6 extends Person6 &#123;</span><br><span class="line">  override val WHO_AM_I: String = &quot;学生&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Policeman6 extends Person6 &#123;</span><br><span class="line">  override val WHO_AM_I: String = &quot;警察&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Main6 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val p1 = new Student6</span><br><span class="line">    val p2 = new Policeman6</span><br><span class="line"></span><br><span class="line">    println(p1.WHO_AM_I)</span><br><span class="line">    println(p2.WHO_AM_I)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类是没有名称的子类，直接用来创建实例对象。Spark的源代码中有大量使用到匿名内部类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object Demo20 &#123;</span><br><span class="line">  abstract class Per()&#123;</span><br><span class="line">    def say()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val per = new Per &#123;</span><br><span class="line">      override def say(): Unit = println(&quot;nicai&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    per.say()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特质-trait"><a href="#特质-trait" class="headerlink" title="特质(trait)"></a>特质(trait)</h2><p>scala中没有接口的概念 替代的就是特质</p>
<ul>
<li>特质是scala中代码复用的基础单元</li>
<li>它可以将方法和字段定义封装起来，然后添加到类中</li>
<li>与类继承不一样的是，类继承要求每个类都只能继承<code>一个</code>超类，而一个类可以添加<code>任意数量</code>的特质。</li>
<li>特质的定义和抽象类的定义很像，但它是使用<code>trait</code>关键字</li>
</ul>
<h3 id="用法一-作为接口使用"><a href="#用法一-作为接口使用" class="headerlink" title="用法一 作为接口使用"></a>用法一 作为接口使用</h3><ul>
<li>使用<code>extends</code>来继承trait（scala不论是类还是特质，都是使用extends关键字）</li>
<li>如果要继承多个trait，则使用<code>with</code>关键字</li>
</ul>
<p><strong>继承单个特质</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo21 &#123;</span><br><span class="line">  trait Loger&#123;</span><br><span class="line">    def pr(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  class LogerE extends Loger&#123;</span><br><span class="line">    override def pr(msg: String): Unit = print(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var e:Loger=new LogerE()</span><br><span class="line">    e.pr(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承多个特质</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">object Demo22 &#123;</span><br><span class="line">  trait D1&#123;</span><br><span class="line">    def ms(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  trait D2&#123;</span><br><span class="line">    def ms():String</span><br><span class="line">  &#125;</span><br><span class="line">  class D3 extends D1 with D2&#123;</span><br><span class="line">    override def ms(msg: String): Unit = println(msg)</span><br><span class="line"></span><br><span class="line">    override def ms(): String = &quot;nicai&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = new D3</span><br><span class="line">    d.ms(&quot;ni&quot;)</span><br><span class="line">    println(d.ms())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>object 继承trait</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">object Demo23 &#123;</span><br><span class="line">  trait D1&#123;</span><br><span class="line">    def m(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  object D2 extends D1&#123;</span><br><span class="line">    override def m(msg: String): Unit = print(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    D2.m(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在trait中可以定义抽象方法，不写方法体就是抽象方法</li>
<li>和继承类一样，使用extends来继承trait</li>
<li>继承多个trait，使用with关键字</li>
<li>单例对象也可以继承trait</li>
</ol>
<h3 id="特质-定义具体的方法"><a href="#特质-定义具体的方法" class="headerlink" title="特质 定义具体的方法"></a>特质 定义具体的方法</h3><p>和类一样，trait中还可以定义具体的方法。·</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo24 &#123;</span><br><span class="line">  trait D&#123;</span><br><span class="line">    def add(msg:String) = println(msg)</span><br><span class="line">  &#125;</span><br><span class="line">   class  D2 extends D&#123;</span><br><span class="line">     def add2()= add(&quot;nicai&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = new D2</span><br><span class="line">    d.add2()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trait中定义具体的字段和抽象字段"><a href="#trait中定义具体的字段和抽象字段" class="headerlink" title="trait中定义具体的字段和抽象字段"></a>trait中定义具体的字段和抽象字段</h3><ul>
<li>在trait中，可以混合使用具体方法和抽象方法</li>
<li>使用具体方法依赖于抽象方法，而抽象方法可以放到继承trait的子类中实现，这种设计方式也称为<strong>模板模式</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">object Demo25 &#123;</span><br><span class="line">  trait D&#123;</span><br><span class="line">  val s = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;)</span><br><span class="line">    var TYPE:String</span><br><span class="line">    def pr(msg:String)</span><br><span class="line">  &#125;</span><br><span class="line">  class D2 extends D&#123;</span><br><span class="line">    override var TYPE: String = &quot;控制台消息&quot;</span><br><span class="line"></span><br><span class="line">    override def pr(msg: String): Unit = println(s&quot;$&#123;TYPE&#125;:$&#123;s.format(new Date)&#125;:$&#123;msg&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = new D2</span><br><span class="line">    d.pr(&quot;nnicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用trait实现模板模式"><a href="#使用trait实现模板模式" class="headerlink" title="使用trait实现模板模式"></a>使用trait实现模板模式</h3><p>在特质中,具体方法依赖于抽象方法,而抽象 方法可以放在继承trait中的子类中实现,这种方式为模板设计模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">object Demo26 &#123;</span><br><span class="line">    trait  Logger&#123;</span><br><span class="line">      def  log(msg:String)</span><br><span class="line">      def info(msg:String) = log(msg)</span><br><span class="line">      def exce(msg:String) = log(msg)</span><br><span class="line">      def erro(msg:String) = log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  class LogE extends Logger&#123;</span><br><span class="line">    override def log(msg: String): Unit = println(msg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val e = new LogE</span><br><span class="line">    e.info(&quot;info&quot;)</span><br><span class="line">    e.exce(&quot;exec&quot;)</span><br><span class="line">    e.erro(&quot;erro&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象混入trait"><a href="#对象混入trait" class="headerlink" title="对象混入trait"></a>对象混入trait</h3><ul>
<li>trait还可以混入到<code>实例对象</code>中，给对象实例添加额外的行为</li>
<li>只有混入了trait的对象才具有trait中的方法，其他的类对象不具有trait中的行为</li>
<li>使用with将trait混入到实例对象中</li>
</ul>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var /val da=new 类 with 特质</span><br><span class="line">object Demo27 &#123;</span><br><span class="line">  trait Logger&#123;</span><br><span class="line">    def log()=println(&quot;nicai&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  class Aa</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val aa = new Aa with Logger</span><br><span class="line">    aa.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="trait-实现调用链模式"><a href="#trait-实现调用链模式" class="headerlink" title="trait 实现调用链模式"></a>trait 实现调用链模式</h3><p>类继承了多个trait后，可以依次调用多个trait中的同一个方法，只要让多个trait中的同一个方法在最后都依次执行super关键字即可。类中调用多个tait中都有这个方法时，首先会从最右边的trait方法开始执行，然后依次往左执行，形成一个调用链条。</p>
<p>如支付连 等</p>
<p>说明 : 一个子类 继承多个父trait 且还有祖父trait 则 会先执行自己的 在执行从右到左的父trait(继承顺序相反),最后执行祖父trait</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">object Demo28 &#123;</span><br><span class="line">    trait Zf&#123;</span><br><span class="line">      def log(data:String ) = println(&quot;祖父&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  trait Login extends Zf&#123;</span><br><span class="line">    override def log(data: String): Unit =&#123;</span><br><span class="line">      println(&quot;父1&quot;)</span><br><span class="line">      super.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  trait Handle extends Zf&#123;</span><br><span class="line">    override def log(data: String): Unit = &#123;</span><br><span class="line">      println(&quot;父2&quot;)</span><br><span class="line">      super.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Ser() extends Handle with Login &#123;</span><br><span class="line">    override def log(data: String): Unit = &#123;</span><br><span class="line">     println(&quot;子类&quot;)</span><br><span class="line">      super.log(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ser = new Ser()</span><br><span class="line">    ser.log(&quot;nn&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子类</span><br><span class="line">//父1</span><br><span class="line">//父2</span><br><span class="line">//祖父</span><br></pre></td></tr></table></figure>

<h3 id="trait的构造机制"><a href="#trait的构造机制" class="headerlink" title="trait的构造机制"></a>trait的构造机制</h3><ul>
<li>trait也有构造代码，但和类不一样，特质不能有构造器参数</li>
<li>每个特质只有<strong>一个无参数</strong>的构造器。</li>
<li>一个类继承另一个类、以及多个trait，当创建该类的实例时，它的构造顺序如下：<ol>
<li>执行父类的构造器</li>
<li><code>从左到右</code>依次执行trait的构造器</li>
<li>如果trait有父trait，先构造父trait，如果多个trait有同样的父trait，则只初始化一次</li>
<li>执行子类构造器</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person_One &#123;</span><br><span class="line">  println(&quot;执行Person构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait Logger_One &#123;</span><br><span class="line">  println(&quot;执行Logger构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait MyLogger_One extends Logger_One &#123;</span><br><span class="line">  println(&quot;执行MyLogger构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">trait TimeLogger_One extends Logger_One &#123;</span><br><span class="line">  println(&quot;执行TimeLogger构造器!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">class Student_One extends Person_One with MyLogger_One with TimeLogger_One &#123;</span><br><span class="line">  println(&quot;执行Student构造器!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">object exe_one &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val student = new Student_One</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 程序运行输出如下：</span><br><span class="line">// 执行Person构造器!</span><br><span class="line">// 执行Logger构造器!</span><br><span class="line">// 执行MyLogger构造器!</span><br><span class="line">// 执行TimeLogger构造器!</span><br><span class="line">// 执行Student构造器!</span><br></pre></td></tr></table></figure>

<p><strong>trait继承class</strong></p>
<ul>
<li>trait也可以继承class 会把class中的成员都继承下来</li>
<li>这个class就会成为所有该trait子类的超级父类。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyUtil &#123;</span><br><span class="line">  def printMsg(msg: String) = println(msg)</span><br><span class="line">&#125;</span><br><span class="line">trait Logger_Two extends MyUtil &#123;</span><br><span class="line">  def log(msg: String) = this.printMsg(&quot;log: &quot; + msg)</span><br><span class="line">&#125;</span><br><span class="line">class Person_Three(val name: String) extends Logger_Two &#123;</span><br><span class="line">    def sayHello &#123;</span><br><span class="line">        this.log(&quot;Hi, I&apos;m &quot; + this.name)</span><br><span class="line">        this.printMsg(&quot;Hello, I&apos;m &quot; + this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object Person_Three&#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">      val p=new Person_Three(&quot;Tom&quot;)</span><br><span class="line">      p.sayHello</span><br><span class="line">    //执行结果：</span><br><span class="line">//      log: Hi, I&apos;m Tom</span><br><span class="line">//      Hello, I&apos;m Tom</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Scala进阶1/" data-id="cjz25rjbe000fd8u5ltyx2nrv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Scala进阶2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Scala进阶2/" class="article-date">
  <time datetime="2019-08-08T03:55:52.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Scala进阶2/">Scala进阶2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一 样例类</p>
<p>样例类是一种特殊类，它可以用来快速定义一个用于<strong>保存数据</strong>的类（类似于Java POJO类），而且它会自动生成apply方法，允许我们快速地创建样例类实例对象。后面，在并发编程和spark、flink这些框架也都会经常使用它。</p>
<ol>
<li>样例类可以使用<strong>类名(参数1, 参数2…)</strong>快速创建实例对象</li>
<li>定义样例类成员变量时，可以指定var类型，表示可变。默认是不可变的 val 可省略</li>
<li>样例类自动生成了toString、equals、hashCode、copy方法</li>
<li>样例对象没有主构造器，可以使用样例对象来创建枚举、或者标识一类没有任何数据的消息</li>
</ol>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case class 样例类名(成员变量名1:类型1, 成员变量名2:类型2, 成员变量名3:类型3)</span><br></pre></td></tr></table></figure>

<p><strong>定义样例类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object Demo1 &#123;</span><br><span class="line">  case class Per(name:String, var age:Int)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val per = Per(&quot;你猜&quot;,25)</span><br><span class="line">    //per.name=&quot;njj&quot;   会报错</span><br><span class="line">    per.age=25  //正常可以修改</span><br><span class="line">    println(per)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="样例类的方法"><a href="#样例类的方法" class="headerlink" title="样例类的方法"></a>样例类的方法</h3><p>定义样例类编译器自动帮我们实现了一下几个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply   快速的用类名创建对象</span><br><span class="line">toString   与java同</span><br><span class="line">equals      比较两个样例类的成员变量是否相等  与==类似</span><br><span class="line">hashCode    如两个样例类的所有的成员变量的值相等 则hash值相等 否则 只要一个不同 则hash值就不等</span><br><span class="line">copy     样例类的克隆</span><br><span class="line">object Demo2 &#123;</span><br><span class="line">  case class Per(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val nicai = Per(&quot;nicai&quot;,55)</span><br><span class="line">    val nn = nicai.copy(&quot;nn&quot;)</span><br><span class="line">      //可以修改成员变量的值</span><br><span class="line">    println(nn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="样例对象"><a href="#样例对象" class="headerlink" title="样例对象"></a>样例对象</h3><p>使用case object可以创建样例对象。样例对象是单例的，而且它<strong>没有主构造器</strong>。样例对象是可序列化的。格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case object 样例对象名</span><br></pre></td></tr></table></figure>

<p>它主要用在两个地方：</p>
<ol>
<li>定义枚举</li>
<li>作为没有任何参数的消息传递（后面Akka编程会讲到）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">object Demo3 &#123;</span><br><span class="line">  //定义一个枚举</span><br><span class="line">  trait Sex</span><br><span class="line">  case object Man extends Sex</span><br><span class="line">  case object Wonmn extends Sex</span><br><span class="line"></span><br><span class="line"> case class Per(name:String,sex: Sex)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val per = Per(&quot;小明&quot;,Man)</span><br><span class="line">    val p = Per(&quot;小红&quot;,Wonmn)</span><br><span class="line">    println(per)</span><br><span class="line">    println(p)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case class StartSpeakingMessage(textToSpeak: String)</span><br><span class="line">// 消息如果没有任何参数，就可以定义为样例对象</span><br><span class="line">case object StopSpeakingMessage</span><br><span class="line">case object PauseSpeakingMessage</span><br><span class="line">case object ResumeSpeakingMessage</span><br></pre></td></tr></table></figure>

<h1 id="二模板匹配"><a href="#二模板匹配" class="headerlink" title="二模板匹配"></a>二模板匹配</h1><p>scala中有一个非常强大的模式匹配机制，可以应用在很多场景：</p>
<ul>
<li>switch语句</li>
<li>类型查询</li>
<li>以及快速获取数据</li>
</ul>
<h3 id="简单模式匹配"><a href="#简单模式匹配" class="headerlink" title="简单模式匹配"></a>简单模式匹配</h3><p>相当于java中的switch语句</p>
<p>语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">变量 match &#123;</span><br><span class="line">    case &quot;常量1&quot; =&gt; 表达式1</span><br><span class="line">    case &quot;常量2&quot; =&gt; 表达式2</span><br><span class="line">    case &quot;常量3&quot; =&gt; 表达式3</span><br><span class="line">    case _ =&gt; 表达式4		// 默认匹配</span><br><span class="line">&#125;</span><br><span class="line">object Demo1 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val str = StdIn.readLine()   //从键盘录入</span><br><span class="line"></span><br><span class="line">    val unit = str match &#123;</span><br><span class="line">      case &quot;hadoop&quot; =&gt; &quot;nicai&quot;</span><br><span class="line">      case &quot;spaker&quot; =&gt; &quot;分布式计算框架&quot;</span><br><span class="line">      case _ =&gt; &quot;未匹配&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><p>根据不同的数据类型进行匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">变量 match &#123;</span><br><span class="line">    case 类型1变量名: 类型1 =&gt; 表达式1</span><br><span class="line">    case 类型2变量名: 类型2 =&gt; 表达式2</span><br><span class="line">    case 类型3变量名: 类型3 =&gt; 表达式3</span><br><span class="line">    ...</span><br><span class="line">    case _ =&gt; 表达式4</span><br><span class="line">&#125;</span><br><span class="line">object Demo2 &#123;</span><br><span class="line">  var  a:Any=&quot;hadoop&quot;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val unit = a match &#123;</span><br><span class="line">      case x: String =&gt; s&quot;$&#123;x&#125;字符串&quot;   //若后面没有用到这个变量 可以写为 _:String</span><br><span class="line">      case x: Int =&gt; &quot;整形&quot;</span><br><span class="line">      case x: Double =&gt; &quot;浮点型&quot;</span><br><span class="line">      case _ =&gt; &quot;没匹配&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守卫"><a href="#守卫" class="headerlink" title="守卫"></a>守卫</h3><p>在Java中，只能简单地添加多个case标签，例如：要匹配0-7，就需要写出来8个case语句。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">switch(a) &#123;</span><br><span class="line">    case 0: a += 1;</span><br><span class="line">    case 1: a += 1;</span><br><span class="line">    case 2: a += 1;</span><br><span class="line">    case 3: a += 1;</span><br><span class="line">    case 4: a += 2;</span><br><span class="line">    case 5: a += 2;</span><br><span class="line">    case 6: a += 2;</span><br><span class="line">    case 7: a += 2;</span><br><span class="line">    default: a = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在scala中，可以使用守卫来简化上述代码——也就是在<strong>case语句中添加if条件判断</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">object Demo3 &#123;</span><br><span class="line">    private val i: Int = StdIn.readInt()</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val unit = i match &#123;</span><br><span class="line">      case x if x &gt; 0 &amp;&amp; x &lt; 3 =&gt; &quot;0-3&quot;   </span><br><span class="line">      case x if x &gt; 3 &amp;&amp; x &lt; 10 =&gt; println(&quot;3-10&quot;)  //若这样鞋  则0-3 之后会打印()</span><br><span class="line">      case x if x &gt; 10 &amp;&amp; x &lt; 13 =&gt; println(&quot;10-13&quot;)</span><br><span class="line">      case _ =&gt; println(&quot;weipi&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配样例类"><a href="#匹配样例类" class="headerlink" title="匹配样例类"></a>匹配样例类</h3><p>scala可以使用模式匹配来匹配样例类，从而可以快速获取样例类中的成员数据。后续，我们在开发Akka案例时，还会用到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object Demo4 &#123;</span><br><span class="line">  case class Per(name:String,age:Int)</span><br><span class="line">  case class Stu(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val ni:Any = Per(&quot;ni&quot;,55)              //若不为any则会报错</span><br><span class="line">    val unit = ni match &#123;</span><br><span class="line">      case Per(name, age) =&gt; s&quot;$&#123;name&#125;:$&#123;age&#125;per&quot;</span><br><span class="line">      case Stu(name, age) =&gt; s&quot;$&#123;name&#125;:$&#123;age&#125;stu&quot;</span><br><span class="line">      case _ =&gt; &quot;未匹配&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配集合"><a href="#匹配集合" class="headerlink" title="匹配集合"></a>匹配集合</h3><p>1 匹配数组</p>
<ul>
<li><p>依次修改代码定义以下三个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array(1,x,y)   // 以1开头，后续的两个元素不固定</span><br><span class="line">Array(0)       // 只匹配一个0元素的元素</span><br><span class="line">Array(0, ...)  // 可以任意数量，但是以0开头</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式匹配上述数组</p>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val arr = Array(1, 3, 5)</span><br><span class="line">arr match &#123;</span><br><span class="line">    case Array(1, x, y) =&gt; println(x + &quot; &quot; + y)</span><br><span class="line">    case Array(0) =&gt; println(&quot;only 0&quot;)</span><br><span class="line">    case Array(0, _*) =&gt; println(&quot;0 ...&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;something else&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2匹配列表</p>
<ul>
<li><p>依次修改代码定义以下三个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List(0)                // 只保存0一个元素的列表</span><br><span class="line">List(0,...)           // 以0开头的列表，数量不固定</span><br><span class="line">List(x,y)               // 只包含两个元素的列表</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式匹配上述列表</p>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val list = List(0, 1, 2)</span><br><span class="line"></span><br><span class="line">list match &#123;</span><br><span class="line">    case 0 :: Nil =&gt; println(&quot;只有0的列表&quot;)</span><br><span class="line">    case 0 :: tail =&gt; println(&quot;0开头的列表&quot;)</span><br><span class="line">    case x :: y :: Nil =&gt; println(s&quot;只有另两个元素$&#123;x&#125;, $&#123;y&#125;的列表&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;未匹配&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 匹配元组</p>
<ul>
<li><p>依次修改代码定义以下两个元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1, x, y)        // 以1开头的、一共三个元素的元组</span><br><span class="line">(x, y, 5)   // 一共有三个元素，最后一个元素为5的元组</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用模式匹配上述元素</p>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val tuple = (2, 2, 5)</span><br><span class="line"></span><br><span class="line">tuple match &#123;</span><br><span class="line">    case (1, x, y) =&gt; println(s&quot;三个元素，1开头的元组：1, $&#123;x&#125;, $&#123;y&#125;&quot;)</span><br><span class="line">    case (x, y, 5) =&gt; println(s&quot;三个元素，5结尾的元组：$&#123;x&#125;, $&#123;y&#125;, 5&quot;)</span><br><span class="line">    case _ =&gt; println(&quot;未匹配&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量声明中的模式匹配"><a href="#变量声明中的模式匹配" class="headerlink" title="变量声明中的模式匹配"></a>变量声明中的模式匹配</h3><p>在定义变量的时候，可以使用模式匹配快速获取数据。</p>
<p>1 获取数组中的元素</p>
<ul>
<li>生成包含0-10数字的数组，使用模式匹配分别获取第二个、第三个、第四个元素</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.matchdemo</span><br><span class="line">//变量声明中的模式匹配</span><br><span class="line">object Demo8 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var array=(0 to 10).toArray</span><br><span class="line">    var Array(_,x,y,z,_*)=array</span><br><span class="line">    println(x)  //1</span><br><span class="line">    println(y)  //2</span><br><span class="line">    println(z)   //3</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 获取列表中的数据</p>
<ul>
<li>生成包含0-10数字的列表，使用模式匹配分别获取第一个、第二个元素</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.matchdemo</span><br><span class="line">//变量声明中的模式匹配</span><br><span class="line">object Demo9 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var a= (0 to 10).toList</span><br><span class="line">    var x :: y :: tail =a</span><br><span class="line"></span><br><span class="line">    println(x) //0</span><br><span class="line">    println(y)  //1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="option类型"><a href="#option类型" class="headerlink" title="option类型"></a>option类型</h3><p>scala中，Option类型来表示可选值。这种类型的数据有两种形式：</p>
<p>Some(x)：表示实际的值</p>
<p>None：表示没有值</p>
<p>使用Option类型，可以用来有效避免空引用(null)异常。也就是说，将来我们返回某些数据时，可以返回一个Option类型来替代。</p>
<p>getOrElse方法</p>
<p>使用getOrElse方法，当Option对应的实例是None时，可以指定一个默认值，从而避免空指针异常</p>
<ol>
<li>scala鼓励使用Option类型来封装数据，可以有效减少，在代码中判断某个值是否为null</li>
<li>可以使用getOrElse方法来针对None返回一个默认值</li>
</ol>
<p>例子一</p>
<ul>
<li>定义一个两个数相除的方法，使用Option类型来封装结果</li>
<li>然后使用模式匹配来打印结果<ul>
<li>不是除零，打印结果</li>
<li>除零打印异常错误</li>
</ul>
</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> package com.nicai.demo.matchdemo</span><br><span class="line"></span><br><span class="line">object Demo10 &#123;</span><br><span class="line">  def div(a:Double,b:Int): Option[Double] =&#123;</span><br><span class="line">    if (b != 0)&#123;</span><br><span class="line">      Some(a/b)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      None</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val option = div(15.2,2)</span><br><span class="line">    val unit = option match &#123;</span><br><span class="line">      case Some(x) =&gt; x</span><br><span class="line">      case None =&gt; &quot;除数不可为0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)  //7.6</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子二</p>
<ul>
<li>重写上述案例，使用getOrElse方法，当除零时，或者默认值为0</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.matchdemo</span><br><span class="line"></span><br><span class="line">object Demo11 &#123;</span><br><span class="line">  def div(a: Double, b: Int):Option[Double]= &#123;</span><br><span class="line">    if( b != 0)&#123;</span><br><span class="line">      Some(a/b)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      None</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val d = div(15.6,0).getOrElse(0)</span><br><span class="line">    println(d)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>偏函数可以提供了简洁的语法，可以简化函数的定义。配合集合的函数式编程，可以让代码更加优雅。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>偏函数被包在花括号内没有match的一组case语句是一个偏函数</li>
<li>偏函数是PartialFunction[A, B]的一个实例<ul>
<li>A代表输入参数类型</li>
<li>B代表返回结果类型</li>
</ul>
</li>
</ul>
<p>可以理解为：偏函数是一个参数和一个返回值的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.PartialFunctionDemo</span><br><span class="line"></span><br><span class="line">object Demo12 &#123;</span><br><span class="line"></span><br><span class="line">  private val value: PartialFunction[Int, String] = &#123;</span><br><span class="line">    case 1 =&gt; &quot;一&quot;</span><br><span class="line">    case 2 =&gt; &quot;二&quot;</span><br><span class="line">    case _ =&gt; &quot;其他&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(value(1))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个列表，包含1-10的数字</li>
<li>请将1-3的数字都转换为[1-3]</li>
<li>请将4-8的数字都转换为[4-8]</li>
<li>将其他的数字转换为(8-*]</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val list = (1 to 10).toList</span><br><span class="line"></span><br><span class="line">val list2 = list.map&#123;</span><br><span class="line">    case x if x &gt;= 1 &amp;&amp; x &lt;= 3 =&gt; &quot;[1-3]&quot;</span><br><span class="line">    case x if x &gt;= 4 &amp;&amp; x &lt;= 8 =&gt; &quot;[4-8]&quot;</span><br><span class="line">    case x if x &gt; 8 =&gt; &quot;(8-*]&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(list2)</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>在scala中，可以很方便地使用正则表达式来匹配数据。</p>
<p>scala中提供了Regex类来定义正则表达式，要构造一个RegEx对象，直接使用String类的r方法即可。</p>
<p>建议使用三个双引号来表示正则表达式，不然就得对正则中的反斜杠来进行转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val regEx = &quot;&quot;&quot;正则表达式&quot;&quot;&quot;.r</span><br></pre></td></tr></table></figure>

<p>findAllMatchIn方法</p>
<p>使用findAllMatchIn方法可以获取所有正则匹配到的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例说明</span><br><span class="line"></span><br><span class="line">定义一个正则表达式，来匹配邮箱是否合法</span><br><span class="line">合法邮箱测试：qq12344@163.com</span><br><span class="line">不合法邮箱测试：qq12344@.com</span><br><span class="line">val r = &quot;&quot;&quot;.+@.+\..+&quot;&quot;&quot;.r</span><br><span class="line"></span><br><span class="line">val eml1 = &quot;qq12344@163.com&quot;</span><br><span class="line">val eml2 = &quot;qq12344@.com&quot;</span><br><span class="line"></span><br><span class="line">if(r.findAllMatchIn(eml1).size &gt; 0) &#123;  //z\size  为0 没有匹配上  大于0 为匹配上</span><br><span class="line">    println(eml1 + &quot;邮箱合法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    println(eml1 + &quot;邮箱不合法&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(r.findAllMatchIn(eml2).size &gt; 0) &#123;</span><br><span class="line">    println(eml2 + &quot;邮箱合法&quot;)</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    println(eml2 + &quot;邮箱不合法&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找出以下列表中的所有不合法的邮箱</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;</span><br><span class="line">package com.nicai.demo.zhengzebiaodashi</span><br><span class="line">//匹配多个邮箱</span><br><span class="line">object Demo15 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    var a= List(&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;)</span><br><span class="line"></span><br><span class="line">    val r=&quot;&quot;&quot;.+@.+\.com&quot;&quot;&quot;.r</span><br><span class="line">    val strings = a.filter &#123;</span><br><span class="line">      //过滤出不合法的</span><br><span class="line">      case x if r.findAllMatchIn(x).size == 0 =&gt; true</span><br><span class="line">      case _ =&gt; false</span><br><span class="line">    &#125;</span><br><span class="line">    println(strings)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有以下邮箱列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用正则表达式进行模式匹配，匹配出来邮箱运营商的名字。例如：邮箱<a href="mailto:zhansan@163.com" target="_blank" rel="noopener">zhansan@163.com</a>，需要将163匹配出来</p>
<ul>
<li>使用括号来匹配分组</li>
</ul>
</li>
<li><p>打印匹配到的邮箱以及运营商</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.zhengzebiaodashi</span><br><span class="line"></span><br><span class="line">object Demo16 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    //括号为分组</span><br><span class="line">    val re =&quot;&quot;&quot;.+@(.+)\.com&quot;&quot;&quot;.r   //此处必为 val</span><br><span class="line">    var li=List(&quot;38123845@qq.com&quot;, &quot;a1da88123f@gmail.com&quot;, &quot;zhansan@163.com&quot;, &quot;123afadff.com&quot;)</span><br><span class="line">    val strings = li.map &#123;</span><br><span class="line">      //company为分组的名字  就是分组的字段</span><br><span class="line">      case x@re(company) =&gt; s&quot;$&#123;x&#125; -&gt; $&#123;company&#125;&quot;</span><br><span class="line">      case x =&gt; s&quot;$&#123;x&#125; + 未知&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(strings)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>来看看下面一段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">   val i = 10 / 0</span><br><span class="line"></span><br><span class="line">    println(&quot;你好！&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at ForDemo$.main(ForDemo.scala:3)</span><br><span class="line">    at ForDemo.main(ForDemo.scala)</span><br></pre></td></tr></table></figure>

<p>执行程序，可以看到scala抛出了异常，而且没有打印出来”你好”。说明程序出现错误后就终止了。</p>
<p>那怎么解决该问题呢？</p>
<p>在scala中，可以使用异常处理来解决这个问题</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br><span class="line">catch &#123;</span><br><span class="line">    case ex:异常类型1 =&gt; // 代码</span><br><span class="line">    case ex:异常类型2 =&gt; // 代码</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">    // 代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>try中的代码是我们编写的业务处理代码</li>
<li>在catch中表示当出现某个异常时，需要执行的代码</li>
<li>在finally中，是不管是否出现异常都会执行的代码</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例说明</strong></p>
<ul>
<li>使用try..catch来捕获除零异常</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.exceptionDemo</span><br><span class="line"></span><br><span class="line">object Demo17 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      var a= 4/0</span><br><span class="line">    &#125;catch &#123;</span><br><span class="line">      case ex:Exception =&gt; println(ex.getMessage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###抛出异常</p>
<p>我们也可以在一个方法中，抛出异常。语法格式和Java类似，使用<code>throw new Exception...</code></p>
<p>例子:</p>
<ul>
<li>在main方法中抛出一个异常</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> package com.nicai.demo.exceptionDemo</span><br><span class="line"></span><br><span class="line">object Demo18 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    throw new Exception(&quot;这是一个异常&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.Exception: 这是一个异常</span><br><span class="line">    at ForDemo$.main(ForDemo.scala:3)</span><br><span class="line">    at ForDemo.main(ForDemo.scala)</span><br></pre></td></tr></table></figure>

<ul>
<li>scala不需要在方法上声明要抛出的异常，它已经解决了再Java中被认为是设计失败的检查型异常。</li>
</ul>
<p>下面是Java代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    throw new Exception(&quot;这是一个异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提取器"><a href="#提取器" class="headerlink" title="提取器"></a>提取器</h2><p>我们之前已经使用过scala中非常强大的模式匹配功能了，通过模式匹配，我们可以快速匹配样例类中的成员变量.</p>
<p>那是不是所有的类都可以进行这样的模式匹配呢？答案是：</p>
<p><code>不可以</code>的。要支持模式匹配，必须要实现一个<strong>提取器</strong>。</p>
<p><strong>样例类自动实现了apply、unapply方法</strong></p>
<h2 id="定义提取器"><a href="#定义提取器" class="headerlink" title="定义提取器"></a>定义提取器</h2><p>之前我们学习过了，实现一个类的伴生对象中的apply方法，可以用类名来快速构建一个对象。伴生对象中，还有一个unapply方法。与apply相反，unapply是将该类的对象，拆解为一个个的元素。</p>
<p>要实现一个类的提取器，只需要在该类的伴生对象中实现一个unapply方法即可</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def unapply(stu:Student):Option[(类型1, 类型2, 类型3...)] = &#123;</span><br><span class="line">    if(stu != null) &#123;</span><br><span class="line">        Some((变量1, 变量2, 变量3...))</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例说明</strong></p>
<ul>
<li>创建一个Student类，包含姓名年龄两个字段</li>
<li>实现一个类的解构器，并使用match表达式进行模式匹配，提取类中的字段。</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.tiquqi</span><br><span class="line"></span><br><span class="line">object Demo19 &#123;</span><br><span class="line">  class Stu(var name:String,var age:Int)</span><br><span class="line">  object Stu&#123;</span><br><span class="line">    def apply(name: String, age: Int): Stu = new Stu(name, age)</span><br><span class="line"></span><br><span class="line">    def unapply(stu :Stu) = &#123;</span><br><span class="line">      val tuple =(stu.name,stu.age)</span><br><span class="line">      Some(tuple)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val nicai = Stu(&quot;nicai&quot;,55)</span><br><span class="line">    val unit = nicai match &#123;</span><br><span class="line">      case Stu(name, age) =&gt; s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    println(unit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>scala和Java一样，类和特质、方法都可以支持泛型。我们在学习集合的时候，一般都会涉及到泛型。</p>
<h2 id="定义一个泛型方法"><a href="#定义一个泛型方法" class="headerlink" title="定义一个泛型方法"></a>定义一个泛型方法</h2><p>在scala中，使用方括号来定义类型参数。</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 方法名[泛型名称](..) = &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例说明</strong></p>
<ul>
<li>用一个方法来获取任意类型数组的中间的元素<ul>
<li>不考虑泛型直接实现（基于Array[Int]实现）</li>
<li>加入泛型支持</li>
</ul>
</li>
</ul>
<p><strong>参考代码</strong></p>
<p>不考虑泛型的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def getMiddle(arr:Array[Int]) = arr(arr.length / 2)</span><br><span class="line"></span><br><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">  val arr1 = Array(1,2,3,4,5)</span><br><span class="line"></span><br><span class="line">  println(getMiddle(arr1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入泛型支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line">object Demo20 &#123;</span><br><span class="line">  def getMid[T](array: Array[T])= array(array.length/2)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(getMid(Array(1, 2, 3)))</span><br><span class="line">    println(getMid(Array(&quot;dd&quot;, &quot;uu&quot;, &quot;sss&quot;)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##泛型类</p>
<p>scala的类也可以定义泛型。接下来，我们来学习如何定义scala的泛型类</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类[T](val 变量名: T)</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个泛型类，直接在类名后面加上方括号，指定要使用的泛型参数</li>
<li>指定类对应的泛型参数后，就使用这些类型参数来定义变量了</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line">object Demo21 &#123;</span><br><span class="line">  case class Per[y] (name:y,age:y)</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val list = List(</span><br><span class="line">      Per(&quot;NJJS&quot;, 45),</span><br><span class="line">      Per(&quot;jsjj&quot;, 789),</span><br><span class="line">      Per(56456, &quot;SSS&quot;)</span><br><span class="line">    )</span><br><span class="line">    println(list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上下界"><a href="#上下界" class="headerlink" title="上下界"></a>上下界</h2><p>需求：</p>
<p>我们在定义方法/类的泛型时，限定必须从哪个类继承、或者必须是哪个类的父类。此时，就需要使用到上下界。</p>
<p><strong>上界定义:</strong></p>
<p>使用<code>&lt;: 类型名</code>表示给类型添加一个<strong>上界</strong>，表示泛型参数必须要从该类（或本身）继承</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[T &lt;: 类型]</span><br></pre></td></tr></table></figure>

<p><strong>示例说明</strong></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line">object Demo22 &#123;</span><br><span class="line">   //上界</span><br><span class="line">  class  Per</span><br><span class="line">  class Stu extends Per</span><br><span class="line">  class Man extends Stu</span><br><span class="line">  def m[t &lt;: Stu](a:Array[t]) = println(a)   //Per 本身及其子类</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    // 编译报错</span><br><span class="line">   // m(Array(new Per))</span><br><span class="line">    m(Array(new Stu))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下界</strong></p>
<p>上界是要求必须是某个类的子类，或者必须从某个类继承，而下界是必须是<strong>某个类的父类</strong>（或本身）</p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[T &gt;: 类型]</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>如果类既有上界、又有下界。下界写在前面，上界写在后面 (同时又上下界,可能会守不住,即范围之外的也可以)</p>
<p><strong>示例说明</strong></p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.fanxing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object Demo23 &#123;</span><br><span class="line">//下界</span><br><span class="line"></span><br><span class="line">  class  Per</span><br><span class="line">  class Stu extends Per</span><br><span class="line">  class Man extends Stu</span><br><span class="line">  def m[T &gt;: Stu](a:Array[T])= println(a)  //Stu  本身及其父类</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    m(Array(new Stu))</span><br><span class="line">    m(Array(new Per))</span><br><span class="line">    //会报错</span><br><span class="line">    //m(Array(new Man))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协变-逆变-非变"><a href="#协变-逆变-非变" class="headerlink" title="协变 逆变 非变"></a>协变 逆变 非变</h2><p>spark的源代码中大量使用到了协变、逆变、非变，学习该知识点对我们将来阅读spark源代码很有帮助。</p>
<p>来看一个类型转换的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Pair[T]</span><br><span class="line"></span><br><span class="line">object Pair &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val p1 = Pair(&quot;hello&quot;)</span><br><span class="line">    // 编译报错，无法将p1转换为p2</span><br><span class="line">    val p2:Pair[AnyRef] = p1</span><br><span class="line"></span><br><span class="line">    println(p2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何让带有泛型的类支持类型转换呢？</p>
<p><strong>非变</strong></p>
<p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Pair[T]&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认泛型类是非变的</li>
<li>类型B是A的子类型，Pair[A]和Pair[B]没有任何从属关系</li>
<li>Java是一样的</li>
</ul>
<p><a href="https://manzhong.github.io/images/scala/fxn.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/fxn.png" alt="img"></a></p>
<h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Pair[+T]</span><br></pre></td></tr></table></figure>

<ul>
<li>类型B是A的子类型，Pair[B]可以认为是Pair[A]的子类型</li>
<li>参数化类型的方向和类型的方向是一致的。</li>
</ul>
<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p><strong>语法格式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Pair[-T]</span><br></pre></td></tr></table></figure>

<ul>
<li>类型B是A的子类型，Pair[A]反过来可以认为是Pair[B]的子类型</li>
<li>参数化类型的方向和类型的方向是相反的</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Super</span><br><span class="line">class Sub extends Super</span><br><span class="line"></span><br><span class="line">class Temp1[T]</span><br><span class="line">class Temp2[+T]</span><br><span class="line">class Temp3[-T]</span><br><span class="line"></span><br><span class="line">def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val a:Temp1[Sub] = new Temp1[Sub]</span><br><span class="line">    // 编译报错</span><br><span class="line">    // 非变</span><br><span class="line">    //val b:Temp1[Super] = a</span><br><span class="line"></span><br><span class="line">    // 协变</span><br><span class="line">    val c: Temp2[Sub] = new Temp2[Sub]</span><br><span class="line">    val d: Temp2[Super] = c</span><br><span class="line"></span><br><span class="line">    // 逆变</span><br><span class="line">    val e: Temp3[Super] = new Temp3[Super]</span><br><span class="line">    val f: Temp3[Sub] = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Actor并发编程"><a href="#Actor并发编程" class="headerlink" title="Actor并发编程"></a>Actor并发编程</h2><p>scala的Actor并发编程模型可以用来开发比Java线程效率更高的并发程序。我们学习scala Actor的目的主要是为后续学习Akka做准备。</p>
<h2 id="Java并发编程的问题"><a href="#Java并发编程的问题" class="headerlink" title="Java并发编程的问题"></a>Java并发编程的问题</h2><p>在Java并发编程中，每个对象都有一个逻辑监视器（monitor），可以用来控制对象的多线程访问。我们添加sychronized关键字来标记，需要进行同步加锁访问。这样，通过加锁的机制来确保同一时间只有一个线程访问共享数据。但这种方式存在资源争夺、以及死锁问题，程序越大问题越麻烦。</p>
<p>思索问题</p>
<p><a href="https://manzhong.github.io/images/scala/xcss.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/xcss.png" alt="img"></a></p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.Demo;</span><br><span class="line"></span><br><span class="line">public class MyLock &#123;</span><br><span class="line">    public static Object obja = new Object();</span><br><span class="line">    public static Object objb = new Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DieLock extends Thread &#123;</span><br><span class="line">    private boolean flag;</span><br><span class="line"></span><br><span class="line">    public DieLock(boolean flag) &#123;</span><br><span class="line">         this.flag=flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            synchronized (MyLock.obja)&#123;</span><br><span class="line">                System.out.println(&quot;a&quot;);</span><br><span class="line">                synchronized (MyLock.objb)&#123;</span><br><span class="line">                    System.out.println(&quot;b&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            synchronized (MyLock.objb)&#123;</span><br><span class="line">                System.out.println(&quot;bb&quot;);</span><br><span class="line">                synchronized (MyLock.obja)&#123;</span><br><span class="line">                    System.out.println(&quot;aa&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DieLock lock1 = new DieLock(true);</span><br><span class="line">        DieLock lock2 = new DieLock(false);</span><br><span class="line">        lock1.start();</span><br><span class="line">        lock2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Artor并发编程模型"><a href="#Artor并发编程模型" class="headerlink" title="Artor并发编程模型"></a>Artor并发编程模型</h3><p>Actor并发编程模型，是scala提供给程序员的一种与Java并发编程完全不一样的并发编程模型，是一种基于事件模型的并发机制。Actor并发编程模型是一种不共享数据，依赖消息传递的一种并发编程模式，有效避免资源争夺、死锁等情况。</p>
<p><a href="https://manzhong.github.io/images/scala/bf.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/bf.png" alt="img"></a></p>
<h3 id="java-并发编程-与Actor并发编程对比"><a href="#java-并发编程-与Actor并发编程对比" class="headerlink" title="java 并发编程 与Actor并发编程对比"></a>java 并发编程 与Actor并发编程对比</h3><table>
<thead>
<tr>
<th align="left">Java内置线程模型</th>
<th align="left">scala Actor模型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“共享数据-锁”模型 (share data and lock)</td>
<td align="left">share nothing</td>
</tr>
<tr>
<td align="left">每个object有一个monitor，监视线程对共享数据的访问</td>
<td align="left">不共享数据，Actor之间通过Message通讯</td>
</tr>
<tr>
<td align="left">加锁代码使用synchronized标识</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">死锁问题</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">每个线程内部是顺序执行的</td>
<td align="left">每个Actor内部是顺序执行的</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<p>scala在2.11.x版本中加入了Akka并发编程框架，老版本已经废弃。Actor的编程模型和Akka很像，我们这里学习Actor的目的是为学习Akka做准备。</p>
<h3 id="创建Actor"><a href="#创建Actor" class="headerlink" title="创建Actor"></a>创建Actor</h3><p>创建Actor的方式和Java中创建线程很类似，也是通过继承来创建。</p>
<p>使用方式</p>
<ol>
<li>定义class或object继承Actor特质</li>
<li>重写act方法</li>
<li>调用Actor的start方法执行Actor</li>
</ol>
<p>类似于Java线程，这里的每个Actor是并行执行的</p>
<p><strong>示例说明</strong></p>
<p>创建两个Actor，一个Actor打印1-10，另一个Actor打印11-20</p>
<ul>
<li>使用class继承Actor创建（如果需要在程序中创建多个相同的Actor）</li>
<li>使用object继承Actor创建（如果在程序中只创建一个Actor）</li>
</ul>
<p><strong>参考代码</strong></p>
<p>使用class继承Actor创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object _05ActorDemo &#123;</span><br><span class="line">  class Actor1 extends Actor &#123;</span><br><span class="line">    override def act(): Unit = (1 to 10).foreach(println(_))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Actor2 extends Actor &#123;</span><br><span class="line">    override def act(): Unit = (11 to 20).foreach(println(_))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    new Actor1().start()</span><br><span class="line">    new Actor2().start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用object继承Actor创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo26 &#123;</span><br><span class="line">  object  A1 extends Actor&#123;</span><br><span class="line">    override def act(): Unit = (1 to 10).foreach(println(_)+&quot;,&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  object A2 extends Actor &#123;</span><br><span class="line">    override def act(): Unit = (11 to 20).foreach(print(_)+&quot;,&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    A1.start()</span><br><span class="line">     A2.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Actor程序运行流程"><a href="#Actor程序运行流程" class="headerlink" title="Actor程序运行流程"></a>Actor程序运行流程</h2><ol>
<li>调用start()方法启动Actor</li>
<li>自动执行<strong>act</strong>()方法</li>
<li>向Actor发送消息</li>
<li>act方法执行完成后，程序会调用<strong>exit()</strong>方法</li>
</ol>
<h3 id="发送消息-与接收消息"><a href="#发送消息-与接收消息" class="headerlink" title="发送消息 与接收消息"></a>发送消息 与接收消息</h3><p>我们之前介绍Actor的时候，说过Actor是基于事件（消息）的并发编程模型，那么Actor是如何发送消息和接收消息的呢？</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p><strong>发送消息</strong></p>
<p>我们可以使用三种方式来发送消息：</p>
<table>
<thead>
<tr>
<th align="left"><strong>！</strong></th>
<th align="left"><strong>发送异步消息，没有返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>!?</strong></td>
<td align="left"><strong>发送同步消息，等待返回值</strong></td>
</tr>
<tr>
<td align="left"><strong>!!</strong></td>
<td align="left"><strong>发送异步消息，返回值是Future[Any]</strong></td>
</tr>
</tbody></table>
<p>例如：</p>
<p>要给actor1发送一个异步字符串消息，使用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actor1 ! &quot;你好!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>接收消息</strong></p>
<p>Actor中使用receive方法来接收消息，需要给receive方法传入一个偏函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    case 变量名1:消息类型1 =&gt; 业务处理1,</span><br><span class="line">    case 变量名2:消息类型2 =&gt; 业务处理2,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>receive方法只接收一次消息，接收完后继续执行act方法</p>
<p><strong>示例说明</strong></p>
<ul>
<li>创建两个Actor（ActorSender、ActorReceiver）</li>
<li>ActorSender发送一个异步字符串消息给ActorReceiver</li>
<li>ActorReceive接收到该消息后，打印出来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo27 &#123;</span><br><span class="line">//发送消息 与 接收消息</span><br><span class="line">//发送</span><br><span class="line">  object  MsgSender extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      MsgReceiver ! &quot;nicai&quot;    //给谁发消息</span><br><span class="line">      TimeUnit.SECONDS.sleep(3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //接收</span><br><span class="line">  object MsgReceiver extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      receive&#123;</span><br><span class="line">        case msg: String =&gt; println(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgSender.start()</span><br><span class="line">    MsgReceiver.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="持续接收消息"><a href="#持续接收消息" class="headerlink" title="持续接收消息"></a>持续接收消息</h3><p>通过上一个案例，ActorReceiver调用receive来接收消息，但接收一次后，Actor就退出了。</p>
<p>我们希望ActorReceiver能够一直接收消息，怎么实现呢？</p>
<p>——我们只需要使用一个while(true)循环，不停地调用receive来接收消息就可以啦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo27 &#123;</span><br><span class="line">//发送消息 与 接收消息</span><br><span class="line">//发送</span><br><span class="line">  object  MsgSender extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      MsgReceiver ! &quot;nicai&quot;</span><br><span class="line">      TimeUnit.SECONDS.sleep(3)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //接收</span><br><span class="line">  object MsgReceiver extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      receive&#123;</span><br><span class="line">        case msg: String =&gt; println(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgSender.start()</span><br><span class="line">    MsgReceiver.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用loop和react-优化接收消息"><a href="#使用loop和react-优化接收消息" class="headerlink" title="使用loop和react 优化接收消息"></a>使用loop和react 优化接收消息</h3><p>上述代码，使用while循环来不断接收消息。</p>
<ul>
<li>如果当前Actor没有接收到消息，线程就会处于阻塞状态</li>
<li>如果有很多的Actor，就有可能会导致很多线程都是处于阻塞状态</li>
<li>每次有新的消息来时，重新创建线程来处理</li>
<li>频繁的线程创建、销毁和切换，会影响运行效率</li>
</ul>
<p>在scala中，可以使用loop + react来复用线程。比while + receive更高效</p>
<p>使用loop + react重写上述案例</p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 持续接收消息</span><br><span class="line">loop &#123;</span><br><span class="line">    react &#123;</span><br><span class="line">        case msg:String =&gt; println(&quot;接收到消息：&quot; + msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改写:</span><br><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo29 &#123;</span><br><span class="line">  object MsgSender extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      while(true)&#123;</span><br><span class="line">        MsgReceice ! &quot;NICAII&quot;</span><br><span class="line">        TimeUnit.SECONDS.sleep(3)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  object MsgReceice extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      loop&#123;</span><br><span class="line">        react&#123;</span><br><span class="line">          case msg :String =&gt; println(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgReceice.start()</span><br><span class="line">    MsgSender.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送和接收自定义消息"><a href="#发送和接收自定义消息" class="headerlink" title="发送和接收自定义消息"></a>发送和接收自定义消息</h3><p>我们前面发送的消息是字符串类型，Actor中也支持发送自定义消息，常见的如：使用样例类封装消息，然后进行发送处理。</p>
<p><strong>例子1</strong></p>
<p><strong>示例说明</strong></p>
<ul>
<li>创建一个MsgActor，并向它发送一个同步消息，该消息包含两个字段（id、message）</li>
<li>MsgActor回复一个消息，该消息包含两个字段（message、name）</li>
<li>打印回复消息</li>
</ul>
<p>注意:</p>
<ul>
<li>使用<code>!?</code>来发送同步消息</li>
<li>在Actor的act方法中，可以使用sender获取发送者的Actor引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//同步的方式</span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">//发送和接收自定义消息</span><br><span class="line">object Demo30 &#123;</span><br><span class="line"> //封装发送消息</span><br><span class="line"> case  class Msg(name:String,Age:Int)</span><br><span class="line">  //封装回复消息</span><br><span class="line"> case class ReplyMsg(name:String,addres:String)</span><br><span class="line">  //接收消息</span><br><span class="line">  object MsgActor extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      loop&#123;</span><br><span class="line">        react&#123;</span><br><span class="line">          case Msg(name,age) =&gt;&#123;</span><br><span class="line">            println(&quot;收到消息&quot;+s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;)</span><br><span class="line">            //获取发送者队象 并回复消息</span><br><span class="line">            sender ! ReplyMsg(&quot;wobucai&quot;,&quot;bbb&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgActor.start()</span><br><span class="line">//发送消息 并获取返回的消息</span><br><span class="line">    val unit:Any = MsgActor !? Msg(&quot;nicai&quot;,22)</span><br><span class="line">    //转换 消息类型</span><br><span class="line">    if(unit.isInstanceOf[ReplyMsg])&#123;</span><br><span class="line">      println(&quot;回复消息&quot;+unit.asInstanceOf[ReplyMsg])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例2</strong></p>
<ul>
<li>创建一个MsgActor，并向它发送一个异步无返回消息，该消息包含两个字段（message, company）</li>
<li>使用<code>!</code>发送异步无返回消息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//异步无返回值</span><br><span class="line">import com.nicai.demo.actorDemo.Demo30.Msg</span><br><span class="line">import scala.actors.Actor</span><br><span class="line">object Demo31 &#123;</span><br><span class="line">  //封装 消息</span><br><span class="line">  case class Mag(name:String,age:Int)</span><br><span class="line"></span><br><span class="line">  object  MsgActor extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line">      loop&#123;</span><br><span class="line">        react&#123;</span><br><span class="line">          case Msg(name,age) =&gt; &#123;</span><br><span class="line">            println(s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgActor.start()</span><br><span class="line">    //发送消息</span><br><span class="line">    MsgActor ! Msg(&quot;你猜&quot;,55)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子3</strong></p>
<ul>
<li><p>创建一个MsgActor，并向它发送一个异步有返回消息，该消息包含两个字段（id、message）</p>
</li>
<li><p>MsgActor回复一个消息，该消息包含两个字段（message、name）</p>
</li>
<li><p>打印回复消息</p>
<p>注意:</p>
</li>
<li><p>使用<code>!!</code>发送异步有返回消息</p>
</li>
<li><p>发送后，返回类型为Future[Any]的对象</p>
</li>
<li><p>Future表示异步返回数据的封装，虽获取到Future的返回值，但不一定有值，可能在将来某一时刻才会返回消息</p>
</li>
<li><p>Future的isSet()可检查是否已经收到返回消息，apply()方法可获取返回数据</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//异步有返回值</span><br><span class="line">package com.nicai.demo.actorDemo</span><br><span class="line"></span><br><span class="line">import scala.actors.Actor</span><br><span class="line"></span><br><span class="line">object Demo32 &#123;</span><br><span class="line">    //封装发送消息</span><br><span class="line">  case class Msg(name:String ,age: Int)</span><br><span class="line">  //封装返回消息</span><br><span class="line">  case class ReMsg(name:String ,age: Int)</span><br><span class="line"></span><br><span class="line">  //设置接收消息</span><br><span class="line">  object  MsgActor extends Actor&#123;</span><br><span class="line">    override def act(): Unit = &#123;</span><br><span class="line"></span><br><span class="line">        loop&#123;</span><br><span class="line">          react&#123;</span><br><span class="line">            case Msg(name,age) =&gt;&#123;</span><br><span class="line">              println(s&quot;$&#123;name&#125;:$&#123;age&#125;&quot;)</span><br><span class="line">              //返回消息</span><br><span class="line">              sender ! ReMsg(&quot;NICAI&quot;,4564)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    MsgActor.start()</span><br><span class="line"></span><br><span class="line">    val unit = MsgActor !! Msg(&quot;温暖你的空间&quot;,777)</span><br><span class="line">    //if(unit.isInstanceOf[ReMsg])&#123;</span><br><span class="line">      //检查是否已经收到返回消息  apply()方法可获取返回数据</span><br><span class="line">      // 等待所有结果都已返回</span><br><span class="line">    while(!unit.isSet)&#123; &#125;</span><br><span class="line">println(unit.apply().asInstanceOf[ReMsg])</span><br><span class="line">    //&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##WordCount案例</p>
<p>我们要使用Actor并发编程模型实现多文件的单词统计</p>
<p>需求:</p>
<p>给定几个文本文件（文本文件都是以空格分隔的），使用Actor并发编程来统计单词的数量</p>
<p><a href="https://manzhong.github.io/images/scala/wc.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/wc.png" alt="img"></a></p>
<p><strong>实现思路</strong></p>
<ol>
<li>MainActor获取要进行单词统计的文件</li>
<li>根据文件数量创建对应的WordCountActor</li>
<li>将文件名封装为消息发送给WordCountActor</li>
<li>WordCountActor接收消息，并统计单个文件的单词计数</li>
<li>将单词计数结果发送给MainActor</li>
<li>MainActor等待所有的WordCountActor都已经成功返回消息，然后进行结果合并</li>
</ol>
<h2 id="步骤1-获取文件列表"><a href="#步骤1-获取文件列表" class="headerlink" title="步骤1 | 获取文件列表"></a>步骤1 | 获取文件列表</h2><p><strong>实现思路</strong></p>
<p>在main方法中读取指定目录(${project_root_dir}/data/)下的所有文件，并打印所有的文件名</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建用于测试的数据文件</li>
<li>加载工程根目录，获取到所有文件</li>
<li>将每一个文件名，添加目录路径</li>
<li>打印所有文件名</li>
</ol>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取文件目录</span><br><span class="line">   // val DIR=&quot;G:\\develop\\bigdatas\\BigData\\day22Scala3\\data/&quot;</span><br><span class="line">    val DIR=&quot;day22Scala3/data/&quot;   //当为maven的子工程时 不可使用 &quot;./data/&quot;</span><br><span class="line">    //获取文件流</span><br><span class="line">    val list = new File(DIR).list().toList</span><br><span class="line">    //把每个文件加上前缀 形成完整路径</span><br><span class="line">    val pathAll = list.map(DIR + _)</span><br><span class="line">    println(pathAll)</span><br></pre></td></tr></table></figure>

<h2 id="步骤2-创建WordCountActor"><a href="#步骤2-创建WordCountActor" class="headerlink" title="步骤2 | 创建WordCountActor"></a>步骤2 | 创建WordCountActor</h2><p><strong>实现思路</strong></p>
<p>根据文件数量创建WordCountActor，为了方便后续发送消息给Actor，将每个Actor与文件名关联在一起</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建WordCountActor</li>
<li>将文件列表转换为WordCountActor</li>
<li>为了后续方便发送消息给Actor，将Actor列表和文件列表拉链到一起</li>
<li>打印测试</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取wordcountList</span><br><span class="line"> val wordCountList = list.map &#123;</span><br><span class="line">   fileNmae =&gt; new WordCountActor()</span><br><span class="line"> &#125;</span><br><span class="line"> //每个 文件路径与 wordcount建立连接</span><br><span class="line"> val tuplesList = wordCountList.zip(pathAll)</span><br><span class="line"> println(tuplesList)</span><br></pre></td></tr></table></figure>

<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class WordCountActor extends Actor&#123;</span><br><span class="line">  override def act(): Unit = &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤3-启动Actor-发送-接收任务消息"><a href="#步骤3-启动Actor-发送-接收任务消息" class="headerlink" title="步骤3 | 启动Actor/发送/接收任务消息"></a>步骤3 | 启动Actor/发送/接收任务消息</h2><p><strong>实现思路</strong></p>
<p>启动所有WordCountActor，并发送单词统计任务消息给每个WordCountActor</p>
<p><strong>注意</strong></p>
<p>此处应发送异步有返回消息</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建一个WordCountTask样例类消息，封装要进行单词计数的文件名</li>
<li>启动所有WordCountTask，并发送异步有返回消息</li>
<li>获取到所有的WordCount中获取到的消息（封装到一个Future列表中）</li>
<li>在WordCountActor中接收并打印消息</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//启动 actor /发送和接收消息</span><br><span class="line">   tuplesList.map&#123;</span><br><span class="line">     actorFileName =&gt;&#123;</span><br><span class="line">       val actor = actorFileName._1</span><br><span class="line">       actor.start()</span><br><span class="line">       val future = actor !! Msg(actorFileName._2)</span><br><span class="line">       future</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>MessagePackage.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 单词统计任务消息</span><br><span class="line">  * @param fileName 文件名</span><br><span class="line">  */</span><br><span class="line">case class Msg(name:String)</span><br></pre></td></tr></table></figure>

<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class WordCountActor extends Actor&#123;</span><br><span class="line">  override def act(): Unit = &#123;</span><br><span class="line">    loop&#123;</span><br><span class="line">      react&#123;</span><br><span class="line">        //获取消息</span><br><span class="line">        case Msg(fileName) =&gt; println(&quot;对&quot;+fileName+&quot;进行单词统计&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤4-消息统计文件单词计数"><a href="#步骤4-消息统计文件单词计数" class="headerlink" title="步骤4 | 消息统计文件单词计数"></a>步骤4 | 消息统计文件单词计数</h2><p><strong>实现思路</strong></p>
<p>读取文件文本，并统计出来单词的数量。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(hadoop, 3), (spark, 1)...</span><br></pre></td></tr></table></figure>

<p><strong>实现步骤</strong></p>
<ol>
<li>读取文件内容，并转换为列表</li>
<li>按照空格切割文本，并转换为一个一个的单词</li>
<li>为了方便进行计数，将单词转换为元组</li>
<li>按照单词进行分组，然后再进行聚合统计</li>
<li>打印聚合统计结果</li>
</ol>
<p><strong>参考代码</strong></p>
<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class WordCountActor extends Actor&#123;</span><br><span class="line">  override def act(): Unit = &#123;</span><br><span class="line">    loop&#123;</span><br><span class="line">      react&#123;</span><br><span class="line">        //获取消息</span><br><span class="line">        case Msg(fileName) =&gt; println(&quot;对&quot;+fileName+&quot;进行单词统计&quot;)</span><br><span class="line">          //一 读取文件 获取列表  hadoop sqoop hadoop</span><br><span class="line">        val wordLineList = Source.fromFile(fileName).getLines().toList</span><br><span class="line">          //二 切割字符串,转换为一个一个的单词[hadoop, sqoop, hadoop]</span><br><span class="line">        val wordList = wordLineList.flatMap(_.split(&quot; &quot;))</span><br><span class="line">          //三将单词转换为元组  [&lt;hadoop,1&gt;, &lt;sqoop,1&gt;, &lt;hadoop,1&gt;]</span><br><span class="line">        val wordAndCountList = wordList.map(_ -&gt; 1)</span><br><span class="line">          // 四 对其进行分组 聚合计算</span><br><span class="line">        //4.1 分组 &#123;hadoop-&gt;List(&lt;hadoop,1&gt;,&lt;hadoop,1&gt;), sqoop-&gt;List(&lt;sqoop,1&gt;)&#125;</span><br><span class="line">        val wordGroubList = wordAndCountList.groupBy(_._1)</span><br><span class="line">          //4.2 聚合  &#123;hadoop-&gt;2, sqoop-&gt;1&#125;</span><br><span class="line">        var wordSum=wordGroubList.map&#123;</span><br><span class="line">          keyValue =&gt;</span><br><span class="line">            keyValue._1 -&gt; keyValue._2.map(_._2).sum</span><br><span class="line">        &#125;</span><br><span class="line">          println(wordSum)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤5-封装单词计数结果回复给MainActor"><a href="#步骤5-封装单词计数结果回复给MainActor" class="headerlink" title="步骤5 | 封装单词计数结果回复给MainActor"></a>步骤5 | 封装单词计数结果回复给MainActor</h2><p><strong>实现思路</strong></p>
<ul>
<li>将单词计数的结果封装为一个样例类消息，并发送给MainActor</li>
<li>MainActor等待所有WordCount均已返回后获取到每个WordCountActor单词计算后的结果</li>
</ul>
<p><strong>实现步骤</strong></p>
<ol>
<li>定义一个样例类封装单词计数结果</li>
<li>将单词计数结果发送给MainActor</li>
<li>MainActor中检测所有WordActor是否均已返回，如果均已返回，则获取并转换结果</li>
<li>打印结果</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MessagePackage.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 单词统计结果</span><br><span class="line">  * @param wordCount 单词计数</span><br><span class="line">  */</span><br><span class="line">//封装单词统计结果</span><br><span class="line">case class WordCountResult(wordSum:Map[String,Int])</span><br></pre></td></tr></table></figure>

<p>WordCountActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//6将结果封装到样例类中,发送给WcMain</span><br><span class="line">sender ! WordCountResult(wordSum)</span><br></pre></td></tr></table></figure>

<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编写一个while循环来等待所有的Actor都已经返回数据</span><br><span class="line">     while (futureList.filter(!_.isSet).size!=0)&#123;&#125;</span><br><span class="line">   // 获取Future中封装的数据</span><br><span class="line">     val wordCountResultList = futureList.map(_.apply().asInstanceOf[WordCountResult])</span><br><span class="line">   // 获取样例类中封装的单词统计结果</span><br><span class="line">   val stringToInts = wordCountResultList.map(_.wordSum)</span><br><span class="line">   println(stringToInts)</span><br></pre></td></tr></table></figure>

<h2 id="步骤6-结果合并"><a href="#步骤6-结果合并" class="headerlink" title="步骤6 | 结果合并"></a>步骤6 | 结果合并</h2><p><strong>实现思路</strong></p>
<p>对接收到的所有单词计数进行合并。因为该部分已经在WordCountActor已经编写过，所以抽取这部分一样的代码到一个工具类中，再调用合并得到最终结果</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>创建一个用于单词合并的工具类</li>
<li>抽取重复代码为一个方法</li>
<li>在MainActor调用该合并方法，计算得到最终结果，并打印</li>
</ol>
<p><strong>参考代码</strong></p>
<p>WordCountUtil.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 单词分组统计</span><br><span class="line">  * @param wordCountList 单词计数列表</span><br><span class="line">  * @return 分组聚合结果</span><br><span class="line">  */</span><br><span class="line">def reduce(wordCountList:List[(String, Int)]) = &#123;</span><br><span class="line">  // 按照单词进行分组</span><br><span class="line">  // [单词分组] = &#123;hadoop-&gt;List(hadoop-&gt;1, hadoop-&gt;1, hadoop-&gt;1), spark-&gt;List(spark -&gt;1)&#125;</span><br><span class="line">  val grouped: Map[String, List[(String, Int)]] = wordCountList.groupBy(_._1)</span><br><span class="line">  // 将分组内的数据进行聚合</span><br><span class="line">  // [单词计数] = (hadoop, 3), (spark, 1)</span><br><span class="line">  val wordCount: Map[String, Int] = grouped.map &#123;</span><br><span class="line">    tuple =&gt;</span><br><span class="line">      // 单词</span><br><span class="line">      val word = tuple._1</span><br><span class="line">      // 进行计数</span><br><span class="line">      // 获取到所有的单词数量，然后进行累加</span><br><span class="line">      val total = tuple._2.map(_._2).sum</span><br><span class="line">      word -&gt; total</span><br><span class="line">  &#125;</span><br><span class="line">  wordCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MainActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 扁平化后再聚合计算</span><br><span class="line">val result: Map[String, Int] = WordCountUtil.reduce(resultList.flatten)</span><br><span class="line"></span><br><span class="line">println(&quot;最终结果:&quot; + result)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Scala进阶2/" data-id="cjz25rjbq000kd8u5opm0uyqd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Scala高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Scala高级/" class="article-date">
  <time datetime="2019-08-08T03:55:41.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Scala高级/">Scala高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Scala高级"><a href="#Scala高级" class="headerlink" title="Scala高级"></a>Scala高级</h1><h2 id="一-高阶函数"><a href="#一-高阶函数" class="headerlink" title="一 高阶函数"></a>一 高阶函数</h2><p>scala 混合了面向对象和函数式的特性，在函数式编程语言中，函数是“头等公民”，它和Int、String、Class等其他类型处于同等的地位，可以像其他类型的变量一样被传递和操作。</p>
<p>高阶函数包含</p>
<ul>
<li>作为值的函数</li>
<li>匿名函数</li>
<li>闭包</li>
<li>柯里化等等</li>
</ul>
<h3 id="1作为值得函数"><a href="#1作为值得函数" class="headerlink" title="1作为值得函数"></a>1作为值得函数</h3><p>在scala中，函数就像和数字、字符串一样，可以将函数传递给一个方法。我们可以对算法进行封装，然后将具体的动作传递给方法，这种特性很有用。</p>
<p>我们之前学习过List的map方法，它就可以接收一个函数，完成List的转换。</p>
<p><strong>例子</strong></p>
<p><strong>示例说明</strong></p>
<p>将一个整数列表中的每个元素转换为对应个数的小星星</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(1, 2, 3...) =&gt; *, **, ***</span><br></pre></td></tr></table></figure>

<p><strong>步骤</strong></p>
<ol>
<li>创建一个函数，用于将数字转换为指定个数的小星星</li>
<li>创建一个列表，调用map方法</li>
<li>打印转换为的列表</li>
</ol>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.highlevel</span><br><span class="line"></span><br><span class="line">object Demo01 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val fun: Int =&gt; String = (num:Int) =&gt; &quot;*&quot; * num</span><br><span class="line">    val strings = (1 to 10).map(fun)</span><br><span class="line">    println(strings)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-匿名函数"><a href="#2-匿名函数" class="headerlink" title="2 匿名函数"></a>2 匿名函数</h3><p><strong>定义</strong></p>
<p>上面的代码，给(num:Int) =&gt; “<em>” * num函数赋值给了一个变量，但是这种写法有一些啰嗦。在scala中，可以不需要给函数赋值给变量，没有赋值给变量的函数就是*</em>匿名函数**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val list = List(1, 2, 3, 4)</span><br><span class="line"></span><br><span class="line">// 字符串*方法，表示生成指定数量的字符串</span><br><span class="line">val func_num2star = (num:Int) =&gt; &quot;*&quot; * num</span><br><span class="line"></span><br><span class="line">print(list.map(func_num2star))</span><br></pre></td></tr></table></figure>

<p>使用匿名函数优化上述代码</p>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object Demo02 &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val strings = (1 to 10).map(x =&gt; &quot;*&quot; * x)</span><br><span class="line"></span><br><span class="line">    println(strings)</span><br><span class="line">// 因为此处num变量只使用了一次，而且只是进行简单的计算，所以可以省略参数列表，使用_替代参数</span><br><span class="line">    val strings2 = (1 to 10 ).map(&quot;*&quot; * _)</span><br><span class="line">    println(strings2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-柯里化"><a href="#3-柯里化" class="headerlink" title="3 柯里化"></a>3 柯里化</h3><p>在scala和spark的源代码中，大量使用到了柯里化。为了后续方便阅读源代码，我们需要来了解下柯里化。</p>
<p>定义:</p>
<p>柯里化（Currying）是指将原先接受多个参数的方法转换为多个只有一个参数的参数列表的过程。</p>
<p><a href="https://manzhong.github.io/images/scala/klh.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/klh.png" alt="img"></a></p>
<p><strong>柯里化过程解析</strong></p>
<p><a href="https://manzhong.github.io/images/scala/klhgcjx.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/klhgcjx.png" alt="img"></a></p>
<p><strong>例子</strong></p>
<p><strong>示例说明</strong></p>
<ul>
<li>编写一个方法，用来完成两个Int类型数字的计算</li>
<li>具体如何计算封装到函数中</li>
<li>使用柯里化来实现上述操作</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 柯里化：实现对两个数进行计算</span><br><span class="line">package com.nicai.highlevel</span><br><span class="line"></span><br><span class="line">object Demo3 &#123;</span><br><span class="line">  def add(a:Int,b:Int)(cala:(Int,Int) =&gt; Int)=&#123;</span><br><span class="line">    cala(a,b)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(add(1, 2)(_ + _))</span><br><span class="line">    println(add(1, 2)(_ * _))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包其实就是一个函数，只不过这个函数的返回值依赖于声明在函数外部的变量。</p>
<p>可以简单认为，就是可以访问不在当前作用域范围的一个函数。</p>
<p><strong>例子一</strong></p>
<p>定义一个闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.highlevel</span><br><span class="line">//闭包</span><br><span class="line">object Demo4 &#123;</span><br><span class="line">  var x=4</span><br><span class="line">  val add=(y:Int) =&gt; x+y</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(add(5))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add函数就是一个闭包</p>
<p><strong>例子二</strong></p>
<p>柯里化就是一个闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add(x:Int)(y:Int) = &#123;</span><br><span class="line">  x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  def add(x:Int) = &#123;</span><br><span class="line">    (y:Int) =&gt; x + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">总的:</span><br><span class="line">package com.nicai.highlevel</span><br><span class="line">//闭包二  柯里化就是一个闭包</span><br><span class="line">object Demo5 &#123;</span><br><span class="line">  def add(a:Int)(b:Int): Int =&#123;</span><br><span class="line">    a+b</span><br><span class="line">  &#125;</span><br><span class="line">  def add2(x:Int)=&#123;</span><br><span class="line">    (y:Int) =&gt; x+y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(add(5)(6))  //11</span><br><span class="line">    println(add2(5)(6))//11</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-隐式转换与隐式参数"><a href="#二-隐式转换与隐式参数" class="headerlink" title="二 隐式转换与隐式参数"></a>二 隐式转换与隐式参数</h2><p>隐式转换和隐式参数是scala非常有特色的功能，也是Java等其他编程语言没有的功能。我们可以很方便地利用隐式转换来丰富现有类的功能。后面在编写Akka并发编程、Spark SQL、Flink都会看到隐式转换和隐式参数的身影。</p>
<h3 id="1-使用隐式转换"><a href="#1-使用隐式转换" class="headerlink" title="1 使用隐式转换"></a>1 使用隐式转换</h3><p><strong>定义:</strong></p>
<p>所谓<strong>隐式转换</strong>，是指以implicit关键字声明的带有<strong>单个参数</strong>的方法。它是<strong>自动被调用</strong>的，自动将某种类型转换为另外一种类型。</p>
<p><strong>使用步骤</strong></p>
<ol>
<li>在object中定义隐式转换方法（使用implicit）</li>
<li>在需要用到隐式转换的地方，引入隐式转换（使用import）</li>
<li>自动调用隐式转化后的方法</li>
</ol>
<p><strong>例子</strong></p>
<p><strong>示例说明</strong></p>
<p>使用隐式转换，让File具备有read功能——实现将文本中的内容以字符串形式读取出来</p>
<p><strong>步骤</strong></p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建RichFile类，提供一个read方法，用于将文件内容读取为字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个隐式转换方法，将File隐式转换为RichFile对象</p>
</li>
<li><p>创建一个File，导入隐式转换，调用File的read方法</p>
</li>
</ol>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.yinshizhuanhuan</span><br><span class="line"></span><br><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line">import scala.io.Source</span><br><span class="line">//隐式转换</span><br><span class="line">/*1. 创建RichFile类，提供一个read方法，用于将文件内容读取为字符串</span><br><span class="line">2. 定义一个隐式转换方法，将File隐式转换为RichFile对象</span><br><span class="line">3. 创建一个File，导入隐式转换，调用File的read方法*/</span><br><span class="line"></span><br><span class="line">object Demo6 &#123;</span><br><span class="line">    class RichFile(f:File)&#123;</span><br><span class="line">      def read()=&#123;</span><br><span class="line">        Source.fromFile(f).mkString</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  object Im&#123;</span><br><span class="line">    implicit def fileToRichFile(file:File) =new RichFile(file)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">  	val file = new File(&quot;day23Scala4/data/a.txt&quot;)</span><br><span class="line">    import Im.fileToRichFile</span><br><span class="line">    println(file.read())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐式转换的时机</strong></p>
<ul>
<li>当对象调用类中不存在的方法或者成员时，编译器会自动将对象进行隐式转换</li>
<li>当方法中的参数的类型与目标类型不一致时</li>
</ul>
<h3 id="2-自动导入隐式转化方法"><a href="#2-自动导入隐式转化方法" class="headerlink" title="2 自动导入隐式转化方法"></a>2 自动导入隐式转化方法</h3><p>前面，我们手动使用了import来导入隐式转换。是否可以不手动import呢？</p>
<p>在scala中，如果在当前作用域中有隐式转换方法，会自动导入隐式转换。</p>
<p>示例：将隐式转换方法定义在main所在的object中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.yinshizhuanhuan</span><br><span class="line"></span><br><span class="line">import java.io.File</span><br><span class="line"></span><br><span class="line">import scala.io.Source</span><br><span class="line"></span><br><span class="line">//自动导入隐式转换</span><br><span class="line">object Demo7 &#123;</span><br><span class="line">  class RichFile(f:File)&#123;</span><br><span class="line">    def read()=&#123;</span><br><span class="line">      Source.fromFile(f).mkString</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val file = new File(&quot;day23Scala4/data/a.txt&quot;)</span><br><span class="line">    implicit def fileToRichFile(file:File) =new RichFile(file)</span><br><span class="line">    println(file.read())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-隐式参数"><a href="#3-隐式参数" class="headerlink" title="3 隐式参数"></a>3 隐式参数</h3><p>方法可以带有一个标记为implicit的参数列表。这种情况，编译器会查找缺省值，提供给该方法。</p>
<p><strong>定义</strong></p>
<ol>
<li>在方法后面添加一个参数列表，参数使用implicit修饰</li>
<li>在object中定义implicit修饰的隐式值</li>
<li>调用方法，可以不传入implicit修饰的参数列表，编译器会自动查找缺省值</li>
</ol>
<p>注意:</p>
<ol>
<li>和隐式转换一样，可以使用import手动导入隐式参数</li>
<li>如果在当前作用域定义了隐式值，会自动进行导入</li>
</ol>
<p><strong>例子</strong></p>
<p><strong>示例说明</strong></p>
<ul>
<li>定义一个方法，可将传入的值，使用一个分隔符前缀、后缀包括起来</li>
<li>使用隐式参数定义分隔符</li>
<li>调用该方法，并打印测试</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.yinshizhuanhuan</span><br><span class="line">//隐式参数</span><br><span class="line">/*- 定义一个方法，可将传入的值，使用一个分隔符前缀、后缀包括起来</span><br><span class="line">- 使用隐式参数定义分隔符</span><br><span class="line">- 调用该方法，并打印测试*/</span><br><span class="line">//与java中的动态代理  作用有点类似</span><br><span class="line">object Demo8 &#123;</span><br><span class="line">    def qu(str:String)(implicit im:(String,String)) =&#123;</span><br><span class="line">      im._1+str+im._2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //定义隐式参数</span><br><span class="line">  object Im&#123;</span><br><span class="line">    implicit val delim= (&quot;&lt;&lt;&quot;,&quot;&gt;&gt;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    import Im.delim</span><br><span class="line">    println(qu(&quot;aa&quot;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-Akka-并发编程"><a href="#三-Akka-并发编程" class="headerlink" title="三 Akka 并发编程"></a>三 Akka 并发编程</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>Akka是一个用于构建高并发、分布式和可扩展的基于事件驱动的应用的工具包。Akka是使用scala开发的库，同时可以使用scala和Java语言来开发基于Akka的应用程序。</p>
<h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2 特性"></a>2 特性</h3><ul>
<li>提供基于异步非阻塞、高性能的事件驱动编程模型</li>
<li>内置容错机制，允许Actor在出错时进行恢复或者重置操作</li>
<li>超级轻量级的事件处理（每GB堆内存几百万Actor）</li>
<li>使用Akka可以在单机上构建高并发程序，也可以在网络中构建分布式程序。</li>
</ul>
<h3 id="3-Akka通信过程"><a href="#3-Akka通信过程" class="headerlink" title="3 Akka通信过程"></a>3 Akka通信过程</h3><p>以下图片说明了Akka Actor的并发编程模型的基本流程：</p>
<ol>
<li><p>学生创建一个ActorSystem</p>
</li>
<li><p>通过ActorSystem来创建一个ActorRef（老师的引用），并将消息发送给ActorRef</p>
</li>
<li><p>ActorRef将消息发送给Message Dispatcher（消息分发器）</p>
</li>
<li><p>Message Dispatcher将消息按照顺序保存到目标Actor的MailBox中</p>
</li>
<li><p>Message Dispatcher将MailBox放到一个线程中</p>
</li>
<li><p>MailBox按照顺序取出消息，最终将它递给TeacherActor接受的方法中</p>
<p><a href="https://manzhong.github.io/images/scala/akka.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/akka.png" alt="img"></a></p>
</li>
</ol>
<h3 id="4-入门案例"><a href="#4-入门案例" class="headerlink" title="4 入门案例"></a>4 入门案例</h3><p>基于Akka创建两个Actor，Actor之间可以互相发送消息。</p>
<p><a href="https://manzhong.github.io/images/scala/akkabf.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/akkabf.png" alt="img"></a></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li>创建Maven模块</li>
<li>创建并加载Actor</li>
<li>发送/接收消息</li>
</ol>
<p><strong>1创建Maven模块</strong></p>
<p>使用Akka需要导入Akka库，我们这里使用Maven来管理项目</p>
<ol>
<li>创建Maven模块</li>
<li>打开pom.xml文件，导入akka Maven依赖和插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">       &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">       &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">       &lt;scala.version&gt;2.11.8&lt;/scala.version&gt;</span><br><span class="line">       &lt;scala.compat.version&gt;2.11&lt;/scala.compat.version&gt;</span><br><span class="line">   &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;scala-library&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;akka-actor_2.11&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.3.14&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;akka-remote_2.11&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.3.14&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">   &lt;build&gt;</span><br><span class="line">       &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt;</span><br><span class="line">       &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt;</span><br><span class="line">       &lt;plugins&gt;</span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">               &lt;executions&gt;</span><br><span class="line">                   &lt;execution&gt;</span><br><span class="line">                       &lt;goals&gt;</span><br><span class="line">                           &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                           &lt;goal&gt;testCompile&lt;/goal&gt;</span><br><span class="line">                       &lt;/goals&gt;</span><br><span class="line">                       &lt;configuration&gt;</span><br><span class="line">                           &lt;args&gt;</span><br><span class="line">                               &lt;arg&gt;-dependencyfile&lt;/arg&gt;</span><br><span class="line">                               &lt;arg&gt;$&#123;project.build.directory&#125;/.scala_dependencies&lt;/arg&gt;</span><br><span class="line">                           &lt;/args&gt;</span><br><span class="line">                       &lt;/configuration&gt;</span><br><span class="line">                   &lt;/execution&gt;</span><br><span class="line">               &lt;/executions&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">           &lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">               &lt;executions&gt;</span><br><span class="line">                   &lt;execution&gt;</span><br><span class="line">                       &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                       &lt;goals&gt;</span><br><span class="line">                           &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                       &lt;/goals&gt;</span><br><span class="line">                       &lt;configuration&gt;</span><br><span class="line">                           &lt;filters&gt;</span><br><span class="line">                               &lt;filter&gt;</span><br><span class="line">                                   &lt;artifact&gt;*:*&lt;/artifact&gt;</span><br><span class="line">                                   &lt;excludes&gt;</span><br><span class="line">                                       &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;</span><br><span class="line">                                       &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;</span><br><span class="line">                                       &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;</span><br><span class="line">                                   &lt;/excludes&gt;</span><br><span class="line">                               &lt;/filter&gt;</span><br><span class="line">                           &lt;/filters&gt;</span><br><span class="line">                           &lt;transformers&gt;</span><br><span class="line">                               &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                   &lt;resource&gt;reference.conf&lt;/resource&gt;</span><br><span class="line">                               &lt;/transformer&gt;</span><br><span class="line">                               &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                                   &lt;mainClass&gt;&lt;/mainClass&gt;</span><br><span class="line">                               &lt;/transformer&gt;</span><br><span class="line">                           &lt;/transformers&gt;</span><br><span class="line">                       &lt;/configuration&gt;</span><br><span class="line">                   &lt;/execution&gt;</span><br><span class="line">               &lt;/executions&gt;</span><br><span class="line">           &lt;/plugin&gt;</span><br><span class="line">       &lt;/plugins&gt;</span><br><span class="line">   &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2创建并加载Actor</strong></p>
<p>创建两个Actor</p>
<ul>
<li><p>SenderActor：用来发送消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.akkademo</span><br><span class="line"></span><br><span class="line">import akka.actor.Actor</span><br><span class="line">//发送消息</span><br><span class="line">object SenderActor extends Actor&#123;</span><br><span class="line">  //不在使用loop+react了 在akka中直接在receive中编写偏函数直接处理消息就可以持续接受消息</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReceiveActor：用来接收，回复消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.akkademo</span><br><span class="line"></span><br><span class="line">import akka.actor.Actor</span><br><span class="line">//接收  回复消息</span><br><span class="line">object ReceiveActor extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>创建Actor</strong></p>
<ol>
<li><p>创建ActorSystem</p>
</li>
<li><p>创建自定义Actor</p>
</li>
<li><p>ActorSystem加载Actor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.akkademo</span><br><span class="line"></span><br><span class="line">import akka.actor.&#123;ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object Entrance &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    //创建ActorSystem</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;, ConfigFactory.load())</span><br><span class="line">    //加载Actor</span><br><span class="line">    val senderActor = actorSystem.actorOf(Props(SenderActor),&quot;senderActor&quot;)</span><br><span class="line">    val receiveActor = actorSystem.actorOf(Props(ReceiveActor),&quot;receiveActor&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>3发送/接收消息</strong></p>
<ul>
<li>使用样例类封装消息</li>
<li>SubmitTaskMessage——提交任务消息</li>
<li>SuccessSubmitTaskMessage——任务提交成功消息</li>
<li>使用类似于之前学习的Actor方式，使用<code>!</code>发送异步消息</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">完整版</span><br><span class="line">//sender发送消息</span><br><span class="line">case class MessageSub(msg:String)</span><br><span class="line">//receive回复消息</span><br><span class="line">case class MsgSuccess(msg:String)</span><br><span class="line">............................................................................</span><br><span class="line">import akka.actor.Actor</span><br><span class="line">//发送消息</span><br><span class="line">object SenderActor extends Actor&#123;</span><br><span class="line">  //不在使用loop+react了 在akka中直接在receive中编写偏函数直接处理消息就可以持续接受消息</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    //匹配 entrance 的消息</span><br><span class="line">    case MessageSub(&quot;start&quot;) =&gt; &#123;</span><br><span class="line">      println(&quot;收到消息&quot;)</span><br><span class="line">        //格式akka://actorSystem的名字/user(固定)/receiveActor的名字  若是远程连接则加端口号等</span><br><span class="line">      val receiveActor = context.actorSelection(&quot;akka://actorSystem/user/receiveActor&quot;)</span><br><span class="line">      //向receive发送消息</span><br><span class="line">      receiveActor ! MessageSub(&quot;nicai&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">      //接收receive的消息</span><br><span class="line">    case MsgSuccess(name) =&gt;&#123;</span><br><span class="line">      println(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...............................................................................</span><br><span class="line">import akka.actor.Actor</span><br><span class="line">//接收  回复消息</span><br><span class="line">object ReceiveActor extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">      //匹配消息</span><br><span class="line">    case MessageSub(name) =&gt; &#123;</span><br><span class="line">      println(name)</span><br><span class="line">        //回复消息</span><br><span class="line">      sender  ! MsgSuccess(&quot;我不猜&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    case _ =&gt; println(&quot;未匹配的消息类型&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">............................................................................</span><br><span class="line">import akka.actor.&#123;ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line">object Entrance &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    //创建ActorSystem</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;, ConfigFactory.load())</span><br><span class="line">    //加载Actor</span><br><span class="line">    val senderActor = actorSystem.actorOf(Props(SenderActor),&quot;senderActor&quot;)</span><br><span class="line">    val receiveActor = actorSystem.actorOf(Props(ReceiveActor),&quot;receiveActor&quot;)</span><br><span class="line"></span><br><span class="line">    //向senderActor发送消息</span><br><span class="line">    senderActor ! MessageSub(&quot;start&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">收到消息</span><br><span class="line">nicai</span><br><span class="line">我不猜</span><br></pre></td></tr></table></figure>

<h3 id="5-Akka定时任务"><a href="#5-Akka定时任务" class="headerlink" title="5 Akka定时任务"></a>5 Akka定时任务</h3><p>如果我们想要使用Akka框架定时的执行一些任务，该如何处理呢？</p>
<p>使用方式:</p>
<p>Akka中，提供一个<strong>scheduler</strong>对象来实现定时调度功能。使用ActorSystem.scheduler.schedule方法，可以启动一个定时任务。</p>
<p>schedule方法针对scala提供两种使用形式：</p>
<p><strong>第一种：发送消息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def schedule(</span><br><span class="line">    initialDelay: FiniteDuration,        // 延迟多久后启动定时任务</span><br><span class="line">    interval: FiniteDuration,            // 每隔多久执行一次</span><br><span class="line">    receiver: ActorRef,                    // 给哪个Actor发送消息</span><br><span class="line">    message: Any)                        // 要发送的消息</span><br><span class="line">(implicit executor: ExecutionContext)    // 隐式参数：需要手动导入</span><br></pre></td></tr></table></figure>

<p><strong>第二种：自定义实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def schedule(</span><br><span class="line">    initialDelay: FiniteDuration,            // 延迟多久后启动定时任务</span><br><span class="line">    interval: FiniteDuration                // 每隔多久执行一次</span><br><span class="line">)(f: ⇒ Unit)                                // 定期要执行的函数，可以将逻辑写在这里</span><br><span class="line">(implicit executor: ExecutionContext)        // 隐式参数：需要手动导入</span><br></pre></td></tr></table></figure>

<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p><strong>示例说明</strong></p>
<ul>
<li>定义一个Actor，每1秒发送一个消息给Actor，Actor收到后打印消息</li>
<li>使用发送消息方式实现</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.&#123;Actor, ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object Demo1 &#123;</span><br><span class="line">//创建actor</span><br><span class="line">  object ReceiveActor extends Actor &#123;</span><br><span class="line">    override def receive: Receive = &#123;</span><br><span class="line">      case x =&gt; println(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;,ConfigFactory.load())</span><br><span class="line">    val receiveActor = actorSystem.actorOf(Props(ReceiveActor))</span><br><span class="line"></span><br><span class="line">    //导入 隐式转换</span><br><span class="line">    import  scala.concurrent.duration._</span><br><span class="line">    //导入隐式参数</span><br><span class="line">    import actorSystem.dispatcher</span><br><span class="line"></span><br><span class="line">    actorSystem.scheduler.schedule(0 seconds, //延迟后多久启动定时任务</span><br><span class="line">      1 seconds,   //每隔多久执行一次</span><br><span class="line">      receiveActor,        //给那个actor发送消息</span><br><span class="line">      &quot;hello&quot;    //消息正文</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p><strong>示例说明</strong></p>
<ul>
<li>定义一个Actor，每1秒发送一个消息给Actor，Actor收到后打印消息</li>
<li>使用自定义方式实现</li>
</ul>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.&#123;Actor, ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object Demo2 &#123;</span><br><span class="line">    object ReceiceActor extends Actor&#123;</span><br><span class="line">      override def receive: Receive = &#123;</span><br><span class="line">        case x =&gt; println(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;,ConfigFactory.load())</span><br><span class="line">    val receiveActor = actorSystem.actorOf(Props(ReceiceActor))</span><br><span class="line"></span><br><span class="line">    //导入隐式装换 不到无法使用 0 seconds</span><br><span class="line">    import scala.concurrent.duration._</span><br><span class="line">    //导入隐式参数</span><br><span class="line">    import actorSystem.dispatcher</span><br><span class="line"></span><br><span class="line">    actorSystem.scheduler.schedule(0 seconds,1 seconds)(</span><br><span class="line">      receiveActor ! &quot; iac&quot;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ol>
<li>需要导入隐式转换<code>import scala.concurrent.duration._</code>才能调用0 seconds方法</li>
<li>需要导入隐式参数<code>import actorSystem.dispatcher</code>才能启动定时任务</li>
</ol>
<h3 id="6-实现两个进程间的通信-master实现"><a href="#6-实现两个进程间的通信-master实现" class="headerlink" title="6 实现两个进程间的通信 master实现"></a>6 实现两个进程间的通信 master实现</h3><p>基于Akka实现在两个<strong>进程</strong>间发送、接收消息。Worker启动后去连接Master，并发送消息，Master接收到消息后，再回复Worker消息。</p>
<p><a href="https://manzhong.github.io/images/scala/jctx.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/jctx.png" alt="img"></a></p>
<h2 id="1-Worker实现"><a href="#1-Worker实现" class="headerlink" title="1. Worker实现"></a>1. Worker实现</h2><p><strong>步骤</strong></p>
<ol>
<li><p>创建一个Maven模块，导入依赖和配置文件</p>
</li>
<li><p>创建配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">application.conf</span><br><span class="line"></span><br><span class="line">akka.actor.provider = &quot;akka.remote.RemoteActorRefProvider&quot;</span><br><span class="line">akka.remote.netty.tcp.hostname = &quot;127.0.0.1&quot;</span><br><span class="line">akka.remote.netty.tcp.port = &quot;8888&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建启动WorkerActor</p>
</li>
<li><p>发送”setup”消息给WorkerActor，WorkerActor接收打印消息</p>
</li>
<li><p>启动测试</p>
</li>
</ol>
<p><strong>参考代码</strong></p>
<p>Worker.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.&#123;Actor, ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object Worker &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;,ConfigFactory.load())</span><br><span class="line">    val worker = actorSystem.actorOf(Props(WorkerActor))</span><br><span class="line">    //发送消息</span><br><span class="line">    worker ! &quot;nicai&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.Actor</span><br><span class="line"></span><br><span class="line">object WorkerActor extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Master实现"><a href="#2-Master实现" class="headerlink" title="2. Master实现"></a>2. Master实现</h2><p><strong>步骤</strong></p>
<ol>
<li>创建Maven模块，导入依赖和配置文件</li>
<li>创建启动MasterActor</li>
<li>WorkerActor发送”connect”消息给MasterActor</li>
<li>MasterActor回复”success”消息给WorkerActor</li>
<li>WorkerActor接收并打印接收到的消息</li>
<li>启动Master、Worker测试</li>
</ol>
<p><strong>参考代码</strong></p>
<p>Master.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.&#123;ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object Master &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;,ConfigFactory.load())</span><br><span class="line">    val masterActor = actorSystem.actorOf(Props(MasterActor),&quot;masterActor&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.Actor</span><br><span class="line"></span><br><span class="line">object MasterActor  extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case &quot;connect&quot; =&gt; &#123;</span><br><span class="line">      println(&quot;worker连接成功&quot;)</span><br><span class="line">      sender ! &quot;success&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.Actor</span><br><span class="line"></span><br><span class="line">object WorkerActor extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case &quot;start&quot; =&gt; &#123;</span><br><span class="line">      println(&quot;start&quot;)</span><br><span class="line">        //设置连接</span><br><span class="line">      val masterActor = context.actorSelection(&quot;akka.tcp://actorSystem@127.0.0.1:9999/user/masterActor&quot;)</span><br><span class="line">      masterActor ! &quot;connect&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    case &quot;success&quot; =&gt; &#123;</span><br><span class="line">      println(&quot;连接master成功&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-简易Spark通信框架案例"><a href="#四-简易Spark通信框架案例" class="headerlink" title="四 简易Spark通信框架案例"></a>四 简易Spark通信框架案例</h2><p><strong>案例介绍</strong></p>
<p>模拟Spark的Master与Worker通信</p>
<ul>
<li>一个Master<ul>
<li>管理Worker</li>
</ul>
</li>
<li>若干个Worker（Worker可以按需添加）<ul>
<li>注册</li>
<li>发送心跳</li>
</ul>
</li>
</ul>
<p><a href="https://manzhong.github.io/images/scala/spark.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/scala/spark.png" alt="img"></a></p>
<p><strong>实现思路</strong></p>
<ol>
<li>构建Master、Worker阶段<ul>
<li>构建Master ActorSystem、Actor</li>
<li>构建Worker ActorSystem、Actor</li>
</ul>
</li>
<li>Worker注册阶段<ul>
<li>Worker进程向Master注册（将自己的ID、CPU核数、内存大小(M)发送给Master）</li>
</ul>
</li>
<li>Worker定时发送心跳阶段<ul>
<li>Worker定期向Master发送心跳消息</li>
</ul>
</li>
<li>Master定时心跳检测阶段<ul>
<li>Master定期检查Worker心跳，将一些超时的Worker移除，并对Worker按照内存进行倒序排序</li>
</ul>
</li>
<li>多个Worker测试阶段<ul>
<li>启动多个Worker，查看是否能够注册成功，并停止某个Worker查看是否能够正确移除</li>
</ul>
</li>
</ol>
<p><strong>工程搭建</strong></p>
<p>项目使用Maven搭建工程</p>
<ol>
<li>分别搭建几下几个项目</li>
</ol>
<table>
<thead>
<tr>
<th align="left">工程名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">spark-demo-common</td>
<td align="left">存放公共的消息、实体类</td>
</tr>
<tr>
<td align="left">spark-demo-master</td>
<td align="left">Akka Master节点</td>
</tr>
<tr>
<td align="left">spark-demo-worker</td>
<td align="left">Akka Worker节点</td>
</tr>
</tbody></table>
<ol>
<li><p>导入依赖</p>
<ul>
<li><p>master/worker添加common依赖,其余同上</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">common依赖</span><br><span class="line"></span><br><span class="line"> &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">        &lt;scala.version&gt;2.11.8&lt;/scala.version&gt;</span><br><span class="line">        &lt;scala.compat.version&gt;2.11&lt;/scala.compat.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;scala-library&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt;</span><br><span class="line">        &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;testCompile&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;args&gt;</span><br><span class="line">                                &lt;arg&gt;-dependencyfile&lt;/arg&gt;</span><br><span class="line">                                &lt;arg&gt;$&#123;project.build.directory&#125;/.scala_dependencies&lt;/arg&gt;</span><br><span class="line">                            &lt;/args&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;filters&gt;</span><br><span class="line">                                &lt;filter&gt;</span><br><span class="line">                                    &lt;artifact&gt;*:*&lt;/artifact&gt;</span><br><span class="line">                                    &lt;excludes&gt;</span><br><span class="line">                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;</span><br><span class="line">                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;</span><br><span class="line">                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;</span><br><span class="line">                                    &lt;/excludes&gt;</span><br><span class="line">                                &lt;/filter&gt;</span><br><span class="line">                            &lt;/filters&gt;</span><br><span class="line">                            &lt;transformers&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">                                    &lt;resource&gt;reference.conf&lt;/resource&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;mainClass&gt;&lt;/mainClass&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                            &lt;/transformers&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>导入配置文件(同上)</p>
<ul>
<li>修改Master的端口为7000(或者自定义)</li>
<li>修改Worker的端口为7100(或者自定义 最好 8000以上)</li>
</ul>
</li>
</ol>
<p><strong>构建master和worker</strong></p>
<p>master和masterActor worker和workerActor</p>
<p>同上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//MasterActor</span><br><span class="line">import akka.actor.Actor</span><br><span class="line">object MasterActor extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">........................................</span><br><span class="line">//MasterMain</span><br><span class="line">import akka.actor.&#123;ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object MasterMain &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;,ConfigFactory.load())</span><br><span class="line">    val masterActor = actorSystem.actorOf(Props(MasterActor),&quot;masterActor&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.............................................................</span><br><span class="line">//WorkerActor </span><br><span class="line">import akka.actor.Actor</span><br><span class="line"></span><br><span class="line">object WorkerActor extends Actor&#123;</span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case x =&gt; println(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">..............................</span><br><span class="line">//WorkerMain </span><br><span class="line">import akka.actor.&#123;ActorSystem, Props&#125;</span><br><span class="line">import com.typesafe.config.ConfigFactory</span><br><span class="line"></span><br><span class="line">object WorkerMain &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val actorSystem = ActorSystem(&quot;actorSystem&quot;,ConfigFactory.load())</span><br><span class="line">    val workerActor = actorSystem.actorOf(Props(WorkerActor),&quot;workerActor&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>worker注册实现</strong></p>
<p>在Worker启动时，发送注册消息给Master</p>
<p><strong>步骤</strong></p>
<ol>
<li>Worker向Master发送注册消息（workerid、cpu核数、内存大小）<ul>
<li>随机生成CPU核（1、2、3、4、6、8）</li>
<li>随机生成内存大小（512、1024、2048、4096）（单位M）</li>
</ul>
</li>
<li>Master保存Worker信息，并给Worker回复注册成功消息</li>
<li>启动测试</li>
</ol>
<p><strong>参考代码</strong></p>
<p>MasterActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import akka.actor.Actor</span><br><span class="line">import com.nicai.common.&#123;MsgRegin, MsgSuccess, Pojo&#125;</span><br><span class="line"></span><br><span class="line">import scala.collection.mutable</span><br><span class="line"></span><br><span class="line">object MasterActor extends Actor&#123;</span><br><span class="line">  //保存消息</span><br><span class="line">  private var stringToPojo: mutable.Map[String, Pojo] = collection.mutable.Map[String,Pojo]()</span><br><span class="line"></span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case MsgRegin(workid,cpu,mem) =&gt; &#123;</span><br><span class="line">      println(&quot;收到注册消息&quot;+workid+&quot;-&quot;+cpu+&quot;-&quot;+mem)</span><br><span class="line">      //保存消息到实体类</span><br><span class="line">      stringToPojo += workid -&gt; Pojo(workid,cpu,mem)</span><br><span class="line">      //回复消息</span><br><span class="line">      sender ! MsgSuccess(&quot;success&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pojo.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//实体类保存 worker的注册信息</span><br><span class="line">case class Pojo(wokid:String,cpu:Int,mem:Int)</span><br></pre></td></tr></table></figure>

<p>MsgPackage.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注册消息</span><br><span class="line">case class MsgRegin(workid:String,cpu:Int,mem:Int)</span><br><span class="line">//注册成功回复消息</span><br><span class="line">case class MsgSuccess(success:String)</span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.UUID</span><br><span class="line"></span><br><span class="line">import akka.actor.&#123;Actor, ActorSelection, ActorSystem&#125;</span><br><span class="line">import com.nicai.common.&#123;MsgRegin, MsgSuccess&#125;</span><br><span class="line"></span><br><span class="line">import scala.util.Random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">object WorkerActor extends Actor&#123;</span><br><span class="line">  private var actorSelection:ActorSelection=_</span><br><span class="line">  private var CPU_lIST:Int=_</span><br><span class="line">  private var MEM_LIST:Int=_</span><br><span class="line">  private var cpuList=List(1,2,4,8)</span><br><span class="line">  private var memList=List(128,256,512,1024,2048)</span><br><span class="line">  //在actor启动前要做的事</span><br><span class="line"> override def preStart()=&#123;</span><br><span class="line">    //1 获取发送的对象</span><br><span class="line">   actorSelection = context.system.actorSelection(&quot;akka.tcp://actorSystem@127.0.0.1:7000/user/masterActor&quot;)</span><br><span class="line">    //2  封装消息</span><br><span class="line">    val workerid:String=UUID.randomUUID().toString</span><br><span class="line">    var a=new Random()</span><br><span class="line">    CPU_lIST=cpuList(a.nextInt(cpuList.length))</span><br><span class="line">    MEM_LIST=memList(a.nextInt(memList.length))</span><br><span class="line">    val regin = MsgRegin(workerid,CPU_lIST,MEM_LIST)</span><br><span class="line">    //3 发送消息</span><br><span class="line">    actorSelection ! regin</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case MsgSuccess(name) =&gt; &#123;</span><br><span class="line">      println(&quot;注册后的回复&quot;+name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>worker定时发送心跳</strong></p>
<p>Worker接收到Master返回注册成功后，发送心跳消息。而Master收到Worker发送的心跳消息后，需要更新对应Worker的最后心跳时间。</p>
<p><strong>步骤</strong></p>
<ol>
<li>编写工具类读取心跳发送时间间隔</li>
<li>创建心跳消息</li>
<li>Worker接收到注册成功后，定时发送心跳消息</li>
<li>Master收到心跳消息，更新Worker最后心跳时间</li>
<li>启动测试</li>
</ol>
<p><strong>参考代码</strong></p>
<p>修改配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">添加 workerActor中的</span><br><span class="line">//定时发送消息</span><br><span class="line">worker.heartbeat.interval=5</span><br></pre></td></tr></table></figure>

<p>在workerActor中ConfUtil.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import com.typesafe.config.&#123;Config, ConfigFactory&#125;</span><br><span class="line"></span><br><span class="line">object ConfUtil&#123;</span><br><span class="line">  private val config: Config = ConfigFactory.load()</span><br><span class="line"></span><br><span class="line">  val `worker.heartbeat.interval` = config.getInt(&quot;worker.heartbeat.interval&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MsgPackage.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//心跳信息</span><br><span class="line">case class MsgHeartBeat(workid:String,cpu:Int,mem:Int)</span><br></pre></td></tr></table></figure>

<p>WorkerActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.util.UUID</span><br><span class="line">import akka.actor.&#123;Actor, ActorSelection, ActorSystem&#125;</span><br><span class="line">import com.nicai.common.&#123;MsgHeartBeat, MsgRegin, MsgSuccess&#125;</span><br><span class="line">import scala.util.Random</span><br><span class="line">object WorkerActor extends Actor &#123;</span><br><span class="line">  private var actorSelection: ActorSelection = _</span><br><span class="line">  private var workerid: String = _</span><br><span class="line">  private var CPU_lIST: Int = _</span><br><span class="line">  private var MEM_LIST: Int = _</span><br><span class="line">  private var cpuList = List(1, 2, 4, 8)</span><br><span class="line">  private var memList = List(128, 256, 512, 1024, 2048)</span><br><span class="line"></span><br><span class="line">  //在actor启动前要做的事</span><br><span class="line">  override def preStart() = &#123;</span><br><span class="line">    //1 获取发送的对象</span><br><span class="line">    actorSelection = context.system.actorSelection(&quot;akka.tcp://actorSystem@127.0.0.1:7000/user/masterActor&quot;)</span><br><span class="line">    //2  封装消息</span><br><span class="line">    workerid = UUID.randomUUID().toString</span><br><span class="line">    var a = new Random()</span><br><span class="line">    CPU_lIST = cpuList(a.nextInt(cpuList.length))</span><br><span class="line">    MEM_LIST = memList(a.nextInt(memList.length))</span><br><span class="line">    val regin = MsgRegin(workerid, CPU_lIST, MEM_LIST)</span><br><span class="line">    //3 发送消息</span><br><span class="line">    actorSelection ! regin</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case MsgSuccess(name) =&gt; &#123;</span><br><span class="line">      println(&quot;注册后的回复&quot; + name)</span><br><span class="line">      //导入隐式转换</span><br><span class="line">      import scala.concurrent.duration._</span><br><span class="line">      //导入隐式参数</span><br><span class="line">      import context.dispatcher</span><br><span class="line">      //心跳发送</span><br><span class="line">      context.system.scheduler.schedule(0 seconds,</span><br><span class="line">        ConfUtil.`worker.heartbeat.interval` seconds</span><br><span class="line">      ) &#123;</span><br><span class="line">        actorSelection ! MsgHeartBeat(workerid,CPU_lIST,MEM_LIST)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date</span><br><span class="line"></span><br><span class="line">import akka.actor.Actor</span><br><span class="line">import com.nicai.common.&#123;MsgHeartBeat, MsgRegin, MsgSuccess, Pojo&#125;</span><br><span class="line"></span><br><span class="line">import scala.collection.mutable</span><br><span class="line"></span><br><span class="line">object MasterActor extends Actor&#123;</span><br><span class="line">  //保存消息</span><br><span class="line">  private var stringToPojo: mutable.Map[String, Pojo] = collection.mutable.Map[String,Pojo]()</span><br><span class="line"></span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case MsgRegin(workid,cpu,mem) =&gt; &#123;</span><br><span class="line">      println(&quot;收到注册消息&quot;+workid+&quot;-&quot;+cpu+&quot;-&quot;+mem)</span><br><span class="line">      //保存消息到实体类</span><br><span class="line">      stringToPojo += workid -&gt; Pojo(workid,cpu,mem,new Date().getTime)</span><br><span class="line">      //回复消息</span><br><span class="line">      sender ! MsgSuccess(&quot;success&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">      //心跳</span><br><span class="line">    case MsgHeartBeat(workid,cpu,mem)=&gt;&#123;</span><br><span class="line">      println(&quot;接收到心跳&quot;)</span><br><span class="line">      //更新消息</span><br><span class="line">      stringToPojo += workid -&gt; Pojo(workid,cpu,mem,new Date().getTime)</span><br><span class="line">      println(stringToPojo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>master定时心跳检测</strong></p>
<p>如果某个worker超过一段时间没有发送心跳，Master需要将该worker从当前的Worker集合中移除。可以通过Akka的定时任务，来实现心跳超时检查。</p>
<p><strong>步骤</strong></p>
<ol>
<li>编写工具类，读取检查心跳间隔时间间隔、超时时间</li>
<li>定时检查心跳，过滤出来大于超时时间的Worker</li>
<li>移除超时的Worker</li>
<li>对现有Worker按照内存进行降序排序，打印可用Worker</li>
</ol>
<p><strong>参考代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改 master的配置文件</span><br><span class="line"></span><br><span class="line">//检查worker心跳的时间周期</span><br><span class="line">master.heartbeat.check.interval=6</span><br><span class="line">//配置worker的心跳超时时间</span><br><span class="line">master.heartbeat.check.timeout=15</span><br></pre></td></tr></table></figure>

<p>ConfigUtil.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.typesafe.config.&#123;Config, ConfigFactory&#125;</span><br><span class="line">object ConfigUtil &#123;</span><br><span class="line">  private val config: Config = ConfigFactory.load()</span><br><span class="line"></span><br><span class="line">  // 心跳检查时间间隔</span><br><span class="line">  val `master.heartbeat.check.interval` = config.getInt(&quot;master.heartbeat.check.interval&quot;)</span><br><span class="line">  // 心跳超时时间</span><br><span class="line">  val `master.heartbeat.check.timeout` = config.getInt(&quot;master.heartbeat.check.timeout&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MasterActor.scala</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date</span><br><span class="line">import akka.actor.Actor</span><br><span class="line">import com.nicai.common.&#123;MsgHeartBeat, MsgRegin, MsgSuccess, Pojo&#125;</span><br><span class="line"></span><br><span class="line">import scala.collection.mutable</span><br><span class="line"></span><br><span class="line">object MasterActor extends Actor&#123;</span><br><span class="line">  //保存消息</span><br><span class="line">  private var stringToPojo: mutable.Map[String, Pojo] = collection.mutable.Map[String,Pojo]()</span><br><span class="line">  override def preStart(): Unit = &#123;</span><br><span class="line">    // 导入时间单位隐式转换</span><br><span class="line">    import scala.concurrent.duration._</span><br><span class="line">    // 导入隐式参数</span><br><span class="line">    import context.dispatcher</span><br><span class="line"></span><br><span class="line">    // 1. 启动定时任务</span><br><span class="line">    context.system.scheduler.schedule(0 seconds,</span><br><span class="line">      ConfigUtil.`master.heartbeat.check.interval` seconds)&#123;</span><br><span class="line">      // 2. 过滤大于超时时间的Worker</span><br><span class="line">      val timeoutWorkerMap = stringToPojo.filter &#123;</span><br><span class="line">        keyval =&gt;</span><br><span class="line">          // 获取最后一次心跳更新时间</span><br><span class="line">          val lastHeartBeatTime = keyval._2.heartBeat</span><br><span class="line">          // 当前系统时间 - 最后一次心跳更新时间 &gt; 超时时间（配置文件） * 1000，返回true，否则返回false</span><br><span class="line">          if (new Date().getTime - lastHeartBeatTime &gt; ConfigUtil.`master.heartbeat.check.timeout` * 1000) &#123;</span><br><span class="line">            true</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">            false</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 3. 移除超时Worker</span><br><span class="line">      if(!timeoutWorkerMap.isEmpty) &#123;</span><br><span class="line">        stringToPojo --= timeoutWorkerMap.map(_._1)</span><br><span class="line"></span><br><span class="line">        // 4. 对Worker按照内存进行降序排序，打印Worker</span><br><span class="line">        val workerList = stringToPojo.map(_._2).toList</span><br><span class="line">        val sortedWorkerList = workerList.sortBy(_.mem).reverse</span><br><span class="line">        println(&quot;按照内存降序排序后的Worker列表：&quot;)</span><br><span class="line">        println(sortedWorkerList)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def receive: Receive = &#123;</span><br><span class="line">    case MsgRegin(workid,cpu,mem) =&gt; &#123;</span><br><span class="line">      println(&quot;收到注册消息&quot;+workid+&quot;-&quot;+cpu+&quot;-&quot;+mem)</span><br><span class="line">      //保存消息到实体类</span><br><span class="line">      stringToPojo += workid -&gt; Pojo(workid,cpu,mem,new Date().getTime)</span><br><span class="line">      //回复消息</span><br><span class="line">      sender ! MsgSuccess(&quot;success&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">      //心跳</span><br><span class="line">    case MsgHeartBeat(workid,cpu,mem)=&gt;&#123;</span><br><span class="line">      println(&quot;接收到心跳&quot;)</span><br><span class="line">      //更新消息</span><br><span class="line">      stringToPojo += workid -&gt; Pojo(workid,cpu,mem,new Date().getTime)</span><br><span class="line">      println(stringToPojo)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多个worker测试</strong></p>
<p>修改配置文件，启动多个worker进行测试。</p>
<p><strong>步骤</strong></p>
<ol>
<li>测试启动新的Worker是否能够注册成功 (修改worker的端口号即可)</li>
<li>停止Worker，测试是否能够从现有列表删除</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Scala高级/" data-id="cjz25rjbs000nd8u52adc2r6t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ElSearh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/ElSearh/" class="article-date">
  <time datetime="2019-08-08T03:54:52.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/ElSearh/">ElSearh</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#一 Lucene</p>
<p>全文检索:</p>
<p>索引&amp;检索</p>
<p>倒排索引 :</p>
<p>1我是中国人</p>
<p>2 中国是全球人口最多的国家 ,中国人也最多</p>
<p>例如这两句 用 倒排索引</p>
<p>1，我 （1:1）｛0｝ 第一个1 为第一行 第二个1 为个数 0 为行偏移量</p>
<p>2，中国 (1:1) {2},(2:2){0，15}</p>
<p><a href="https://manzhong.github.io/images/Es/dc.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Es/dc.jpg" alt="img"></a></p>
<p>#二 es 概述</p>
<p>全称 Elastic Search 基于Lucene ES只是封装了Lucene es 制定了一套规则 ,发送给我的数据只要满足一定的格式即可,而不管你的数据来源,只要满足这个规则es就可以对其进行操作.</p>
<p>Elastic有一条完整的产品线及解决方案：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。</p>
<p>##1特点</p>
<ul>
<li>分布式，无需人工搭建集群（solr就需要人为配置，使用Zookeeper作为注册中心）</li>
<li>Restful风格，一切API都遵循Rest原则，容易上手</li>
<li>近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。</li>
</ul>
<h2 id="2原理与应用"><a href="#2原理与应用" class="headerlink" title="2原理与应用"></a>2原理与应用</h2><h3 id="1-2-1索引结构"><a href="#1-2-1索引结构" class="headerlink" title="1.2.1索引结构"></a>1.2.1索引结构</h3><p> 下图是ElasticSearch的索引结构，下边黑色部分是物理结构，上边黄色部分是逻辑结构，逻辑结构也是为了更好的去描述ElasticSearch的工作原理及去使用物理结构中的索引文件。</p>
<p><a href="https://manzhong.github.io/images/Es/sy.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Es/sy.png" alt="img"></a></p>
<p>逻辑结构部分是一个倒排索引表：</p>
<p>1、将要搜索的文档内容分词，所有不重复的词组成分词列表。</p>
<p>2、将搜索的文档最终以Document方式存储起来。</p>
<p>3、每个词和docment都有关联。</p>
<p>如下：</p>
<p><a href="https://manzhong.github.io/images/Es/dp.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Es/dp.png" alt="img"></a></p>
<p>现在，如果我们想搜索 <code>quick brown</code> ，我们只需要查找包含每个词条的文档：</p>
<p><a href="https://manzhong.github.io/images/Es/s.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Es/s.png" alt="img"></a></p>
<p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 <em>相似性算法</em> ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p>
<h2 id="3-RESTful应用方法"><a href="#3-RESTful应用方法" class="headerlink" title="3 RESTful应用方法"></a>3 RESTful应用方法</h2><p>Elasticsearch提供 RESTful Api接口进行索引、搜索，并且支持多种客户端。</p>
<p>es在项目中的应用:</p>
<p><a href="https://manzhong.github.io/images/Es/x.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/Es/x.png" alt="img"></a></p>
<p>1) 用户在前端搜索关键字</p>
<p>2）项目前端通过http方式请求项目服务端</p>
<p>3）项目服务端通过Http RESTful方式请求ES集群进行搜索</p>
<p>4）ES集群从索引库检索数据。</p>
<h2 id="三-安装与部署-集群"><a href="#三-安装与部署-集群" class="headerlink" title="三 安装与部署 集群"></a>三 安装与部署 集群</h2><h3 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1 新建用户"></a>1 新建用户</h3><p>出于安全考虑，elasticsearch默认不允许以root账号运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd es</span><br><span class="line">passwd 123456</span><br><span class="line">切换用户  su - es</span><br></pre></td></tr></table></figure>

<h3 id="2-上传压塑包并解压"><a href="#2-上传压塑包并解压" class="headerlink" title="2 上传压塑包并解压"></a>2 上传压塑包并解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3 修改配置文件"></a>3 修改配置文件</h3><p>要修改两个配置文件在 config目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br></pre></td></tr></table></figure>

<p>elasticsearch.yml和jvm.options</p>
<h4 id="3-1-修改jvm-options"><a href="#3-1-修改jvm-options" class="headerlink" title="3.1 修改jvm.options"></a>3.1 修改jvm.options</h4><p>Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。</p>
<p>编辑jvm.options：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim jvm.options</span><br><span class="line">默认配置如下：</span><br><span class="line"></span><br><span class="line">    -Xms1g</span><br><span class="line">    -Xmx1g</span><br><span class="line"></span><br><span class="line">内存占用太多了，我们调小一些：</span><br><span class="line">-Xms512m</span><br><span class="line">-Xmx512m</span><br></pre></td></tr></table></figure>

<h4 id="3-2-修改elasticsearch-yml"><a href="#3-2-修改elasticsearch-yml" class="headerlink" title="3.2 修改elasticsearch.yml"></a>3.2 修改elasticsearch.yml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure>

<p>修改数据和日志目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.data: /export/server/elasticsearch/data # 数据目录位置</span><br><span class="line">path.logs: /export/server/elasticsearch/logs # 日志目录位置</span><br></pre></td></tr></table></figure>

<p>我们把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此我们需要创建出来。</p>
<p>进入elasticsearch的根目录，然后创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure>

<p>修改绑定的ip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问</span><br></pre></td></tr></table></figure>

<p>默认只允许本机访问，修改为0.0.0.0后则可以远程访问</p>
<p>这个是做的单机安装，如果要做集群，只需要在这个配置文件中添加其它节点信息即可。</p>
<blockquote>
<p>elasticsearch.ym文件中的其他配置</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cluster.name</td>
<td align="left">配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。</td>
</tr>
<tr>
<td align="left">node.name</td>
<td align="left">节点名，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理</td>
</tr>
<tr>
<td align="left">path.conf</td>
<td align="left">设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch</td>
</tr>
<tr>
<td align="left">path.data</td>
<td align="left">设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开</td>
</tr>
<tr>
<td align="left">path.logs</td>
<td align="left">设置日志文件的存储路径，默认是es根目录下的logs文件夹</td>
</tr>
<tr>
<td align="left">path.plugins</td>
<td align="left">设置插件的存放路径，默认是es根目录下的plugins文件夹</td>
</tr>
<tr>
<td align="left">bootstrap.memory_lock</td>
<td align="left">设置为true可以锁住ES使用的内存，避免内存进行swap</td>
</tr>
<tr>
<td align="left">network.host</td>
<td align="left">设置bind_host和publish_host，设置为0.0.0.0允许外网访问</td>
</tr>
<tr>
<td align="left">http.port</td>
<td align="left">设置对外服务的http端口，默认为9200。</td>
</tr>
<tr>
<td align="left">transport.tcp.port</td>
<td align="left">集群结点之间通信端口</td>
</tr>
<tr>
<td align="left">discovery.zen.ping.timeout</td>
<td align="left">设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些</td>
</tr>
<tr>
<td align="left">discovery.zen.minimum_master_nodes</td>
<td align="left">主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>cluster.name:</p>
<p> 配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。</p>
<p>node.name:</p>
<p> 节点名，通常一台物理服务器就是一个节点，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理</p>
<p> 一个或多个节点组成一个cluster集群，集群是一个逻辑的概念，节点是物理概念，后边章节会详细介绍。</p>
<p>path.conf: 设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch</p>
<p>path.data: 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开。 path.logs: 设置日志文件的存储路径，默认是es根目录下的logs文件夹</p>
<p>path.plugins: 设置插件的存放路径，默认是es根目录下的plugins文件夹</p>
<p>bootstrap.memory_lock: true 设置为true可以锁住ES使用的内存，避免内存与swap分区交换数据。</p>
<p>network.host: 设置绑定主机的ip地址，设置为0.0.0.0表示绑定任何ip，允许外网访问，生产环境建议设置为具体的ip。 http.port: 9200 设置对外服务的http端口，默认为9200。</p>
<p>transport.tcp.port: 9300 集群结点之间通信端口</p>
<p>node.master: 指定该节点是否有资格被选举成为master结点，默认是true，如果原来的master宕机会重新选举新的master。</p>
<p>node.data: 指定该节点是否存储索引数据，默认为true。</p>
<p>discovery.zen.ping.unicast.hosts: [“host1:port”, “host2:port”, “…”] 设置集群中master节点的初始列表。</p>
<p>discovery.zen.ping.timeout: 3s 设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些。 discovery.zen.minimum_master_nodes:</p>
<p> 主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2。</p>
<p>node.max_local_storage_nodes:</p>
<p> 单机允许的最大存储结点数，通常单机启动一个结点建议设置为1，开发环境如果单机启动多个节点可设置大于1.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/ElSearh/" data-id="cjz25rjav0008d8u5bjch6x7w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Spark入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/Spark入门/" class="article-date">
  <time datetime="2019-08-08T03:54:40.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/Spark入门/">Spark入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#一 Spark 概述</p>
<p>##1 什么是Spark</p>
<p>Apache Spark 是一个快速的, 多用途的集群计算系统, 相对于 Hadoop MapReduce 将中间结果保存在磁盘中, Spark 使用了内存保存中间结果, 能在数据尚未写入硬盘时在内存中进行运算.</p>
<p>Spark 只是一个计算框架, 不像 Hadoop 一样包含了分布式文件系统和完备的调度系统, 如果要使用 Spark, 需要搭载其它的文件系统和更成熟的调度系统</p>
<p>Spark 产生之前, 已经有非常成熟的计算系统存在了, 例如 MapReduce, 这些计算系统提供了高层次的API, 把计算运行在集群中并提供容错能力, 从而实现分布式计算.</p>
<p>虽然这些框架提供了大量的对访问利用计算资源的抽象, 但是它们缺少了对利用分布式内存的抽象, 这些框架多个计算之间的数据复用就是将中间数据写到一个稳定的文件系统中(例如HDFS), 所以会产生数据的复制备份, 磁盘的I/O以及数据的序列化, 所以这些框架在遇到需要在多个计算之间复用中间结果的操作时会非常的不高效.</p>
<p>而这类操作是非常常见的, 例如迭代式计算, 交互式数据挖掘, 图计算等.</p>
<p>认识到这个问题后, 学术界的 AMPLab 提出了一个新的模型, 叫做 <code>RDDs</code>.</p>
<p><code>RDDs</code> 是一个可以容错且并行的数据结构, 它可以让用户显式的将中间结果数据集保存在内中, 并且通过控制数据集的分区来达到数据存放处理最优化.</p>
<p>同时 <code>RDDs</code> 也提供了丰富的 API 来操作数据集.</p>
<p>后来 RDDs 被 AMPLab 在一个叫做 Spark 的框架中提供并开源.</p>
<p><strong>mr 的问题</strong></p>
<p>1 计算过程比较缓慢,不适应与交互式计算,和迭代计算</p>
<p>2 不是所有的计算都由Map和Reduce两个阶段组成</p>
<p><strong>spark解决问题</strong></p>
<p>1 第一个问题 解决 中间结果存在内存中</p>
<p>2 提供了更好的API 函数式</p>
<p>##2 spark特点</p>
<ul>
<li><p>速度快</p>
<p>Spark 的在内存时的运行速度是 Hadoop MapReduce 的100倍基于硬盘的运算速度大概是 Hadoop MapReduce 的10倍Spark 实现了一种叫做 RDDs 的 DAG 执行引擎, 其数据缓存在内存中可以进行迭代处理</p>
</li>
<li><p>易用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = spark.read.json(&quot;logs.json&quot;)</span><br><span class="line">df.where(&quot;age &gt; 21&quot;) \</span><br><span class="line">  .select(&quot;name.first&quot;) \</span><br><span class="line">  .show()</span><br></pre></td></tr></table></figure>

<ul>
<li>Spark 支持 Java, Scala, Python, R, SQL 等多种语言的API.</li>
<li>Spark 支持超过80个高级运算符使得用户非常轻易的构建并行计算程序</li>
<li>Spark 可以使用基于 Scala, Python, R, SQL的 Shell 交互式查询.</li>
</ul>
</li>
<li><p>通用</p>
<p>Spark 提供一个完整的技术栈, 包括 SQL执行, Dataset命令式API, 机器学习库MLlib, 图计算框架GraphX, 流计算SparkStreaming用户可以在同一个应用中同时使用这些工具, 这一点是划时代的</p>
</li>
<li><p>兼容</p>
<p>Spark 可以运行在 Hadoop Yarn, Apache Mesos, Kubernets, Spark Standalone等集群中Spark 可以访问 HBase, HDFS, Hive, Cassandra 在内的多种数据库</p>
</li>
</ul>
<p>总结</p>
<ul>
<li>支持 Java, Scala, Python 和 R 的 API</li>
<li>可扩展至超过 8K 个节点</li>
<li>能够在内存中缓存数据集, 以实现交互式数据分析</li>
<li>提供命令行窗口, 减少探索式的数据分析的反应时间</li>
</ul>
<h2 id="3-spark组件"><a href="#3-spark组件" class="headerlink" title="3 spark组件"></a>3 spark组件</h2><p>Spark 最核心的功能是 RDDs, RDDs 存在于 <code>spark-core</code> 这个包内, 这个包也是 Spark 最核心的包.</p>
<p>同时 Spark 在 <code>spark-core</code> 的上层提供了很多工具, 以便于适应不用类型的计算.</p>
<ul>
<li><p>Spark-Core 和 弹性分布式数据集(RDDs)</p>
<p>Spark-Core 是整个 Spark 的基础, 提供了分布式任务调度和基本的 I/O 功能Spark 的基础的程序抽象是弹性分布式数据集(RDDs), 是一个可以并行操作, 有容错的数据集合RDDs 可以通过引用外部存储系统的数据集创建(如HDFS, HBase), 或者通过现有的 RDDs 转换得到RDDs 抽象提供了 Java, Scala, Python 等语言的APIRDDs 简化了编程复杂性, 操作 RDDs 类似通过 Scala 或者 Java8 的 Streaming 操作本地数据集合</p>
</li>
<li><p>Spark SQL</p>
<p>Spark SQL 在 <code>spark-core</code> 基础之上带出了一个名为 DataSet 和 DataFrame 的数据抽象化的概念Spark SQL 提供了在 Dataset 和 DataFrame 之上执行 SQL 的能力Spark SQL 提供了 DSL, 可以通过 Scala, Java, Python 等语言操作 DataSet 和 DataFrame它还支持使用 JDBC/ODBC 服务器操作 SQL 语言</p>
</li>
<li><p>Spark Streaming</p>
<p>Spark Streaming 充分利用 <code>spark-core</code> 的快速调度能力来运行流分析它截取小批量的数据并可以对之运行 RDD Transformation它提供了在同一个程序中同时使用流分析和批量分析的能力</p>
</li>
<li><p>MLlib</p>
<p>MLlib 是 Spark 上分布式机器学习的框架. Spark分布式内存的架构 比 Hadoop磁盘式 的 Apache Mahout 快上 10 倍, 扩展性也非常优良MLlib 可以使用许多常见的机器学习和统计算法, 简化大规模机器学习汇总统计, 相关性, 分层抽样, 假设检定, 随即数据生成支持向量机, 回归, 线性回归, 逻辑回归, 决策树, 朴素贝叶斯协同过滤, ALSK-meansSVD奇异值分解, PCA主成分分析TF-IDF, Word2Vec, StandardScalerSGD随机梯度下降, L-BFGS</p>
</li>
<li><p>GraphX</p>
<p>GraphX 是分布式图计算框架, 提供了一组可以表达图计算的 API, GraphX 还对这种抽象化提供了优化运行</p>
</li>
</ul>
<p>总结</p>
<ul>
<li>Spark 提供了 批处理(RDDs), 结构化查询(DataFrame), 流计算(SparkStreaming), 机器学习(MLlib), 图计算(GraphX) 等组件</li>
<li>这些组件均是依托于通用的计算引擎 RDDs 而构建出的, 所以 <code>spark-core</code> 的 RDDs 是整个 Spark 的基础</li>
</ul>
<p><a href="https://manzhong.github.io/images/spark/zj.jpg" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/zj.jpg" alt="img"></a></p>
<h3 id="Spark和Hadoop的异同"><a href="#Spark和Hadoop的异同" class="headerlink" title="Spark和Hadoop的异同"></a>Spark和Hadoop的异同</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Hadoop</th>
<th align="left">Spark</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">基础平台, 包含计算, 存储, 调度</td>
<td align="left">分布式计算工具</td>
</tr>
<tr>
<td align="left"><strong>场景</strong></td>
<td align="left">大规模数据集上的批处理</td>
<td align="left">迭代计算, 交互式计算, 流计算</td>
</tr>
<tr>
<td align="left"><strong>延迟</strong></td>
<td align="left">大</td>
<td align="left">小</td>
</tr>
<tr>
<td align="left"><strong>易用性</strong></td>
<td align="left">API 较为底层, 算法适应性差</td>
<td align="left">API 较为顶层, 方便使用</td>
</tr>
<tr>
<td align="left"><strong>价格</strong></td>
<td align="left">对机器要求低, 便宜</td>
<td align="left">对内存有要求, 相对较贵</td>
</tr>
</tbody></table>
<h1 id="二-集群搭建"><a href="#二-集群搭建" class="headerlink" title="二 集群搭建"></a>二 集群搭建</h1><h2 id="1-spark集群结构"><a href="#1-spark集群结构" class="headerlink" title="1 spark集群结构"></a>1 spark集群结构</h2><p>Spark 自身是没有集群管理工具的, 但是如果想要管理数以千计台机器的集群, 没有一个集群管理工具还不太现实, 所以 Spark 可以借助外部的集群工具来进行管理</p>
<p>整个流程就是使用 Spark 的 Client 提交任务, 找到集群管理工具申请资源, 后将计算任务分发到集群中运行</p>
<p><a href="https://manzhong.github.io/images/spark/j.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/j.png" alt="img"></a></p>
<p>名词解释</p>
<ul>
<li><p><code>Driver</code></p>
<p>该进程调用 Spark 程序的 main 方法, 并且启动 SparkContext</p>
</li>
<li><p><code>Cluster Manager</code></p>
<p>该进程负责和外部集群工具打交道, 申请或释放集群资源</p>
</li>
<li><p><code>Worker</code></p>
<p>该进程是一个守护进程, 负责启动和管理 Executor</p>
</li>
<li><p><code>Executor</code></p>
<p>该进程是一个JVM虚拟机, 负责运行 Spark Task</p>
</li>
</ul>
<p>运行一个 Spark 程序大致经历如下几个步骤</p>
<ol>
<li>启动 Drive, 创建 SparkContext</li>
<li>Client 提交程序给 Drive, Drive <strong>向 Cluster Manager 申请集群资源</strong></li>
<li>资源申请完毕, <strong>在 Worker 中启动 Executor</strong></li>
<li>Driver 将程序转化为 Tasks, 分发给 Executor 执行</li>
</ol>
<p><strong>Spark 程序可以运行在什么地方?</strong></p>
<ul>
<li><strong>集群:</strong> 一组协同工作的计算机, 通常表现的好像是一台计算机一样, <strong>所运行的任务由软件来控制和调度</strong></li>
<li><strong>集群管理工具:</strong> 调度任务到集群的软件</li>
<li><strong>常见的集群管理工具:</strong> Hadoop Yarn, Apache Mesos, Kubernetes</li>
</ul>
<p>Spark 可以将任务运行在两种模式下:</p>
<ul>
<li><strong>单机,</strong> 使用线程模拟并行来运行程序</li>
<li><strong>集群,</strong> 使用集群管理器来和不同类型的集群交互, 将任务运行在集群中</li>
</ul>
<p>Spark 可以使用的集群管理工具有:</p>
<ul>
<li>Spark Standalone</li>
<li>Hadoop Yarn</li>
<li>Apache Mesos</li>
<li>Kubernetes</li>
</ul>
<p><strong>Driver 和 Worker 什么时候被启动?</strong></p>
<p><a href="https://manzhong.github.io/images/spark/s.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/s.png" alt="img"></a></p>
<ul>
<li>Standalone 集群中, 分为两个角色: Master 和 Slave, 而 Slave 就是 Worker, 所以在 Standalone 集群中, 启动之初就会创建固定数量的 Worker</li>
<li>Driver 的启动分为两种模式: Client 和 Cluster. 在 Client 模式下, Driver 运行在 Client 端, 在 Client 启动的时候被启动. 在 Cluster 模式下, Driver 运行在某个 Worker 中, 随着应用的提交而启动</li>
</ul>
<p><a href="https://manzhong.github.io/images/spark/ya.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/ya.png" alt="img"></a></p>
<ul>
<li>在 Yarn 集群模式下, 也依然分为 Client 模式和 Cluster 模式, 较新的版本中已经逐渐在废弃 Client 模式了, 所以上图所示为 Cluster 模式</li>
<li>如果要在 Yarn 中运行 Spark 程序, 首先会和 RM 交互, 开启 ApplicationMaster, 其中运行了 Driver, Driver创建基础环境后, 会由 RM 提供对应的容器, 运行 Executor, Executor会反向向 Driver 反向注册自己, 并申请 Tasks 执行</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><code>Master</code> 负责总控, 调度, 管理和协调 Worker, 保留资源状况等</li>
<li><code>Slave</code> 对应 Worker 节点, 用于启动 Executor 执行 Tasks, 定期向 Master汇报</li>
<li><code>Driver</code> 运行在 Client 或者 Slave(Worker) 中, 默认运行在 Slave(Worker) 中</li>
</ul>
<h2 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2 集群搭建"></a>2 集群搭建</h2><p><strong>集群规划</strong></p>
<table>
<thead>
<tr>
<th align="left">Node01</th>
<th align="left">Node02</th>
<th align="left">Node03</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Master</td>
<td align="left">Slave</td>
<td align="left">Slave</td>
</tr>
<tr>
<td align="left">History Server</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="2-1-下载解压"><a href="#2-1-下载解压" class="headerlink" title="2.1 下载解压"></a>2.1 下载解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网址</span><br><span class="line">https://archive.apache.org/dist/spark/spark-2.2.0/spark-2.2.0-bin-hadoop2.7.tgz</span><br><span class="line">上传解压</span><br><span class="line">tar -xzvf spark-2.2.0-bin-hadoop2.7.tgz -C /path</span><br></pre></td></tr></table></figure>

<p>解压后改名为spark</p>
<p>修改配置文件<code>spark-env.sh</code>, 以指定运行参数</p>
<ul>
<li><p>进入配置目录, 并复制一份新的配置文件, 以供在此基础之上进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark/conf</span><br><span class="line">cp spark-env.sh.template spark-env.sh</span><br><span class="line">vi spark-env.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下内容复制进配置文件末尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 指定 Java Home</span><br><span class="line">export JAVA_HOME=/export/servers/jdk1.8.0_141</span><br><span class="line"></span><br><span class="line"># 指定 Spark Master 地址</span><br><span class="line">export SPARK_MASTER_HOST=node01</span><br><span class="line">export SPARK_MASTER_PORT=7077</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><ol>
<li><p>修改配置文件 <code>slaves</code>, 以指定从节点为止, 从在使用 <code>sbin/start-all.sh</code> 启动集群的时候, 可以一键启动整个集群所有的 Worker</p>
<ul>
<li><p>进入配置目录, 并复制一份新的配置文件, 以供在此基础之上进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark/conf</span><br><span class="line">cp slaves.template slaves</span><br><span class="line">vi slaves</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置所有从节点的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node02</span><br><span class="line">node03</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置 <code>HistoryServer</code></p>
<ol>
<li><p>默认情况下, Spark 程序运行完毕后, 就无法再查看运行记录的 Web UI 了, 通过 HistoryServer 可以提供一个服务, 通过读取日志文件, 使得我们可以在程序运行结束后, 依然能够查看运行过程</p>
</li>
<li><p>复制 <code>spark-defaults.conf</code>, 以供修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark/conf</span><br><span class="line">cp spark-defaults.conf.template spark-defaults.conf</span><br><span class="line">vi spark-defaults.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下内容复制到<code>spark-defaults.conf</code>末尾处, 通过这段配置, 可以指定 Spark 将日志输入到 HDFS 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark.eventLog.enabled  true</span><br><span class="line">spark.eventLog.dir      hdfs://node01:8020/spark_log</span><br><span class="line">spark.eventLog.compress true</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下内容复制到<code>spark-env.sh</code>的<strong>末尾</strong>, 配置 HistoryServer 启动参数, 使得 HistoryServer 在启动的时候读取 HDFS 中写入的 Spark 日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定 Spark History 运行参数</span><br><span class="line">export SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=4000 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://node01:8020/spark_log&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为 Spark 创建 HDFS 中的日志目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -mkdir -p /spark_log</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="2-3-分发运行"><a href="#2-3-分发运行" class="headerlink" title="2.3 分发运行"></a>2.3 分发运行</h3><ol>
<li><p>将 Spark 安装包分发给集群中其它机器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers</span><br><span class="line">scp -r spark/ node03:$PWD</span><br><span class="line">scp -r spark/ node02:$PWD</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Spark Master 和 Slaves, 以及 HistoryServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark</span><br><span class="line">sbin/start-all.sh</span><br><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-spark集群高可用搭建"><a href="#3-spark集群高可用搭建" class="headerlink" title="3 spark集群高可用搭建"></a>3 spark集群高可用搭建</h2><p>了解如何使用 Zookeeper 帮助 Spark Standalone 高可用</p>
<p>对于 Spark Standalone 集群来说, 当 Worker 调度出现问题的时候, 会自动的弹性容错, 将出错的 Task 调度到其它 Worker 执行</p>
<p>但是对于 Master 来说, 是会出现单点失败的, 为了避免可能出现的单点失败问题, Spark 提供了两种方式满足高可用</p>
<ul>
<li>使用 Zookeeper 实现 Masters 的主备切换</li>
<li>使用文件系统做主备切换</li>
</ul>
<p>使用文件系统做主备切换的场景实在太小, 所以此处不做探讨</p>
<h3 id="3-1-停止spark集群"><a href="#3-1-停止spark集群" class="headerlink" title="3.1 停止spark集群"></a>3.1 停止spark集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark</span><br><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure>

<h3 id="3-2-修改配置文件-增加-Spark-运行时参数-从而指定-Zookeeper-的位置"><a href="#3-2-修改配置文件-增加-Spark-运行时参数-从而指定-Zookeeper-的位置" class="headerlink" title="3.2 修改配置文件, 增加 Spark 运行时参数, 从而指定 Zookeeper 的位置"></a>3.2 <strong>修改配置文件, 增加 Spark 运行时参数, 从而指定 Zookeeper 的位置</strong></h3><ol>
<li><p>进入 <code>spark-env.sh</code> 所在目录, 打开 vi 编辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark/conf</span><br><span class="line">vi spark-env.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>spark-env.sh</code>, 添加 Spark 启动参数, 并去掉 SPARK_MASTER_HOST 地址</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 指定 Java Home</span><br><span class="line">export JAVA_HOME=/export/servers/jdk1.8.0_141</span><br><span class="line"></span><br><span class="line"># 指定 Spark Master 地址</span><br><span class="line"># export SPARK_MASTER_HOST=node01            //这个注释掉  修改1</span><br><span class="line">export SPARK_MASTER_PORT=7077</span><br><span class="line"></span><br><span class="line"># 指定 Spark History 运行参数</span><br><span class="line">export SPARK_HISTORY_OPTS=&quot;-Dspark.history.ui.port=4000 -Dspark.history.retainedApplications=3 -Dspark.history.fs.logDirectory=hdfs://node01:8020/spark_log&quot;</span><br><span class="line"></span><br><span class="line"># 指定 Spark 运行时参数                      //添加  修改2</span><br><span class="line">export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=node01:2181,node02:2181,node03:2181 -Dspark.deploy.zookeeper.dir=/spark&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-分发配置文件到整个集群"><a href="#3-3-分发配置文件到整个集群" class="headerlink" title="3.3 分发配置文件到整个集群"></a>3.3 <strong>分发配置文件到整个集群</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark/conf</span><br><span class="line">scp spark-env.sh node02:$PWD</span><br><span class="line">scp spark-env.sh node03:$PWD</span><br></pre></td></tr></table></figure>

<h3 id="3-4-启动"><a href="#3-4-启动" class="headerlink" title="3.4 启动"></a>3.4 启动</h3><ol>
<li><p>在 <code>node01</code> 上启动整个集群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark</span><br><span class="line">sbin/start-all.sh</span><br><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>node02</code> 上单独再启动一个 Master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark</span><br><span class="line">sbin/start-master.sh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-5-查看-node01-master-和-node02-master-的-WebUI"><a href="#3-5-查看-node01-master-和-node02-master-的-WebUI" class="headerlink" title="3.5 查看 node01 master 和 node02 master 的 WebUI"></a>3.5 <strong>查看</strong> <code>node01 master</code> <strong>和</strong> <code>node02 master</code> <strong>的 WebUI</strong></h3><p>你会发现一个是 <code>ALIVE(主)</code>, 另外一个是 <code>STANDBY(备)</code></p>
<p>如果关闭一个, 则另外一个成为<code>ALIVE</code>, 但是这个过程可能要持续两分钟左右, 需要耐心等待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在 Node01 中执行如下指令</span><br><span class="line">cd /export/servers/spark/</span><br><span class="line">sbin/stop-master.sh</span><br></pre></td></tr></table></figure>

<p>Spark HA 选举</p>
<p>Spark HA 的 Leader 选举使用了一个叫做 Curator 的 Zookeeper 客户端来进行</p>
<p>Zookeeper 是一个分布式强一致性的协调服务, Zookeeper 最基本的一个保证是: 如果多个节点同时创建一个 ZNode, 只有一个能够成功创建. 这个做法的本质使用的是 Zookeeper 的 ZAB 协议, 能够在分布式环境下达成一致.</p>
<p><strong>spark各服务端口</strong></p>
<table>
<thead>
<tr>
<th align="left">Service</th>
<th align="left">port</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Master WebUI</td>
<td align="left">node01:8080</td>
</tr>
<tr>
<td align="left">Worker WebUI</td>
<td align="left">node01:8081</td>
</tr>
<tr>
<td align="left">History Server</td>
<td align="left">node01:4000</td>
</tr>
</tbody></table>
<h2 id="4-第一个应用程序"><a href="#4-第一个应用程序" class="headerlink" title="4 第一个应用程序"></a>4 第一个应用程序</h2><p>流程:</p>
<p>Step 1 进入 Spark 安装目录中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark/</span><br></pre></td></tr></table></figure>

<p>Step 2 运行 Spark 示例任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \                                //提交spark程序</span><br><span class="line">--master spark://node01:7077,node02:7077,node03:7077 \                   //master地址</span><br><span class="line">--executor-memory 1G \                                                      //这两行为参数</span><br><span class="line">--total-executor-cores 2 \</span><br><span class="line">/export/servers/spark/examples/jars/spark-examples_2.11-2.2.0.jar \                 //指定jar包位置</span><br><span class="line">100                                                                      //会提交到spark程序中</span><br></pre></td></tr></table></figure>

<p>Step 3 运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pi is roughly 3.1424627142462715</span><br></pre></td></tr></table></figure>

<p>刚才所运行的程序是 Spark 的一个示例程序, 使用 Spark 编写了一个以蒙特卡洛算法来计算圆周率的任务</p>
<ul>
<li>蒙特卡洛算法概述</li>
</ul>
<p><a href="https://manzhong.github.io/images/spark/sf.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/sf.png" alt="img"></a></p>
<p>通过迭代循环投点的方式实现蒙特卡洛算法求圆周率</p>
<ul>
<li><p>计算过程</p>
<p>1不断的生成随机的点, 根据点距离圆心是否超过半径来判断是否落入园内</p>
<p>2通过 来计算圆周率</p>
<p>3不断的迭代</p>
</li>
</ul>
<h1 id="三-spark入门"><a href="#三-spark入门" class="headerlink" title="三 spark入门"></a>三 spark入门</h1><p>Spark 官方提供了两种方式编写代码, 都比较重要, 分别如下</p>
<ul>
<li><p><code>spark-shell</code><br>Spark shell 是 Spark 提供的一个基于 Scala 语言的交互式解释器, 类似于 Scala 提供的交互式解释器, Spark shell 也可以直接在 Shell 中编写代码执行<br>这种方式也比较重要, 因为一般的数据分析任务可能需要探索着进行, 不是一蹴而就的, 使用 Spark shell 先进行探索, 当代码稳定以后, 使用独立应用的方式来提交任务, 这样是一个比较常见的流程</p>
</li>
<li><p><code>spark-submit</code><br>Spark submit 是一个命令, 用于提交 Scala 编写的基于 Spark 框架, 这种提交方式常用作于在集群中运行任务</p>
<p>上面的计算pi就是一个spark-submit</p>
</li>
</ul>
<h2 id="1-Spark-shell-的方式编写-WordCount-本地文件"><a href="#1-Spark-shell-的方式编写-WordCount-本地文件" class="headerlink" title="1 Spark shell 的方式编写 WordCount (本地文件)"></a>1 Spark shell 的方式编写 WordCount (本地文件)</h2><p>Spark shell 简介</p>
<ul>
<li>启动 Spark shell<br>进入 Spark 安装目录后执行 <code>spark-shell --master master</code> 就可以提交Spark 任务</li>
<li>Spark shell 的原理是把每一行 Scala 代码编译成类, 最终交由 Spark 执行</li>
</ul>
<p><strong>Master地址的设置</strong></p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>local[N]</code></td>
<td align="left">使用 N 条 Worker 线程在本地运行</td>
</tr>
<tr>
<td align="left"><code>spark://host:port</code></td>
<td align="left">在 Spark standalone 中运行, 指定 Spark 集群的 Master 地址, 端口默认为 7077</td>
</tr>
<tr>
<td align="left"><code>mesos://host:port</code></td>
<td align="left">在 Apache Mesos 中运行, 指定 Mesos 的地址</td>
</tr>
<tr>
<td align="left"><code>yarn</code></td>
<td align="left">在 Yarn 中运行, Yarn 的地址由环境变量 <code>HADOOP_CONF_DIR</code> 来指定</td>
</tr>
</tbody></table>
<p>接下来使用 Spark shell 的方式编写一个 WordCount</p>
<h3 id="1-1-准备文件"><a href="#1-1-准备文件" class="headerlink" title="1.1 准备文件"></a>1.1 准备文件</h3><p>在 Node01 中创建文件 <code>/export/data/wordcount.txt</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word,hello,world,hadoop</span><br><span class="line">hive,sqoop,flume,hello</span><br><span class="line">kitty,tom,jerry,world</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure>

<h3 id="2-2-启动spark-shell-本地线程模式"><a href="#2-2-启动spark-shell-本地线程模式" class="headerlink" title="2.2 启动spark-shell 本地线程模式"></a>2.2 启动spark-shell 本地线程模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/servers/spark</span><br><span class="line">bin/spark-shell --master local[2]</span><br></pre></td></tr></table></figure>

<h3 id="2-3-执行代码"><a href="#2-3-执行代码" class="headerlink" title="2.3 执行代码"></a>2.3 执行代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取文件</span><br><span class="line">val rdd1=sc.textFile(&quot;file:///export/test/wordcount.txt&quot;)</span><br><span class="line">//获取单个单词</span><br><span class="line">val rdd2=rdd1.flatMap(_.split(&quot;,&quot;))   相当于 (item =&gt; item.split(&quot;,&quot;))</span><br><span class="line">//给每个单词 符频次  组成元组</span><br><span class="line">val rdd3=rdd2.map((_,1))              相当于 (item =&gt;(item,1))</span><br><span class="line">//聚合得到最终结果</span><br><span class="line">val rdd4=rdd3.reduceByKey(_ + _)      相当于 ((curr,age) =&gt; curr + age)   这一步并未求值</span><br><span class="line">//打印解结果   collect为收集数据</span><br><span class="line">val res=rdd4.collect                  在这一步才求值</span><br></pre></td></tr></table></figure>

<p>上述代码中 <code>sc</code> 变量指的是 SparkContext, 是 Spark 程序的上下文和入口</p>
<p>正常情况下我们需要自己创建, 但是如果使用 Spark shell 的话, Spark shell 会帮助我们创建, 并且以变量 <code>sc</code> 的形式提供给我们调用</p>
<p><strong>运行流程</strong></p>
<p><a href="https://manzhong.github.io/images/spark/yxlc.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/yxlc.png" alt="img"></a></p>
<ol>
<li><code>flatMap(_.split(&quot; &quot;))</code> 将数据转为数组的形式, 并展平为多个数据</li>
<li><code>map_, 1</code> 将数据转换为元组的形式</li>
<li><code>reduceByKey(_ + _)</code> 计算每个 Key 出现的次数</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>使用 Spark shell 可以快速验证想法</li>
<li>Spark 框架下的代码非常类似 Scala 的函数式调用</li>
</ol>
<h2 id="2-读取hdfs上的文件"><a href="#2-读取hdfs上的文件" class="headerlink" title="2 读取hdfs上的文件"></a>2 读取hdfs上的文件</h2><h3 id="2-1-上传文件呢到hdfs"><a href="#2-1-上传文件呢到hdfs" class="headerlink" title="2.1 上传文件呢到hdfs"></a>2.1 上传文件呢到hdfs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put wordcount.txt /data</span><br></pre></td></tr></table></figure>

<h3 id="2-2-在spark-shell中访问hdfs"><a href="#2-2-在spark-shell中访问hdfs" class="headerlink" title="2.2 在spark-shell中访问hdfs"></a>2.2 在spark-shell中访问hdfs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取文件</span><br><span class="line">val rdd1=sc.textFile(&quot;hdfs://node01:8020/data&quot;)  //或者(&quot;/data&quot;) spark默认的文件地址就是hdfs</span><br><span class="line">//获取单个单词</span><br><span class="line">val rdd2=rdd1.flatMap(_.split(&quot;,&quot;))   相当于 (item =&gt; item.split(&quot;,&quot;))</span><br><span class="line">//给每个单词 符频次  组成元组</span><br><span class="line">val rdd3=rdd2.map((_,1))              相当于 (item =&gt;(item,1))</span><br><span class="line">//聚合得到最终结果</span><br><span class="line">val rdd4=rdd3.reduceByKey(_ + _)      相当于 ((curr,age) =&gt; curr + age)   这一步并未求值</span><br><span class="line">//打印解结果   collect为收集数据</span><br><span class="line">val res=rdd4.collect                  在这一步才求值</span><br></pre></td></tr></table></figure>

<p>也可以通过向 Spark 配置 Hadoop 的路径, 来通过路径直接访问</p>
<ul>
<li><p>1.在 <code>spark-env.sh</code> 中添加 Hadoop 的配置路径</p>
<p><code>export HADOOP_CONF_DIR=&quot;/etc/hadoop/conf&quot;</code></p>
</li>
<li><p>2.在配置过后, 可以直接使用 <code>hdfs:///路径</code> 的形式直接访问</p>
</li>
</ul>
<p><strong>在配置过后, 也可以直接使用路径访问</strong></p>
<p>(“/data”)</p>
<h2 id="3-编写独立应用提交spark任务"><a href="#3-编写独立应用提交spark任务" class="headerlink" title="3 编写独立应用提交spark任务"></a>3 编写独立应用提交spark任务</h2><p>创建maven工程</p>
<h3 id="3-1-添加依赖"><a href="#3-1-添加依赖" class="headerlink" title="3.1 添加依赖"></a>3.1 添加依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;scala.version&gt;2.11.8&lt;/scala.version&gt;</span><br><span class="line">        &lt;spark.version&gt;2.2.0&lt;/spark.version&gt;</span><br><span class="line">        &lt;slf4j.version&gt;1.7.16&lt;/slf4j.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;scala-library&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;scala.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">         &lt;!--scala文件夹需要自己创建--&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt;</span><br><span class="line">        &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                            &lt;goal&gt;testCompile&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;args&gt;</span><br><span class="line">                                &lt;arg&gt;-dependencyfile&lt;/arg&gt;</span><br><span class="line">                                &lt;arg&gt;$&#123;project.build.directory&#125;/.scala_dependencies&lt;/arg&gt;</span><br><span class="line">                            &lt;/args&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">			 &lt;!--打包插件  因为默认的打包不包含maven的依赖--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1.1&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;filters&gt;</span><br><span class="line">                                &lt;filter&gt;</span><br><span class="line">                                    &lt;artifact&gt;*:*&lt;/artifact&gt;</span><br><span class="line">                                    &lt;excludes&gt;</span><br><span class="line">                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;</span><br><span class="line">                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;</span><br><span class="line">                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;</span><br><span class="line">                                    &lt;/excludes&gt;</span><br><span class="line">                                &lt;/filter&gt;</span><br><span class="line">                            &lt;/filters&gt;</span><br><span class="line">                            &lt;transformers&gt;</span><br><span class="line">                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                                    &lt;mainClass&gt;&lt;/mainClass&gt;</span><br><span class="line">                                &lt;/transformer&gt;</span><br><span class="line">                            &lt;/transformers&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>编写代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.nicai.sparkwordcount</span><br><span class="line"></span><br><span class="line">import org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class="line"></span><br><span class="line">object WordCount &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    //获取sparkContext上下文对象</span><br><span class="line">     val conf: SparkConf =new SparkConf().setMaster(&quot;local[2]&quot;).setAppName(&quot;word_count&quot;)</span><br><span class="line">     val sc: SparkContext = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">    //读取文件并计算频次</span><br><span class="line">    //加载文件</span><br><span class="line">    val rdd1 = sc.textFile(&quot;day24Spark/data/wc.txt&quot;)</span><br><span class="line">    val rdd2 = rdd1.flatMap(item =&gt; item.split(&quot;,&quot;))</span><br><span class="line">    val rdd3 = rdd2.map(item =&gt; (item,1))</span><br><span class="line">    val rdd4 = rdd3.reduceByKey((curr,age) =&gt; curr + age)</span><br><span class="line">    val result = rdd4.collect()</span><br><span class="line">    result.foreach(println(_))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2 运行"></a>3.2 运行</h3><p>####1以上代码可以直接在本地运行</p>
<p>若是本地运行有错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error:scalac: error while loading &lt;root&gt;, Error accessing G:\apache-maven-3.3.9\apache-maven-3.3.9\repository_pinyougou\javax\ws\rs\javax.ws.rs-api\2.0.1\javax.ws.rs-api-2.0.1.jar</span><br><span class="line">或者</span><br><span class="line">Error:scalac: error while loading &lt;root&gt;, Error accessing G:\apache-maven-3.3.9\apache-maven-3.3.9\repository_pinyougou\org\spache\commons\commons-crypto\1.0.0\commons-crypto-1.0.0.jar</span><br><span class="line"></span><br><span class="line">则这两个jar包又问题 请自己下载</span><br></pre></td></tr></table></figure>

<h4 id="2-打包在集群运行spark-submit"><a href="#2-打包在集群运行spark-submit" class="headerlink" title="2 打包在集群运行spark-submit"></a>2 打包在集群运行spark-submit</h4><p>修改代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf: SparkConf =new SparkConf().setAppName(&quot;word_count&quot;)</span><br><span class="line">val rdd1 = sc.textFile(&quot;hdfs://node01:8020/data/wc.txt&quot;)  //改为hdfs路径</span><br></pre></td></tr></table></figure>

<p>使用maven打包</p>
<p><em>spark-submit 命令</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark-submit [options] &lt;app jar&gt; &lt;app options&gt;</span><br><span class="line"></span><br><span class="line">app jar 程序 Jar 包</span><br><span class="line">app options 程序 Main 方法传入的参数</span><br><span class="line">options 提交应用的参数, 可以有如下选项</span><br></pre></td></tr></table></figure>

<p>options 参数</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>--master &lt;url&gt;</code></td>
<td align="left">同 Spark shell 的 Master, 可以是spark, yarn, mesos, kubernetes等 URL</td>
</tr>
<tr>
<td align="left"><code>--deploy-mode &lt;client or cluster&gt;</code></td>
<td align="left">Driver 运行位置, 可选 Client 和 Cluster, 分别对应运行在本地和集群(Worker)中</td>
</tr>
<tr>
<td align="left"><code>--class &lt;class full name&gt;</code></td>
<td align="left">Jar 中的 Class, 程序入口</td>
</tr>
<tr>
<td align="left"><code>--jars &lt;dependencies path&gt;</code></td>
<td align="left">依赖 Jar 包的位置</td>
</tr>
<tr>
<td align="left"><code>--driver-memory &lt;memory size&gt;</code></td>
<td align="left">Driver 程序运行所需要的内存, 默认 512M</td>
</tr>
<tr>
<td align="left"><code>--executor-memory &lt;memory size&gt;</code></td>
<td align="left">Executor 的内存大小, 默认 1G</td>
</tr>
</tbody></table>
<p>打包后有两个jar包 一个带有依赖 (大) 一个(小) 因为集群中的spark自带有Hadoop和spark的jar包 所以不需要上传大的,只需上传小的即可</p>
<p>在上传的jar包所在目录执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master spark://node01:7077 \</span><br><span class="line">--class cn.itcast.spark.WordCounts \</span><br><span class="line">original-spark-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>若想在任意目录执行 shell-submit 配置一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/profile</span><br><span class="line"></span><br><span class="line">export SPARK_BIN=/export/servers/spark/bin</span><br><span class="line">export PATH=$PATH:$SPARK_BIN</span><br><span class="line">//生效</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="4-三种方式总结"><a href="#4-三种方式总结" class="headerlink" title="4 三种方式总结"></a>4 三种方式总结</h2><p>Spark shell</p>
<ul>
<li>作用<ul>
<li>一般用作于探索阶段, 通过 Spark shell 快速的探索数据规律</li>
<li>当探索阶段结束后, 代码确定以后, 通过独立应用的形式上线运行</li>
</ul>
</li>
<li>功能<ul>
<li>Spark shell 可以选择在集群模式下运行, 还是在线程模式下运行</li>
<li>Spark shell 是一个交互式的运行环境, 已经内置好了 SparkContext 和 SparkSession 对象, 可以直接使用</li>
<li>Spark shell 一般运行在集群中安装有 Spark client 的服务器中, 所以可以自有的访问 HDFS</li>
</ul>
</li>
</ul>
<p>本地运行</p>
<ul>
<li>作用<ul>
<li>在编写独立应用的时候, 每次都要提交到集群中还是不方便, 另外很多时候需要调试程序, 所以在 IDEA 中直接运行会比较方便, 无需打包上传了</li>
</ul>
</li>
<li>功能<ul>
<li>因为本地运行一般是在开发者的机器中运行, 而不是集群中, 所以很难直接使用 HDFS 等集群服务, 需要做一些本地配置, 用的比较少</li>
<li>需要手动创建 SparkContext</li>
</ul>
</li>
</ul>
<p>集群运行</p>
<ul>
<li>作用<ul>
<li>正式环境下比较多见, 独立应用编写好以后, 打包上传到集群中, 使用<code>spark-submit</code>来运行, 可以完整的使用集群资源</li>
</ul>
</li>
<li>功能<ul>
<li>同时在集群中通过<code>spark-submit</code>来运行程序也可以选择是用线程模式还是集群模式</li>
<li>集群中运行是全功能的, HDFS 的访问, Hive 的访问都比较方便</li>
<li>需要手动创建 SparkContext</li>
</ul>
</li>
</ul>
<h1 id="四-RDD简介"><a href="#四-RDD简介" class="headerlink" title="四 RDD简介"></a>四 RDD简介</h1><p>在idea中的wc代码中</p>
<ol>
<li>使用 <code>sc.textFile()</code> 方法读取 HDFS 中的文件, 并生成一个 <code>RDD</code></li>
<li>使用 <code>flatMap</code> 算子将读取到的每一行字符串打散成单词, 并把每个单词变成新的行</li>
<li>使用 <code>map</code> 算子将每个单词转换成 <code>(word, 1)</code> 这种元组形式</li>
<li>使用 <code>reduceByKey</code> 统计单词对应的频率</li>
</ol>
<p>其中所使用到的算子有如下几个:</p>
<ul>
<li><code>flatMap</code> 是一对多</li>
<li><code>map</code> 是一对一</li>
<li><code>reduceByKey</code> 是按照 Key 聚合, 类似 MapReduce 中的 Shuffled</li>
</ul>
<h2 id="1-rdd"><a href="#1-rdd" class="headerlink" title="1 rdd"></a>1 rdd</h2><p>定义</p>
<p>RDD, 全称为 Resilient Distributed Datasets, 是一个容错的, 并行的数据结构, 可以让用户显式地将数据存储到磁盘和内存中, 并能控制数据的分区.</p>
<p>同时, RDD 还提供了一组丰富的操作来操作这些数据. 在这些操作中, 诸如 map, flatMap, filter 等转换操作实现了 Monad 模式, 很好地契合了 Scala 的集合操作. 除此之外, RDD 还提供了诸如 join, groupBy, reduceByKey 等更为方便的操作, 以支持常见的数据运算.</p>
<p>通常来讲, 针对数据处理有几种常见模型, 包括: Iterative Algorithms, Relational Queries, MapReduce, Stream Processing. 例如 Hadoop MapReduce 采用了 MapReduce 模型, Storm 则采用了 Stream Processing 模型. RDD 混合了这四种模型, 使得 Spark 可以应用于各种大数据处理场景.</p>
<p>RDD 作为数据结构, 本质上是一个只读的分区记录集合. 一个 RDD 可以包含多个分区, 每个分区就是一个 DataSet 片段.</p>
<p>RDD 之间可以相互依赖, 如果 RDD 的每个分区最多只能被一个子 RDD 的一个分区使用，则称之为窄依赖, 若被多个子 RDD 的分区依赖，则称之为宽依赖. 不同的操作依据其特性, 可能会产生不同的依赖. 例如 map 操作会产生窄依赖, 而 join 操作则产生宽依赖.</p>
<p>特点</p>
<ol>
<li>RDD 是一个编程模型<ol>
<li>RDD 允许用户显式的指定数据存放在内存或者磁盘</li>
<li>RDD 是分布式的, 用户可以控制 RDD 的分区</li>
</ol>
</li>
<li>RDD 是一个编程模型<ol>
<li>RDD 提供了丰富的操作</li>
<li>RDD 提供了 map, flatMap, filter 等操作符, 用以实现 Monad 模式</li>
<li>RDD 提供了 reduceByKey, groupByKey 等操作符, 用以操作 Key-Value 型数据</li>
<li>RDD 提供了 max, min, mean 等操作符, 用以操作数字型的数据</li>
</ol>
</li>
<li>RDD 是混合型的编程模型, 可以支持迭代计算, 关系查询, MapReduce, 流计算</li>
<li>RDD 是只读的</li>
<li>RDD 之间有依赖关系, 根据执行操作的操作符的不同, 依赖关系可以分为宽依赖和窄依赖</li>
</ol>
<h2 id="2-rdd-分区"><a href="#2-rdd-分区" class="headerlink" title="2 rdd 分区"></a>2 rdd 分区</h2><p><a href="https://manzhong.github.io/images/spark/rddf.png" target="_blank" rel="noopener"><img src="https://manzhong.github.io/images/spark/rddf.png" alt="img"></a></p>
<p>整个 WordCount 案例的程序从结构上可以用上图表示, 分为两个大部分</p>
<p>存储</p>
<p>文件如果存放在 HDFS 上, 是分块的, 类似上图所示, 这个 <code>wordcount.txt</code> 分了三块</p>
<p>计算</p>
<p>Spark 不止可以读取 HDFS, Spark 还可以读取很多其它的数据集, Spark 可以从数据集中创建出 RDD</p>
<p>例如上图中, 使用了一个 RDD 表示 HDFS 上的某一个文件, 这个文件在 HDFS 中是分三块, 那么 RDD 在读取的时候就也有三个分区, 每个 RDD 的分区对应了一个 HDFS 的分块</p>
<p>后续 RDD 在计算的时候, 可以更改分区, 也可以保持三个分区, 每个分区之间有依赖关系, 例如说 RDD2 的分区一依赖了 RDD1 的分区一</p>
<p>RDD 之所以要设计为有分区的, 是因为要进行分布式计算, 每个不同的分区可以在不同的线程, 或者进程, 甚至节点中, 从而做到并行计算</p>
<p><strong>总结</strong></p>
<ol>
<li>RDD 是弹性分布式数据集</li>
<li>RDD 一个非常重要的前提和基础是 RDD 运行在分布式环境下, 其可以分区</li>
</ol>
<h2 id="3-创建rdd"><a href="#3-创建rdd" class="headerlink" title="3 创建rdd"></a>3 创建rdd</h2><p>程序入口 SparkContext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setMaster(&quot;local[2]&quot;)</span><br><span class="line">val sc: SparkContext = new SparkContext(conf)</span><br></pre></td></tr></table></figure>

<p><code>SparkContext</code> 是 spark-core 的入口组件, 是一个 Spark 程序的入口, 在 Spark 0.x 版本就已经存在 <code>SparkContext</code> 了, 是一个元老级的 API</p>
<p>如果把一个 Spark 程序分为前后端, 那么服务端就是可以运行 Spark 程序的集群, 而 <code>Driver</code> 就是 Spark 的前端, 在 <code>Driver</code>中 <code>SparkContext</code> 是最主要的组件, 也是 <code>Driver</code> 在运行时首先会创建的组件, 是 <code>Driver</code> 的核心</p>
<p><code>SparkContext</code> 从提供的 API 来看, 主要作用是连接集群, 创建 RDD, 累加器, 广播变量等</p>
<p>简略的说, RDD 有三种创建方式</p>
<ul>
<li>RDD 可以通过本地集合直接创建</li>
<li>RDD 也可以通过读取外部数据集来创建</li>
<li>RDD 也可以通过其它的 RDD 衍生而来</li>
</ul>
<p>###1 通过本地集合直接创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setMaster(&quot;local[2]&quot;)</span><br><span class="line">val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">val list = List(1, 2, 3, 4, 5, 6)</span><br><span class="line">val rddParallelize = sc.parallelize(list, 2)</span><br><span class="line">val rddMake = sc.makeRDD(list, 2)</span><br></pre></td></tr></table></figure>

<p>通过 <code>parallelize</code> 和 <code>makeRDD</code> 这两个 API 可以通过本地集合创建 RDD</p>
<p>这两个 API 本质上是一样的, 在 <code>makeRDD</code> 这个方法的内部, 最终也是调用了 <code>parallelize</code></p>
<p>因为不是从外部直接读取数据集的, 所以没有外部的分区可以借鉴, 于是在这两个方法都都有两个参数, 第一个参数是本地集合, 第二个参数是分区数</p>
<h3 id="2-通过读取外部文件创建-RDD"><a href="#2-通过读取外部文件创建-RDD" class="headerlink" title="2 通过读取外部文件创建 RDD"></a>2 <strong>通过读取外部文件创建 RDD</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setMaster(&quot;local[2]&quot;)</span><br><span class="line">val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">val source: RDD[String] = sc.textFile(&quot;hdfs://node01:8020/dataset/wordcount.txt&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>访问方式<ul>
<li>支持访问文件夹, 例如 <code>sc.textFile(&quot;hdfs:///dataset&quot;)</code></li>
<li>支持访问压缩文件, 例如 <code>sc.textFile(&quot;hdfs:///dataset/words.gz&quot;)</code></li>
<li>支持通过通配符访问, 例如 <code>sc.textFile(&quot;hdfs:///dataset/*.txt&quot;)</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">如果把 Spark 应用跑在集群上, 则 Worker 有可能在任何一个节点运行所以如果使用 <code>file:///…;</code> 形式访问本地文件的话, 要确保所有的 Worker 中对应路径上有这个文件, 否则可能会报错无法找到文件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>分区<ul>
<li>默认情况下读取 HDFS 中文件的时候, 每个 HDFS 的 <code>block</code> 对应一个 RDD 的 <code>partition</code>, <code>block</code> 的默认是128M</li>
<li>通过第二个参数, 可以指定分区数量, 例如 <code>sc.textFile(&quot;hdfs://node01:8020/dataset/wordcount.txt&quot;, 20)</code></li>
<li>如果通过第二个参数指定了分区, 这个分区数量一定不能小于<code>block</code>数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">通常每个 CPU core 对应 2 - 4 个分区是合理的值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>支持的平台<ul>
<li>支持 Hadoop 的几乎所有数据格式, 支持 HDFS 的访问</li>
<li>通过第三方的支持, 可以访问AWS和阿里云中的文件, 详情查看对应平台的 API</li>
</ul>
</li>
</ul>
<h3 id="3-通过其它的-RDD-衍生新的-RDD"><a href="#3-通过其它的-RDD-衍生新的-RDD" class="headerlink" title="3 通过其它的 RDD 衍生新的 RDD"></a>3 <strong>通过其它的 RDD 衍生新的 RDD</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setMaster(&quot;local[2]&quot;)</span><br><span class="line">val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">val source: RDD[String] = sc.textFile(&quot;hdfs://node01:8020/dataset/wordcount.txt&quot;, 20)</span><br><span class="line">val words = source.flatMap &#123; line =&gt; line.split(&quot; &quot;) &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source</code> 是通过读取 HDFS 中的文件所创建的</li>
<li><code>words</code> 是通过 <code>source</code> 调用算子 <code>map</code> 生成的新 RDD</li>
</ul>
<p><strong>总结</strong></p>
<p>RDD 的可以通过三种方式创建, 通过本地集合创建, 通过外部数据集创建, 通过其它的 RDD 衍生</p>
<h2 id="4-rdd算子"><a href="#4-rdd算子" class="headerlink" title="4 rdd算子"></a>4 rdd算子</h2><h3 id="1-Map-算子"><a href="#1-Map-算子" class="headerlink" title="1 Map 算子"></a>1 Map 算子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize(Seq(1, 2, 3))</span><br><span class="line">  .map( num =&gt; num * 10 )</span><br><span class="line">  .collect()</span><br></pre></td></tr></table></figure>

<p>作用</p>
<p>把 RDD 中的数据 一对一 的转为另一种形式</p>
<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def map[U: ClassTag](f: T ⇒ U): RDD[U]</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p><code>f</code> → Map 算子是 <code>原RDD → 新RDD</code> 的过程, 这个函数的参数是原 RDD 数据, 返回值是经过函数转换的新 RDD 的数据</p>
<p>注意点</p>
<p>Map 是一对一, 如果函数是 <code>String → Array[String]</code> 则新的 RDD 中每条数据就是一个数组</p>
<h3 id="2-FlatMap"><a href="#2-FlatMap" class="headerlink" title="2 FlatMap"></a>2 FlatMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize(Seq(&quot;Hello lily&quot;, &quot;Hello lucy&quot;, &quot;Hello tim&quot;))</span><br><span class="line">  .flatMap( line =&gt; line.split(&quot; &quot;) )</span><br><span class="line">  .collect()</span><br></pre></td></tr></table></figure>

<p>作用</p>
<p>FlatMap 算子和 Map 算子类似, 但是 FlatMap 是一对多</p>
<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def flatMap[U: ClassTag](f: T ⇒ List[U]): RDD[U]</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p><code>f</code> → 参数是原 RDD 数据, 返回值是经过函数转换的新 RDD 的数据, 需要注意的是返回值是一个集合, 集合中的数据会被展平后再放入新的 RDD</p>
<p>注意点</p>
<p>flatMap 其实是两个操作, 是 <code>map + flatten</code>, 也就是先转换, 后把转换而来的 List 展开</p>
<h3 id="3ReduceByKey"><a href="#3ReduceByKey" class="headerlink" title="3ReduceByKey"></a>3ReduceByKey</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize(Seq((&quot;a&quot;, 1), (&quot;a&quot;, 1), (&quot;b&quot;, 1)))</span><br><span class="line">  .reduceByKey( (curr, agg) =&gt; curr + agg )</span><br><span class="line">  .collect()</span><br></pre></td></tr></table></figure>

<p>作用</p>
<p>首先按照 Key 分组, 接下来把整组的 Value 计算出一个聚合值, 这个操作非常类似于 MapReduce 中的 Reduce</p>
<p>调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def reduceByKey(func: (V, V) ⇒ V): RDD[(K, V)]</span><br></pre></td></tr></table></figure>

<p>参数</p>
<p>func → 执行数据处理的函数, 传入两个参数, 一个是当前值, 一个是局部汇总, 这个函数需要有一个输出, 输出就是这个 Key 的汇总结果</p>
<p>注意点</p>
<ul>
<li>ReduceByKey 只能作用于 Key-Value 型数据, Key-Value 型数据在当前语境中特指 Tuple2</li>
<li>ReduceByKey 是一个需要 Shuffled 的操作</li>
<li>和其它的 Shuffled 相比, ReduceByKey是高效的, 因为类似 MapReduce 的, 在 Map 端有一个 Cominer, 这样 I/O 的数据便会减少</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>map 和 flatMap 算子都是转换, 只是 flatMap 在转换过后会再执行展开, 所以 map 是一对一, flatMap 是一对多</li>
<li>reduceByKey 类似 MapReduce 中的 Reduce</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/Spark入门/" data-id="cjz25rjbs000od8u5u93hdv7l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SparkRDD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/08/SparkRDD/" class="article-date">
  <time datetime="2019-08-08T03:54:26.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/08/SparkRDD/">SparkRDD</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/08/SparkRDD/" data-id="cjz25rjaj0002d8u5p9ijj7t0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/08/Hbase/">Hbase</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Hbase增强/">Hbase增强</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Storm/">Storm</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Scala入门/">Scala入门</a>
          </li>
        
          <li>
            <a href="/2019/08/08/Scala进阶1/">Scala进阶1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>